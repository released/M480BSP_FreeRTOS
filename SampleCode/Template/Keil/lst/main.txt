; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -I..\CPU -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;252    
;;;253    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;254    {
;;;255    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;256    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;257    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;258    	
;;;259    }
;;;260    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;260    
;;;261    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L2.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L2.10|
;;;262    {
;;;263        /*---------------------------------------------------------------------------------------------------------*/
;;;264        /* Init System Clock                                                                                       */
;;;265        /*---------------------------------------------------------------------------------------------------------*/
;;;266        /* Unlock protected registers */
;;;267        SYS_UnlockReg();
;;;268    
;;;269        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;270        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2040          MOV      r0,#0x40004000
000022  f8d01140          LDR      r1,[r0,#0x140]
000026  f02101f0          BIC      r1,r1,#0xf0
00002a  f8c01140          STR      r1,[r0,#0x140]
;;;271    
;;;272        /* Enable External XTAL (4~24 MHz) */
;;;273        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;274    
;;;275        /* Waiting for 12MHz clock ready */
;;;276        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       CLK_WaitClockReady
;;;277    
;;;278        /* Set core clock as PLL_CLOCK from PLL */
;;;279        CLK_SetCoreClock(FREQ_192MHZ);
00003a  4810              LDR      r0,|L2.124|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;280        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;281        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;282    
;;;283        /* Enable UART clock */
;;;284        CLK_EnableModuleClock(UART0_MODULE);
000046  4d0e              LDR      r5,|L2.128|
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       CLK_EnableModuleClock
;;;285    
;;;286        /* Select UART clock source from HXT */
;;;287        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
00004e  2200              MOVS     r2,#0
000050  4611              MOV      r1,r2
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       CLK_SetModuleClock
;;;288    
;;;289    	TIMER0_HW_Init();
000058  f7fffffe          BL       TIMER0_HW_Init
;;;290    	TIMER1_HW_Init();
00005c  f7fffffe          BL       TIMER1_HW_Init
;;;291    	
;;;292        /* Update System Core Clock */
;;;293        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;294        SystemCoreClockUpdate();
000060  f7fffffe          BL       SystemCoreClockUpdate
;;;295    
;;;296        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;297        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000064  6be0              LDR      r0,[r4,#0x3c]
000066  f420007f          BIC      r0,r0,#0xff0000
00006a  63e0              STR      r0,[r4,#0x3c]
;;;298        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00006c  6be0              LDR      r0,[r4,#0x3c]
00006e  f44000cc          ORR      r0,r0,#0x660000
000072  63e0              STR      r0,[r4,#0x3c]
000074  2000              MOVS     r0,#0
000076  f8c40100          STR      r0,[r4,#0x100]
;;;299    
;;;300     
;;;301    	
;;;302        /* Lock protected registers */
;;;303        SYS_LockReg();
;;;304    }
00007a  bd70              POP      {r4-r6,pc}
;;;305    
                          ENDP

                  |L2.124|
                          DCD      0x0b71b000
                  |L2.128|
                          DCD      0x57803d10

                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;241    
;;;242    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;243    {
;;;244    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L3.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;245    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;246    }
;;;247    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;247    
;;;248    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;249    {
;;;250    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L4.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;251    }
;;;252    
                          ENDP

                  |L4.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;227    
;;;228    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;229    {
;;;230        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L5.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;231        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;232    }
;;;233    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;233    
;;;234    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;235    {
;;;236        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L6.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
00001a  4905              LDR      r1,|L6.48|
00001c  2002              MOVS     r0,#2
00001e  f8c10100          STR      r0,[r1,#0x100]
000022  6820              LDR      r0,[r4,#0]
000024  f0404080          ORR      r0,r0,#0x40000000
000028  6020              STR      r0,[r4,#0]
;;;237        TIMER_EnableInt(TIMER1);
;;;238        NVIC_EnableIRQ(TMR1_IRQn);	
;;;239        TIMER_Start(TIMER1);
;;;240    }
00002a  bd10              POP      {r4,pc}
;;;241    
                          ENDP

                  |L6.44|
                          DCD      0x40050100
                  |L6.48|
                          DCD      0xe000e004

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;210    
;;;211    void TMR1_IRQHandler(void)
000000  4808              LDR      r0,|L7.36|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;212    {
000008  2900              CMP      r1,#0
00000a  d00a              BEQ      |L7.34|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;213    	static uint16_t CNT = 0;	
;;;214    //	static uint32_t log = 0;	
;;;215    	
;;;216        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;217        {
;;;218            TIMER_ClearIntFlag(TIMER1);
;;;219    	
;;;220    		if (CNT++ > 1000)
000010  4905              LDR      r1,|L7.40|
000012  8848              LDRH     r0,[r1,#2]  ; CNT
000014  1c42              ADDS     r2,r0,#1
000016  804a              STRH     r2,[r1,#2]
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d901              BLS      |L7.34|
;;;221    		{		
;;;222    			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  8048              STRH     r0,[r1,#2]
                  |L7.34|
;;;223    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;224    		}
;;;225        }
;;;226    }
000022  4770              BX       lr
;;;227    
                          ENDP

                  |L7.36|
                          DCD      0x40050100
                  |L7.40|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;313    
;;;314    int main()
000000  b51c              PUSH     {r2-r4,lr}
;;;315    {	
;;;316        SYS_Init();
000002  f7fffffe          BL       SYS_Init
;;;317        /* Init UART to 115200-8n1 for print message */
;;;318        UART_Open(UART0, 115200);
000006  f44f31e1          MOV      r1,#0x1c200
00000a  483a              LDR      r0,|L8.244|
00000c  f7fffffe          BL       UART_Open
;;;319    
;;;320    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000010  f7fffffe          BL       vTaskSuspendAll
000014  f7fffffe          BL       CLK_GetCPUFreq
000018  4601              MOV      r1,r0
00001a  a037              ADR      r0,|L8.248|
00001c  f7fffffe          BL       __2printf
000020  483c              LDR      r0,|L8.276|
000022  f7fffffe          BL       fflush
000026  f7fffffe          BL       xTaskResumeAll
;;;321    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00002a  f7fffffe          BL       vTaskSuspendAll
00002e  f7fffffe          BL       CLK_GetHXTFreq
000032  4601              MOV      r1,r0
000034  a038              ADR      r0,|L8.280|
000036  f7fffffe          BL       __2printf
00003a  4836              LDR      r0,|L8.276|
00003c  f7fffffe          BL       fflush
000040  f7fffffe          BL       xTaskResumeAll
;;;322    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000044  f7fffffe          BL       vTaskSuspendAll
000048  f7fffffe          BL       CLK_GetLXTFreq
00004c  4601              MOV      r1,r0
00004e  a038              ADR      r0,|L8.304|
000050  f7fffffe          BL       __2printf
000054  482f              LDR      r0,|L8.276|
000056  f7fffffe          BL       fflush
00005a  f7fffffe          BL       xTaskResumeAll
;;;323    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00005e  f7fffffe          BL       vTaskSuspendAll
000062  f7fffffe          BL       CLK_GetPCLK0Freq
000066  4601              MOV      r1,r0
000068  a037              ADR      r0,|L8.328|
00006a  f7fffffe          BL       __2printf
00006e  4829              LDR      r0,|L8.276|
000070  f7fffffe          BL       fflush
000074  f7fffffe          BL       xTaskResumeAll
;;;324    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000078  f7fffffe          BL       vTaskSuspendAll
00007c  f7fffffe          BL       CLK_GetPCLK1Freq
000080  4601              MOV      r1,r0
000082  a038              ADR      r0,|L8.356|
000084  f7fffffe          BL       __2printf
000088  4822              LDR      r0,|L8.276|
00008a  f7fffffe          BL       fflush
00008e  f7fffffe          BL       xTaskResumeAll
;;;325    
;;;326    	LED_Init();
000092  f7fffffe          BL       LED_Init
;;;327    	TIMER1_Init();
000096  f7fffffe          BL       TIMER1_Init
;;;328    
;;;329        xTaskCreate( vTask_10ms, "10ms"				,configMINIMAL_STACK_SIZE 	, NULL	,mainNORMAL_TASK_PRIORITY		, NULL);
00009a  2400              MOVS     r4,#0
00009c  9400              STR      r4,[sp,#0]
00009e  4623              MOV      r3,r4
0000a0  2280              MOVS     r2,#0x80
0000a2  a137              ADR      r1,|L8.384|
0000a4  4838              LDR      r0,|L8.392|
0000a6  9401              STR      r4,[sp,#4]
0000a8  f7fffffe          BL       xTaskCreate
;;;330        xTaskCreate( vTask_50ms, "50ms"				,configMINIMAL_STACK_SIZE 	, NULL	,mainNORMAL_TASK_PRIORITY		, NULL);
0000ac  9400              STR      r4,[sp,#0]
0000ae  2300              MOVS     r3,#0
0000b0  2280              MOVS     r2,#0x80
0000b2  a136              ADR      r1,|L8.396|
0000b4  4837              LDR      r0,|L8.404|
0000b6  9401              STR      r4,[sp,#4]
0000b8  f7fffffe          BL       xTaskCreate
;;;331        xTaskCreate( vTask_100ms, "100ms"			,configMINIMAL_STACK_SIZE 	, NULL	,mainNORMAL_TASK_PRIORITY		, NULL);
0000bc  9400              STR      r4,[sp,#0]
0000be  2300              MOVS     r3,#0
0000c0  2280              MOVS     r2,#0x80
0000c2  a135              ADR      r1,|L8.408|
0000c4  4836              LDR      r0,|L8.416|
0000c6  9401              STR      r4,[sp,#4]
0000c8  f7fffffe          BL       xTaskCreate
;;;332    
;;;333    	//function flag enable and create sub task
;;;334    	xTaskCreate(vTask_RisingFlag	,"RisingFlag"		,configMINIMAL_STACK_SIZE	,NULL	,mainNORMAL_TASK_PRIORITY		,NULL);   	
0000cc  9400              STR      r4,[sp,#0]
0000ce  2300              MOVS     r3,#0
0000d0  2280              MOVS     r2,#0x80
0000d2  a134              ADR      r1,|L8.420|
0000d4  4836              LDR      r0,|L8.432|
0000d6  9401              STR      r4,[sp,#4]
0000d8  f7fffffe          BL       xTaskCreate
;;;335    	xTaskCreate(vTask_CreateTask	,"CreateTask"		,configMINIMAL_STACK_SIZE	,NULL	,mainNORMAL_TASK_PRIORITY		,NULL); 
0000dc  9400              STR      r4,[sp,#0]
0000de  2300              MOVS     r3,#0
0000e0  2280              MOVS     r2,#0x80
0000e2  a134              ADR      r1,|L8.436|
0000e4  4836              LDR      r0,|L8.448|
0000e6  9401              STR      r4,[sp,#4]
0000e8  f7fffffe          BL       xTaskCreate
;;;336    	
;;;337        vTaskStartScheduler();
0000ec  f7fffffe          BL       vTaskStartScheduler
                  |L8.240|
;;;338    
;;;339        for( ;; );
0000f0  e7fe              B        |L8.240|
;;;340    
;;;341    
;;;342    }
;;;343    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L8.244|
                          DCD      0x40070000
                  |L8.248|
0000f8  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
0000fc  4b5f4765
000100  74435055
000104  46726571
000108  203a2025
00010c  38640d0a
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L8.276|
                          DCD      __stdout
                  |L8.280|
000118  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
00011c  47657448
000120  58544672
000124  6571203a
000128  20253864
00012c  0d0a00  
00012f  00                DCB      0
                  |L8.304|
000130  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
000134  4765744c
000138  58544672
00013c  6571203a
000140  20253864
000144  0d0a00  
000147  00                DCB      0
                  |L8.328|
000148  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
00014c  47657450
000150  434c4b30
000154  46726571
000158  203a2025
00015c  38640d0a
000160  00      
000161  00                DCB      0
000162  00                DCB      0
000163  00                DCB      0
                  |L8.356|
000164  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
000168  47657450
00016c  434c4b31
000170  46726571
000174  203a2025
000178  38640d0a
00017c  00      
00017d  00                DCB      0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L8.384|
000180  31306d73          DCB      "10ms",0
000184  00      
000185  00                DCB      0
000186  00                DCB      0
000187  00                DCB      0
                  |L8.392|
                          DCD      vTask_10ms
                  |L8.396|
00018c  35306d73          DCB      "50ms",0
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0
                  |L8.404|
                          DCD      vTask_50ms
                  |L8.408|
000198  3130306d          DCB      "100ms",0
00019c  7300    
00019e  00                DCB      0
00019f  00                DCB      0
                  |L8.416|
                          DCD      vTask_100ms
                  |L8.420|
0001a4  52697369          DCB      "RisingFlag",0
0001a8  6e67466c
0001ac  616700  
0001af  00                DCB      0
                  |L8.432|
                          DCD      vTask_RisingFlag
                  |L8.436|
0001b4  43726561          DCB      "CreateTask",0
0001b8  74655461
0001bc  736b00  
0001bf  00                DCB      0
                  |L8.448|
                          DCD      vTask_CreateTask

                          AREA ||i.vApplicationMallocFailedHook||, CODE, READONLY, ALIGN=1

                  vApplicationMallocFailedHook PROC
;;;180    
;;;181    __weak void vApplicationMallocFailedHook( void )
000000  2050              MOVS     r0,#0x50
000002  f3808811          MSR      BASEPRI,r0
000006  f3bf8f4f          DSB      
00000a  f3bf8f6f          ISB      
                  |L9.14|
;;;182    {
;;;183    	/* vApplicationMallocFailedHook() will only be called if
;;;184    	configUSE_MALLOC_FAILED_HOOK is set to 1 in FreeRTOSConfig.h.  It is a hook
;;;185    	function that will get called if a call to pvPortMalloc() fails.
;;;186    	pvPortMalloc() is called internally by the kernel whenever a task, queue,
;;;187    	timer or semaphore is created.  It is also called by various parts of the
;;;188    	demo application.  If heap_1.c or heap_2.c are used, then the size of the
;;;189    	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
;;;190    	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
;;;191    	to query the size of free heap space that remains (although it does not
;;;192    	provide information on how the remaining heap might be fragmented). */
;;;193    	taskDISABLE_INTERRUPTS();
;;;194    	for( ;; );
00000e  e7fe              B        |L9.14|
;;;195    }
;;;196    
                          ENDP


                          AREA ||i.vApplicationStackOverflowHook||, CODE, READONLY, ALIGN=1

                  vApplicationStackOverflowHook PROC
;;;196    
;;;197    __weak void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
000000  2050              MOVS     r0,#0x50
000002  f3808811          MSR      BASEPRI,r0
000006  f3bf8f4f          DSB      
00000a  f3bf8f6f          ISB      
                  |L10.14|
;;;198    {
;;;199    	( void ) pcTaskName;
;;;200    	( void ) pxTask;
;;;201    
;;;202    	/* Run time stack overflow checking is performed if
;;;203    	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
;;;204    	function is called if a stack overflow is detected. */
;;;205    	taskDISABLE_INTERRUPTS();
;;;206    	for( ;; );
00000e  e7fe              B        |L10.14|
;;;207    }
;;;208    
                          ENDP


                          AREA ||i.vApplicationTickHook||, CODE, READONLY, ALIGN=1

                  vApplicationTickHook PROC
;;;175    
;;;176    __weak void vApplicationTickHook( void )
000000  4770              BX       lr
;;;177    {
;;;178    
;;;179    }
;;;180    
                          ENDP


                          AREA ||i.vTask_100ms||, CODE, READONLY, ALIGN=2

                  vTask_100ms PROC
;;;126    
;;;127    void vTask_100ms( void *pvParameters )
000000  b508              PUSH     {r3,lr}
;;;128    {	
;;;129    	uint32_t millisec = DELAY_MS_100;
000002  2464              MOVS     r4,#0x64
;;;130    
;;;131    	portTickType xLastWakeTime;
;;;132    	xLastWakeTime = xTaskGetTickCount();
000004  f7fffffe          BL       xTaskGetTickCount
;;;133    
;;;134    	(void) pvParameters;
;;;135    	for( ;; )
;;;136    	{
;;;137            vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
000008  9000              STR      r0,[sp,#0]
00000a  f44f707a          MOV      r0,#0x3e8
00000e  fb14f500          SMULBB   r5,r4,r0
;;;138    		
;;;139    		LED_G ^= 1;
000012  4c06              LDR      r4,|L12.44|
000014  4606              MOV      r6,r0                 ;137
                  |L12.22|
000016  fbb5f1f6          UDIV     r1,r5,r6              ;137
00001a  4668              MOV      r0,sp                 ;137
00001c  f7fffffe          BL       vTaskDelayUntil
000020  6820              LDR      r0,[r4,#0]
000022  f0800001          EOR      r0,r0,#1
000026  6020              STR      r0,[r4,#0]
000028  e7f5              B        |L12.22|
;;;140    	}  
;;;141    }
;;;142    
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      0x400049c8

                          AREA ||i.vTask_10ms||, CODE, READONLY, ALIGN=2

                  vTask_10ms PROC
;;;158    
;;;159    void vTask_10ms( void *pvParameters )
000000  b508              PUSH     {r3,lr}
;;;160    {	
;;;161    	uint32_t millisec = DELAY_MS_10;
000002  240a              MOVS     r4,#0xa
;;;162    
;;;163    	portTickType xLastWakeTime;
;;;164    	xLastWakeTime = xTaskGetTickCount();
000004  f7fffffe          BL       xTaskGetTickCount
;;;165    
;;;166    	(void) pvParameters;
;;;167    	for( ;; )
;;;168    	{
;;;169            vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
000008  9000              STR      r0,[sp,#0]
00000a  f44f707a          MOV      r0,#0x3e8
00000e  fb14f500          SMULBB   r5,r4,r0
;;;170    		
;;;171    		LED_R ^= 1;
000012  4c06              LDR      r4,|L13.44|
000014  4606              MOV      r6,r0                 ;169
                  |L13.22|
000016  fbb5f1f6          UDIV     r1,r5,r6              ;169
00001a  4668              MOV      r0,sp                 ;169
00001c  f7fffffe          BL       vTaskDelayUntil
000020  6820              LDR      r0,[r4,#0]
000022  f0800001          EOR      r0,r0,#1
000026  6020              STR      r0,[r4,#0]
000028  e7f5              B        |L13.22|
;;;172    	}  
;;;173    }
;;;174    
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      0x400049c0

                          AREA ||i.vTask_50ms||, CODE, READONLY, ALIGN=2

                  vTask_50ms PROC
;;;142    
;;;143    void vTask_50ms( void *pvParameters )
000000  b508              PUSH     {r3,lr}
;;;144    {	
;;;145    	uint32_t millisec = DELAY_MS_10*5;
000002  2432              MOVS     r4,#0x32
;;;146    
;;;147    	portTickType xLastWakeTime;
;;;148    	xLastWakeTime = xTaskGetTickCount();
000004  f7fffffe          BL       xTaskGetTickCount
;;;149    
;;;150    	(void) pvParameters;
;;;151    	for( ;; )
;;;152    	{
;;;153            vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
000008  9000              STR      r0,[sp,#0]
00000a  f44f707a          MOV      r0,#0x3e8
00000e  fb14f500          SMULBB   r5,r4,r0
;;;154    		
;;;155    		LED_Y ^= 1;
000012  4c06              LDR      r4,|L14.44|
000014  4606              MOV      r6,r0                 ;153
                  |L14.22|
000016  fbb5f1f6          UDIV     r1,r5,r6              ;153
00001a  4668              MOV      r0,sp                 ;153
00001c  f7fffffe          BL       vTaskDelayUntil
000020  6820              LDR      r0,[r4,#0]
000022  f0800001          EOR      r0,r0,#1
000026  6020              STR      r0,[r4,#0]
000028  e7f5              B        |L14.22|
;;;156    	}  
;;;157    }
;;;158    
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      0x400049c4

                          AREA ||i.vTask_CreateSubTask||, CODE, READONLY, ALIGN=2

                  vTask_CreateSubTask PROC
;;;67     
;;;68     void vTask_CreateSubTask(void * pvParameters)
000000  4c09              LDR      r4,|L15.40|
                  |L15.2|
;;;69     {
;;;70     	(void) pvParameters;
;;;71     	for( ;; )
;;;72     	{
;;;73     		#if defined (DEBUG_CREATE_TASK)
;;;74     		printf(">>>>TaskSub Delete\r\n");
000002  f7fffffe          BL       vTaskSuspendAll
000006  a009              ADR      r0,|L15.44|
000008  f7fffffe          BL       __2printf
00000c  480d              LDR      r0,|L15.68|
00000e  f7fffffe          BL       fflush
000012  f7fffffe          BL       xTaskResumeAll
;;;75     		#endif /*DEBUG_CREATE_TASK*/
;;;76     		
;;;77     		set_flag(flag_RisingFlag,DISABLE);
000016  6860              LDR      r0,[r4,#4]  ; BitFlag
000018  f0200001          BIC      r0,r0,#1
;;;78     
;;;79     		/* Delete the Init Thread */ 
;;;80     		vTaskDelete(xTaskCreateSub);
00001c  6060              STR      r0,[r4,#4]  ; BitFlag
00001e  68a0              LDR      r0,[r4,#8]  ; xTaskCreateSub
000020  f7fffffe          BL       vTaskDelete
000024  e7ed              B        |L15.2|
;;;81     	}	
;;;82     }
;;;83     
                          ENDP

000026  0000              DCW      0x0000
                  |L15.40|
                          DCD      ||.data||
                  |L15.44|
00002c  3e3e3e3e          DCB      ">>>>TaskSub Delete\r\n",0
000030  5461736b
000034  53756220
000038  44656c65
00003c  74650d0a
000040  00      
000041  00                DCB      0
000042  00                DCB      0
000043  00                DCB      0
                  |L15.68|
                          DCD      __stdout

                          AREA ||i.vTask_CreateTask||, CODE, READONLY, ALIGN=2

                  vTask_CreateTask PROC
;;;83     
;;;84     void vTask_CreateTask( void * pvParameters )
000000  b51c              PUSH     {r2-r4,lr}
;;;85     {
;;;86     	(void) pvParameters;	
;;;87     	for( ;; )
;;;88     	{		
;;;89     		if (is_flag_set(flag_RisingFlag))
000002  4e0d              LDR      r6,|L16.56|
;;;90     		{
;;;91     			// Perform action here.			
;;;92     			xTaskCreate(vTask_CreateSubTask, "vTaskSub", configMINIMAL_STACK_SIZE/2, NULL, mainABOVENORMAL_TASK_PRIORITY, &xTaskCreateSub ); 
000004  2501              MOVS     r5,#1
000006  f1060408          ADD      r4,r6,#8
                  |L16.10|
00000a  7930              LDRB     r0,[r6,#4]            ;89  ; BitFlag
00000c  07c0              LSLS     r0,r0,#31             ;89
00000e  d0fc              BEQ      |L16.10|
000010  e9cd5400          STRD     r5,r4,[sp,#0]
000014  2300              MOVS     r3,#0
000016  2240              MOVS     r2,#0x40
000018  a108              ADR      r1,|L16.60|
00001a  480b              LDR      r0,|L16.72|
00001c  f7fffffe          BL       xTaskCreate
;;;93     			
;;;94     			#if defined (DEBUG_CREATE_TASK)
;;;95     			printf(">>>>TaskSub Create\r\n");		
000020  f7fffffe          BL       vTaskSuspendAll
000024  a009              ADR      r0,|L16.76|
000026  f7fffffe          BL       __2printf
00002a  480e              LDR      r0,|L16.100|
00002c  f7fffffe          BL       fflush
000030  f7fffffe          BL       xTaskResumeAll
000034  e7e9              B        |L16.10|
;;;96     			#endif /*DEBUG_CREATE_TASK*/
;;;97     		}
;;;98     	}  
;;;99     }
;;;100    
                          ENDP

000036  0000              DCW      0x0000
                  |L16.56|
                          DCD      ||.data||
                  |L16.60|
00003c  76546173          DCB      "vTaskSub",0
000040  6b537562
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
                  |L16.72|
                          DCD      vTask_CreateSubTask
                  |L16.76|
00004c  3e3e3e3e          DCB      ">>>>TaskSub Create\r\n",0
000050  5461736b
000054  53756220
000058  43726561
00005c  74650d0a
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L16.100|
                          DCD      __stdout

                          AREA ||i.vTask_RisingFlag||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  vTask_RisingFlag PROC
;;;100    
;;;101    void vTask_RisingFlag( void * pvParameters )
000000  b51c              PUSH     {r2-r4,lr}
;;;102    {
;;;103    	uint32_t millisec = DELAY_MS_100*5;
000002  f44f77fa          MOV      r7,#0x1f4
;;;104    	static uint16_t cnt = 0;
;;;105    	
;;;106    	portTickType xLastWakeTime;
;;;107    //	Initialise the xLastWakeTime variable with the current time.
;;;108    	xLastWakeTime = xTaskGetTickCount();
000006  f7fffffe          BL       xTaskGetTickCount
;;;109    
;;;110    	(void) pvParameters;
;;;111    	for( ;; )
;;;112    	{
;;;113    		// Wait for the next cycle.
;;;114    		vTaskDelayUntil( &xLastWakeTime, ( millisec *configTICK_RATE_HZ / ( ( TickType_t ) 1000 ) ));
00000a  9001              STR      r0,[sp,#4]
00000c  0078              LSLS     r0,r7,#1
00000e  fb17f500          SMULBB   r5,r7,r0
;;;115    
;;;116    		// Perform action here.	
;;;117    		set_flag(flag_RisingFlag,ENABLE);
000012  4c11              LDR      r4,|L17.88|
000014  4680              MOV      r8,r0                 ;114
                  |L17.22|
000016  fbb5f1f8          UDIV     r1,r5,r8              ;114
00001a  a801              ADD      r0,sp,#4              ;114
00001c  f7fffffe          BL       vTaskDelayUntil
000020  6860              LDR      r0,[r4,#4]  ; BitFlag
000022  f0400001          ORR      r0,r0,#1
;;;118    
;;;119    		#if defined (DEBUG_RISING_FLAG)
;;;120    		printf("RisingFlag(%4dms) :%4d (heap : %3d bytes , CPU : %3d )\r\n" ,millisec, ++cnt,xPortGetFreeHeapSize(),osGetCPUUsage());
000026  6060              STR      r0,[r4,#4]  ; BitFlag
000028  f7fffffe          BL       vTaskSuspendAll
00002c  f7fffffe          BL       osGetCPUUsage
000030  4606              MOV      r6,r0
000032  f7fffffe          BL       xPortGetFreeHeapSize
000036  4603              MOV      r3,r0
000038  9600              STR      r6,[sp,#0]
00003a  8820              LDRH     r0,[r4,#0]  ; cnt
00003c  4639              MOV      r1,r7
00003e  1c40              ADDS     r0,r0,#1
000040  b282              UXTH     r2,r0
000042  8022              STRH     r2,[r4,#0]
000044  a005              ADR      r0,|L17.92|
000046  f7fffffe          BL       __2printf
00004a  4813              LDR      r0,|L17.152|
00004c  f7fffffe          BL       fflush
000050  f7fffffe          BL       xTaskResumeAll
000054  e7df              B        |L17.22|
;;;121    		#else
;;;122    		( void ) cnt;		//Remove compiler warning about cnt being set but never used.
;;;123    		#endif	/*DEBUG_RISING_FLAG*/		
;;;124    	}  
;;;125    }
;;;126    
                          ENDP

000056  0000              DCW      0x0000
                  |L17.88|
                          DCD      ||.data||
                  |L17.92|
00005c  52697369          DCB      "RisingFlag(%4dms) :%4d (heap : %3d bytes , CPU : %3d )\r"
000060  6e67466c
000064  61672825
000068  34646d73
00006c  29203a25
000070  34642028
000074  68656170
000078  203a2025
00007c  33642062
000080  79746573
000084  202c2043
000088  5055203a
00008c  20253364
000090  20290d  
000093  0a00              DCB      "\n",0
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L17.152|
                          DCD      __stdout

                          AREA ||.data||, DATA, ALIGN=2

                  ||cnt||
000000  0000              DCW      0x0000
                  ||CNT||
000002  0000              DCW      0x0000
                  BitFlag
                          DCD      0x00000000
                  xTaskCreateSub
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
