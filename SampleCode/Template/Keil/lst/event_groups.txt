; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\event_groups.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\event_groups.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -I..\CPU -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\event_groups.crf ..\..\..\ThirdParty\FreeRTOS\Source\event_groups.c]
                          THUMB

                          AREA ||i.prvTestWaitCondition||, CODE, READONLY, ALIGN=1

                  prvTestWaitCondition PROC
;;;670    
;;;671    static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
000000  4603              MOV      r3,r0
;;;672    {
;;;673    BaseType_t xWaitConditionMet = pdFALSE;
000002  2000              MOVS     r0,#0
000004  b112              CBZ      r2,|L1.12|
;;;674    
;;;675    	if( xWaitForAllBits == pdFALSE )
;;;676    	{
;;;677    		/* Task only has to wait for one bit within uxBitsToWaitFor to be
;;;678    		set.  Is one already set? */
;;;679    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
;;;680    		{
;;;681    			xWaitConditionMet = pdTRUE;
;;;682    		}
;;;683    		else
;;;684    		{
;;;685    			mtCOVERAGE_TEST_MARKER();
;;;686    		}
;;;687    	}
;;;688    	else
;;;689    	{
;;;690    		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
;;;691    		Are they set already? */
;;;692    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
000006  4399              BICS     r1,r1,r3
000008  d002              BEQ      |L1.16|
                  |L1.10|
;;;693    		{
;;;694    			xWaitConditionMet = pdTRUE;
;;;695    		}
;;;696    		else
;;;697    		{
;;;698    			mtCOVERAGE_TEST_MARKER();
;;;699    		}
;;;700    	}
;;;701    
;;;702    	return xWaitConditionMet;
;;;703    }
00000a  4770              BX       lr
                  |L1.12|
00000c  420b              TST      r3,r1                 ;679
00000e  d0fc              BEQ      |L1.10|
                  |L1.16|
000010  2001              MOVS     r0,#1                 ;681
000012  4770              BX       lr
;;;704    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxEventGroupGetNumber||, CODE, READONLY, ALIGN=1

                  uxEventGroupGetNumber PROC
;;;722    
;;;723    	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
000000  2800              CMP      r0,#0
;;;724    	{
000002  d000              BEQ      |L2.6|
;;;725    	UBaseType_t xReturn;
;;;726    	EventGroup_t const *pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
;;;727    
;;;728    		if( xEventGroup == NULL )
;;;729    		{
;;;730    			xReturn = 0;
;;;731    		}
;;;732    		else
;;;733    		{
;;;734    			xReturn = pxEventBits->uxEventGroupNumber;
000004  6980              LDR      r0,[r0,#0x18]
                  |L2.6|
;;;735    		}
;;;736    
;;;737    		return xReturn;
;;;738    	}
000006  4770              BX       lr
;;;739    
                          ENDP


                          AREA ||i.vEventGroupClearBitsCallback||, CODE, READONLY, ALIGN=1

                  vEventGroupClearBitsCallback PROC
;;;664    an interrupt. */
;;;665    void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
000000  f7ffbffe          B.W      xEventGroupClearBits
;;;666    {
;;;667    	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
;;;668    }
;;;669    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupDelete||, CODE, READONLY, ALIGN=1

                  vEventGroupDelete PROC
;;;612    
;;;613    void vEventGroupDelete( EventGroupHandle_t xEventGroup )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;614    {
000004  4606              MOV      r6,r0
;;;615    EventGroup_t *pxEventBits = xEventGroup;
;;;616    const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
000006  1d04              ADDS     r4,r0,#4
;;;617    
;;;618    	vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;619    	{
;;;620    		traceEVENT_GROUP_DELETE( xEventGroup );
;;;621    
;;;622    		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
;;;623    		{
;;;624    			/* Unblock the task, returning 0 as the event list is being deleted
;;;625    			and cannot therefore have any bits set. */
;;;626    			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
00000c  f1040508          ADD      r5,r4,#8
;;;627    			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
000010  f04f7700          MOV      r7,#0x2000000
000014  e00d              B        |L4.50|
                  |L4.22|
000016  68e0              LDR      r0,[r4,#0xc]          ;626
000018  42a8              CMP      r0,r5                 ;626
00001a  d107              BNE      |L4.44|
00001c  2050              MOVS     r0,#0x50              ;626
00001e  f3808811          MSR      BASEPRI,r0            ;626
000022  f3bf8f4f          DSB                            ;626
000026  f3bf8f6f          ISB                            ;626
                  |L4.42|
00002a  e7fe              B        |L4.42|
                  |L4.44|
00002c  4639              MOV      r1,r7
00002e  f7fffffe          BL       vTaskRemoveFromUnorderedEventList
                  |L4.50|
000032  6820              LDR      r0,[r4,#0]            ;622
000034  2800              CMP      r0,#0                 ;622
000036  d1ee              BNE      |L4.22|
;;;628    		}
;;;629    
;;;630    		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;631    		{
;;;632    			/* The event group can only have been allocated dynamically - free
;;;633    			it again. */
;;;634    			vPortFree( pxEventBits );
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       vPortFree
;;;635    		}
;;;636    		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;637    		{
;;;638    			/* The event group could have been allocated statically or
;;;639    			dynamically, so check before attempting to free the memory. */
;;;640    			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;641    			{
;;;642    				vPortFree( pxEventBits );
;;;643    			}
;;;644    			else
;;;645    			{
;;;646    				mtCOVERAGE_TEST_MARKER();
;;;647    			}
;;;648    		}
;;;649    		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;650    	}
;;;651    	( void ) xTaskResumeAll();
00003e  e8bd41f0          POP      {r4-r8,lr}
000042  f7ffbffe          B.W      xTaskResumeAll
;;;652    }
;;;653    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupSetBitsCallback||, CODE, READONLY, ALIGN=1

                  vEventGroupSetBitsCallback PROC
;;;656    an interrupt. */
;;;657    void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
000000  f7ffbffe          B.W      xEventGroupSetBits
;;;658    {
;;;659    	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
;;;660    }
;;;661    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupSetNumber||, CODE, READONLY, ALIGN=1

                  vEventGroupSetNumber PROC
;;;744    
;;;745    	void vEventGroupSetNumber( void * xEventGroup, UBaseType_t uxEventGroupNumber )
000000  6181              STR      r1,[r0,#0x18]
;;;746    	{
;;;747    		( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
;;;748    	}
000002  4770              BX       lr
;;;749    
                          ENDP


                          AREA ||i.xEventGroupClearBits||, CODE, READONLY, ALIGN=1

                  xEventGroupClearBits PROC
;;;460    
;;;461    EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
000000  b570              PUSH     {r4-r6,lr}
;;;462    {
000002  460e              MOV      r6,r1
;;;463    EventGroup_t *pxEventBits = xEventGroup;
000004  0004              MOVS     r4,r0
000006  d009              BEQ      |L7.28|
;;;464    EventBits_t uxReturn;
;;;465    
;;;466    	/* Check the user is not attempting to clear the bits used by the kernel
;;;467    	itself. */
;;;468    	configASSERT( xEventGroup );
;;;469    	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000008  0e30              LSRS     r0,r6,#24
00000a  d00f              BEQ      |L7.44|
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
                  |L7.26|
00001a  e7fe              B        |L7.26|
                  |L7.28|
00001c  2050              MOVS     r0,#0x50
00001e  f3808811          MSR      BASEPRI,r0
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
                  |L7.42|
00002a  e7fe              B        |L7.42|
                  |L7.44|
;;;470    
;;;471    	taskENTER_CRITICAL();
00002c  f7fffffe          BL       vPortEnterCritical
;;;472    	{
;;;473    		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
;;;474    
;;;475    		/* The value returned is the event group value prior to the bits being
;;;476    		cleared. */
;;;477    		uxReturn = pxEventBits->uxEventBits;
;;;478    
;;;479    		/* Clear the bits. */
;;;480    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000030  6825              LDR      r5,[r4,#0]
000032  ea250006          BIC      r0,r5,r6
;;;481    	}
;;;482    	taskEXIT_CRITICAL();
000036  6020              STR      r0,[r4,#0]
000038  f7fffffe          BL       vPortExitCritical
;;;483    
;;;484    	return uxReturn;
00003c  4628              MOV      r0,r5
;;;485    }
00003e  bd70              POP      {r4-r6,pc}
;;;486    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupCreate||, CODE, READONLY, ALIGN=1

                  xEventGroupCreate PROC
;;;144    
;;;145    	EventGroupHandle_t xEventGroupCreate( void )
000000  b510              PUSH     {r4,lr}
;;;146    	{
;;;147    	EventGroup_t *pxEventBits;
;;;148    
;;;149    		/* Allocate the event group.  Justification for MISRA deviation as
;;;150    		follows:  pvPortMalloc() always ensures returned memory blocks are
;;;151    		aligned per the requirements of the MCU stack.  In this case
;;;152    		pvPortMalloc() must return a pointer that is guaranteed to meet the
;;;153    		alignment requirements of the EventGroup_t structure - which (if you
;;;154    		follow it through) is the alignment requirements of the TickType_t type
;;;155    		(EventBits_t being of TickType_t itself).  Therefore, whenever the
;;;156    		stack alignment requirements are greater than or equal to the
;;;157    		TickType_t alignment requirements the cast is safe.  In other cases,
;;;158    		where the natural word size of the architecture is less than
;;;159    		sizeof( TickType_t ), the TickType_t variables will be accessed in two
;;;160    		or more reads operations, and the alignment requirements is only that
;;;161    		of each individual read. */
;;;162    		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
000002  201c              MOVS     r0,#0x1c
000004  f7fffffe          BL       pvPortMalloc
000008  0004              MOVS     r4,r0
;;;163    
;;;164    		if( pxEventBits != NULL )
00000a  d004              BEQ      |L8.22|
;;;165    		{
;;;166    			pxEventBits->uxEventBits = 0;
00000c  2000              MOVS     r0,#0
;;;167    			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
00000e  6020              STR      r0,[r4,#0]
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       vListInitialise
                  |L8.22|
;;;168    
;;;169    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;170    			{
;;;171    				/* Both static and dynamic allocation can be used, so note this
;;;172    				event group was allocated statically in case the event group is
;;;173    				later deleted. */
;;;174    				pxEventBits->ucStaticallyAllocated = pdFALSE;
;;;175    			}
;;;176    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;177    
;;;178    			traceEVENT_GROUP_CREATE( pxEventBits );
;;;179    		}
;;;180    		else
;;;181    		{
;;;182    			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
;;;183    		}
;;;184    
;;;185    		return pxEventBits;
000016  4620              MOV      r0,r4
;;;186    	}
000018  bd10              POP      {r4,pc}
;;;187    
                          ENDP


                          AREA ||i.xEventGroupGetBitsFromISR||, CODE, READONLY, ALIGN=1

                  xEventGroupGetBitsFromISR PROC
;;;502    
;;;503    EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
000000  2250              MOVS     r2,#0x50
000002  f3ef8111          MRS      r1,BASEPRI
000006  f3828811          MSR      BASEPRI,r2
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
;;;504    {
;;;505    UBaseType_t uxSavedInterruptStatus;
;;;506    EventGroup_t const * const pxEventBits = xEventGroup;
;;;507    EventBits_t uxReturn;
;;;508    
;;;509    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;510    	{
;;;511    		uxReturn = pxEventBits->uxEventBits;
000012  6800              LDR      r0,[r0,#0]
000014  f3818811          MSR      BASEPRI,r1
;;;512    	}
;;;513    	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;514    
;;;515    	return uxReturn;
;;;516    } /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
000018  4770              BX       lr
;;;517    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSetBits||, CODE, READONLY, ALIGN=1

                  xEventGroupSetBits PROC
;;;518    
;;;519    EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;520    {
;;;521    ListItem_t *pxListItem, *pxNext;
;;;522    ListItem_t const *pxListEnd;
;;;523    List_t const * pxList;
;;;524    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
000004  2500              MOVS     r5,#0
000006  4688              MOV      r8,r1                 ;520
;;;525    EventGroup_t *pxEventBits = xEventGroup;
000008  0004              MOVS     r4,r0
00000a  d00a              BEQ      |L10.34|
;;;526    BaseType_t xMatchFound = pdFALSE;
;;;527    
;;;528    	/* Check the user is not attempting to set the bits used by the kernel
;;;529    	itself. */
;;;530    	configASSERT( xEventGroup );
;;;531    	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
00000c  ea5f6018          LSRS     r0,r8,#24
000010  d00f              BEQ      |L10.50|
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L10.32|
000020  e7fe              B        |L10.32|
                  |L10.34|
000022  2050              MOVS     r0,#0x50
000024  f3808811          MSR      BASEPRI,r0
000028  f3bf8f4f          DSB      
00002c  f3bf8f6f          ISB      
                  |L10.48|
000030  e7fe              B        |L10.48|
                  |L10.50|
;;;532    
;;;533    	pxList = &( pxEventBits->xTasksWaitingForBits );
000032  1d26              ADDS     r6,r4,#4
;;;534    	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000034  f104070c          ADD      r7,r4,#0xc
;;;535    	vTaskSuspendAll();
000038  f7fffffe          BL       vTaskSuspendAll
;;;536    	{
;;;537    		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
;;;538    
;;;539    		pxListItem = listGET_HEAD_ENTRY( pxList );
;;;540    
;;;541    		/* Set the bits. */
;;;542    		pxEventBits->uxEventBits |= uxBitsToSet;
00003c  6821              LDR      r1,[r4,#0]
00003e  68f0              LDR      r0,[r6,#0xc]
000040  ea410108          ORR      r1,r1,r8
;;;543    
;;;544    		/* See if the new bit value should unblock any tasks. */
;;;545    		while( pxListItem != pxListEnd )
000044  6021              STR      r1,[r4,#0]
000046  e017              B        |L10.120|
                  |L10.72|
000048  e9d01600          LDRD     r1,r6,[r0,#0]
;;;546    		{
;;;547    			pxNext = listGET_NEXT( pxListItem );
;;;548    			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
;;;549    			xMatchFound = pdFALSE;
;;;550    
;;;551    			/* Split the bits waited for from the control bits. */
;;;552    			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
00004c  f001427f          AND      r2,r1,#0xff000000
;;;553    			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
;;;554    
;;;555    			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
000050  0153              LSLS     r3,r2,#5
000052  6823              LDR      r3,[r4,#0]
000054  f021417f          BIC      r1,r1,#0xff000000     ;553
000058  d402              BMI      |L10.96|
;;;556    			{
;;;557    				/* Just looking for single bit being set. */
;;;558    				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
00005a  420b              TST      r3,r1
00005c  d103              BNE      |L10.102|
00005e  e00a              B        |L10.118|
                  |L10.96|
;;;559    				{
;;;560    					xMatchFound = pdTRUE;
;;;561    				}
;;;562    				else
;;;563    				{
;;;564    					mtCOVERAGE_TEST_MARKER();
;;;565    				}
;;;566    			}
;;;567    			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
000060  ea310303          BICS     r3,r1,r3
000064  d107              BNE      |L10.118|
                  |L10.102|
;;;568    			{
;;;569    				/* All bits are set. */
;;;570    				xMatchFound = pdTRUE;
;;;571    			}
;;;572    			else
;;;573    			{
;;;574    				/* Need all bits to be set, but not all the bits were set. */
;;;575    			}
;;;576    
;;;577    			if( xMatchFound != pdFALSE )
;;;578    			{
;;;579    				/* The bits match.  Should the bits be cleared on exit? */
;;;580    				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
000066  01d2              LSLS     r2,r2,#7
000068  d500              BPL      |L10.108|
;;;581    				{
;;;582    					uxBitsToClear |= uxBitsWaitedFor;
00006a  430d              ORRS     r5,r5,r1
                  |L10.108|
;;;583    				}
;;;584    				else
;;;585    				{
;;;586    					mtCOVERAGE_TEST_MARKER();
;;;587    				}
;;;588    
;;;589    				/* Store the actual event flag value in the task's event list
;;;590    				item before removing the task from the event list.  The
;;;591    				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
;;;592    				that is was unblocked due to its required bits matching, rather
;;;593    				than because it timed out. */
;;;594    				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
00006c  6821              LDR      r1,[r4,#0]
00006e  f0417100          ORR      r1,r1,#0x2000000
000072  f7fffffe          BL       vTaskRemoveFromUnorderedEventList
                  |L10.118|
;;;595    			}
;;;596    
;;;597    			/* Move onto the next list item.  Note pxListItem->pxNext is not
;;;598    			used here as the list item may have been removed from the event list
;;;599    			and inserted into the ready/pending reading list. */
;;;600    			pxListItem = pxNext;
000076  4630              MOV      r0,r6
                  |L10.120|
000078  42b8              CMP      r0,r7                 ;545
00007a  d1e5              BNE      |L10.72|
;;;601    		}
;;;602    
;;;603    		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
;;;604    		bit was set in the control word. */
;;;605    		pxEventBits->uxEventBits &= ~uxBitsToClear;
00007c  6820              LDR      r0,[r4,#0]
00007e  43a8              BICS     r0,r0,r5
;;;606    	}
;;;607    	( void ) xTaskResumeAll();
000080  6020              STR      r0,[r4,#0]
000082  f7fffffe          BL       xTaskResumeAll
;;;608    
;;;609    	return pxEventBits->uxEventBits;
000086  6820              LDR      r0,[r4,#0]
;;;610    }
000088  e8bd81f0          POP      {r4-r8,pc}
;;;611    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSync||, CODE, READONLY, ALIGN=2

                  xEventGroupSync PROC
;;;190    
;;;191    EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;192    {
000004  4604              MOV      r4,r0
000006  461f              MOV      r7,r3
000008  4615              MOV      r5,r2
00000a  4688              MOV      r8,r1
;;;193    EventBits_t uxOriginalBitValue, uxReturn;
;;;194    EventGroup_t *pxEventBits = xEventGroup;
;;;195    BaseType_t xAlreadyYielded;
;;;196    BaseType_t xTimeoutOccurred = pdFALSE;
;;;197    
;;;198    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
00000c  0e10              LSRS     r0,r2,#24
00000e  d007              BEQ      |L11.32|
000010  2050              MOVS     r0,#0x50              ;192
000012  f3808811          MSR      BASEPRI,r0            ;192
000016  f3bf8f4f          DSB                            ;192
00001a  f3bf8f6f          ISB                            ;192
                  |L11.30|
00001e  e7fe              B        |L11.30|
                  |L11.32|
;;;199    	configASSERT( uxBitsToWaitFor != 0 );
000020  b11d              CBZ      r5,|L11.42|
;;;200    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;201    	{
;;;202    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
000022  f7fffffe          BL       xTaskGetSchedulerState
000026  b140              CBZ      r0,|L11.58|
000028  e010              B        |L11.76|
                  |L11.42|
00002a  2050              MOVS     r0,#0x50
00002c  f3808811          MSR      BASEPRI,r0
000030  f3bf8f4f          DSB      
000034  f3bf8f6f          ISB      
                  |L11.56|
000038  e7fe              B        |L11.56|
                  |L11.58|
00003a  b13f              CBZ      r7,|L11.76|
00003c  2050              MOVS     r0,#0x50
00003e  f3808811          MSR      BASEPRI,r0
000042  f3bf8f4f          DSB      
000046  f3bf8f6f          ISB      
                  |L11.74|
00004a  e7fe              B        |L11.74|
                  |L11.76|
;;;203    	}
;;;204    	#endif
;;;205    
;;;206    	vTaskSuspendAll();
00004c  f7fffffe          BL       vTaskSuspendAll
;;;207    	{
;;;208    		uxOriginalBitValue = pxEventBits->uxEventBits;
000050  4620              MOV      r0,r4
;;;209    
;;;210    		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
000052  4641              MOV      r1,r8
000054  6826              LDR      r6,[r4,#0]
000056  f7fffffe          BL       xEventGroupSetBits
;;;211    
;;;212    		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
00005a  ea460608          ORR      r6,r6,r8
00005e  ea350006          BICS     r0,r5,r6
000062  d008              BEQ      |L11.118|
;;;213    		{
;;;214    			/* All the rendezvous bits are now set - no need to block. */
;;;215    			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
;;;216    
;;;217    			/* Rendezvous always clear the bits.  They will have been cleared
;;;218    			already unless this is the only task in the rendezvous. */
;;;219    			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
;;;220    
;;;221    			xTicksToWait = 0;
;;;222    		}
;;;223    		else
;;;224    		{
;;;225    			if( xTicksToWait != ( TickType_t ) 0 )
000064  b167              CBZ      r7,|L11.128|
;;;226    			{
;;;227    				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
;;;228    
;;;229    				/* Store the bits that the calling task is waiting for in the
;;;230    				task's event list item so the kernel knows when a match is
;;;231    				found.  Then enter the blocked state. */
;;;232    				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
000066  f04561a0          ORR      r1,r5,#0x5000000
00006a  463a              MOV      r2,r7
00006c  1d20              ADDS     r0,r4,#4
00006e  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;233    
;;;234    				/* This assignment is obsolete as uxReturn will get set after
;;;235    				the task unblocks, but some compilers mistakenly generate a
;;;236    				warning about uxReturn being returned without being set if the
;;;237    				assignment is omitted. */
;;;238    				uxReturn = 0;
000072  2600              MOVS     r6,#0
000074  e005              B        |L11.130|
                  |L11.118|
000076  6820              LDR      r0,[r4,#0]            ;219
000078  43a8              BICS     r0,r0,r5              ;219
00007a  2700              MOVS     r7,#0                 ;221
00007c  6020              STR      r0,[r4,#0]            ;221
00007e  e000              B        |L11.130|
                  |L11.128|
;;;239    			}
;;;240    			else
;;;241    			{
;;;242    				/* The rendezvous bits were not set, but no block time was
;;;243    				specified - just return the current event bit value. */
;;;244    				uxReturn = pxEventBits->uxEventBits;
000080  6826              LDR      r6,[r4,#0]
                  |L11.130|
;;;245    				xTimeoutOccurred = pdTRUE;
;;;246    			}
;;;247    		}
;;;248    	}
;;;249    	xAlreadyYielded = xTaskResumeAll();
000082  f7fffffe          BL       xTaskResumeAll
;;;250    
;;;251    	if( xTicksToWait != ( TickType_t ) 0 )
000086  b1d7              CBZ      r7,|L11.190|
;;;252    	{
;;;253    		if( xAlreadyYielded == pdFALSE )
000088  b938              CBNZ     r0,|L11.154|
;;;254    		{
;;;255    			portYIELD_WITHIN_API();
00008a  490e              LDR      r1,|L11.196|
00008c  f04f5080          MOV      r0,#0x10000000
000090  6008              STR      r0,[r1,#0]
000092  f3bf8f4f          DSB      
000096  f3bf8f6f          ISB      
                  |L11.154|
;;;256    		}
;;;257    		else
;;;258    		{
;;;259    			mtCOVERAGE_TEST_MARKER();
;;;260    		}
;;;261    
;;;262    		/* The task blocked to wait for its required bits to be set - at this
;;;263    		point either the required bits were set or the block time expired.  If
;;;264    		the required bits were set they will have been stored in the task's
;;;265    		event list item, and they should now be retrieved then cleared. */
;;;266    		uxReturn = uxTaskResetEventItemValue();
00009a  f7fffffe          BL       uxTaskResetEventItemValue
00009e  4606              MOV      r6,r0
;;;267    
;;;268    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0000a0  0180              LSLS     r0,r0,#6
0000a2  d40a              BMI      |L11.186|
;;;269    		{
;;;270    			/* The task timed out, just return the current event bit value. */
;;;271    			taskENTER_CRITICAL();
0000a4  f7fffffe          BL       vPortEnterCritical
;;;272    			{
;;;273    				uxReturn = pxEventBits->uxEventBits;
;;;274    
;;;275    				/* Although the task got here because it timed out before the
;;;276    				bits it was waiting for were set, it is possible that since it
;;;277    				unblocked another task has set the bits.  If this is the case
;;;278    				then it needs to clear the bits before exiting. */
;;;279    				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
0000a8  6826              LDR      r6,[r4,#0]
0000aa  ea350006          BICS     r0,r5,r6
0000ae  d102              BNE      |L11.182|
;;;280    				{
;;;281    					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0000b0  ea260005          BIC      r0,r6,r5
0000b4  6020              STR      r0,[r4,#0]
                  |L11.182|
;;;282    				}
;;;283    				else
;;;284    				{
;;;285    					mtCOVERAGE_TEST_MARKER();
;;;286    				}
;;;287    			}
;;;288    			taskEXIT_CRITICAL();
0000b6  f7fffffe          BL       vPortExitCritical
                  |L11.186|
;;;289    
;;;290    			xTimeoutOccurred = pdTRUE;
;;;291    		}
;;;292    		else
;;;293    		{
;;;294    			/* The task unblocked because the bits were set. */
;;;295    		}
;;;296    
;;;297    		/* Control bits might be set as the task had blocked should not be
;;;298    		returned. */
;;;299    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0000ba  f026467f          BIC      r6,r6,#0xff000000
                  |L11.190|
;;;300    	}
;;;301    
;;;302    	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
;;;303    
;;;304    	/* Prevent compiler warnings when trace macros are not used. */
;;;305    	( void ) xTimeoutOccurred;
;;;306    
;;;307    	return uxReturn;
0000be  4630              MOV      r0,r6
;;;308    }
0000c0  e8bd81f0          POP      {r4-r8,pc}
;;;309    /*-----------------------------------------------------------*/
                          ENDP

                  |L11.196|
                          DCD      0xe000ed04

                          AREA ||i.xEventGroupWaitBits||, CODE, READONLY, ALIGN=2

                  xEventGroupWaitBits PROC
;;;310    
;;;311    EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;312    {
000004  469a              MOV      r10,r3
;;;313    EventGroup_t *pxEventBits = xEventGroup;
000006  9f08              LDR      r7,[sp,#0x20]
000008  4691              MOV      r9,r2                 ;312
00000a  460d              MOV      r5,r1                 ;312
00000c  0004              MOVS     r4,r0
;;;314    EventBits_t uxReturn, uxControlBits = 0;
00000e  f04f0600          MOV      r6,#0
000012  d009              BEQ      |L12.40|
;;;315    BaseType_t xWaitConditionMet, xAlreadyYielded;
;;;316    BaseType_t xTimeoutOccurred = pdFALSE;
;;;317    
;;;318    	/* Check the user is not attempting to wait on the bits used by the kernel
;;;319    	itself, and that at least one bit is being requested. */
;;;320    	configASSERT( xEventGroup );
;;;321    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000014  0e28              LSRS     r0,r5,#24
000016  d00f              BEQ      |L12.56|
000018  2050              MOVS     r0,#0x50
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
                  |L12.38|
000026  e7fe              B        |L12.38|
                  |L12.40|
000028  2050              MOVS     r0,#0x50
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L12.54|
000036  e7fe              B        |L12.54|
                  |L12.56|
;;;322    	configASSERT( uxBitsToWaitFor != 0 );
000038  b11d              CBZ      r5,|L12.66|
;;;323    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;324    	{
;;;325    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00003a  f7fffffe          BL       xTaskGetSchedulerState
00003e  b140              CBZ      r0,|L12.82|
000040  e010              B        |L12.100|
                  |L12.66|
000042  2050              MOVS     r0,#0x50
000044  f3808811          MSR      BASEPRI,r0
000048  f3bf8f4f          DSB      
00004c  f3bf8f6f          ISB      
                  |L12.80|
000050  e7fe              B        |L12.80|
                  |L12.82|
000052  b13f              CBZ      r7,|L12.100|
000054  2050              MOVS     r0,#0x50
000056  f3808811          MSR      BASEPRI,r0
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
                  |L12.98|
000062  e7fe              B        |L12.98|
                  |L12.100|
;;;326    	}
;;;327    	#endif
;;;328    
;;;329    	vTaskSuspendAll();
000064  f7fffffe          BL       vTaskSuspendAll
;;;330    	{
;;;331    		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
;;;332    
;;;333    		/* Check to see if the wait condition is already met or not. */
;;;334    		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
000068  f8d48000          LDR      r8,[r4,#0]
00006c  4652              MOV      r2,r10
00006e  4629              MOV      r1,r5
000070  4640              MOV      r0,r8
000072  f7fffffe          BL       prvTestWaitCondition
;;;335    
;;;336    		if( xWaitConditionMet != pdFALSE )
000076  b140              CBZ      r0,|L12.138|
;;;337    		{
;;;338    			/* The wait condition has already been met so there is no need to
;;;339    			block. */
;;;340    			uxReturn = uxCurrentEventBits;
;;;341    			xTicksToWait = ( TickType_t ) 0;
000078  2700              MOVS     r7,#0
00007a  4646              MOV      r6,r8                 ;340
;;;342    
;;;343    			/* Clear the wait bits if requested to do so. */
;;;344    			if( xClearOnExit != pdFALSE )
00007c  f1b90f00          CMP      r9,#0
000080  d015              BEQ      |L12.174|
;;;345    			{
;;;346    				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
000082  6820              LDR      r0,[r4,#0]
000084  43a8              BICS     r0,r0,r5
000086  6020              STR      r0,[r4,#0]
000088  e011              B        |L12.174|
                  |L12.138|
;;;347    			}
;;;348    			else
;;;349    			{
;;;350    				mtCOVERAGE_TEST_MARKER();
;;;351    			}
;;;352    		}
;;;353    		else if( xTicksToWait == ( TickType_t ) 0 )
00008a  b1af              CBZ      r7,|L12.184|
;;;354    		{
;;;355    			/* The wait condition has not been met, but no block time was
;;;356    			specified, so just return the current value. */
;;;357    			uxReturn = uxCurrentEventBits;
;;;358    			xTimeoutOccurred = pdTRUE;
;;;359    		}
;;;360    		else
;;;361    		{
;;;362    			/* The task is going to block to wait for its required bits to be
;;;363    			set.  uxControlBits are used to remember the specified behaviour of
;;;364    			this call to xEventGroupWaitBits() - for use when the event bits
;;;365    			unblock the task. */
;;;366    			if( xClearOnExit != pdFALSE )
00008c  f1b90f00          CMP      r9,#0
000090  d001              BEQ      |L12.150|
;;;367    			{
;;;368    				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
000092  f04f7680          MOV      r6,#0x1000000
                  |L12.150|
;;;369    			}
;;;370    			else
;;;371    			{
;;;372    				mtCOVERAGE_TEST_MARKER();
;;;373    			}
;;;374    
;;;375    			if( xWaitForAllBits != pdFALSE )
000096  f1ba0f00          CMP      r10,#0
00009a  d001              BEQ      |L12.160|
;;;376    			{
;;;377    				uxControlBits |= eventWAIT_FOR_ALL_BITS;
00009c  f0466680          ORR      r6,r6,#0x4000000
                  |L12.160|
;;;378    			}
;;;379    			else
;;;380    			{
;;;381    				mtCOVERAGE_TEST_MARKER();
;;;382    			}
;;;383    
;;;384    			/* Store the bits that the calling task is waiting for in the
;;;385    			task's event list item so the kernel knows when a match is
;;;386    			found.  Then enter the blocked state. */
;;;387    			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
0000a0  ea450106          ORR      r1,r5,r6
0000a4  463a              MOV      r2,r7
0000a6  1d20              ADDS     r0,r4,#4
0000a8  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;388    
;;;389    			/* This is obsolete as it will get set after the task unblocks, but
;;;390    			some compilers mistakenly generate a warning about the variable
;;;391    			being returned without being set if it is not done. */
;;;392    			uxReturn = 0;
0000ac  2600              MOVS     r6,#0
                  |L12.174|
;;;393    
;;;394    			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
;;;395    		}
;;;396    	}
;;;397    	xAlreadyYielded = xTaskResumeAll();
0000ae  f7fffffe          BL       xTaskResumeAll
;;;398    
;;;399    	if( xTicksToWait != ( TickType_t ) 0 )
0000b2  b31f              CBZ      r7,|L12.252|
;;;400    	{
;;;401    		if( xAlreadyYielded == pdFALSE )
0000b4  b110              CBZ      r0,|L12.188|
0000b6  e009              B        |L12.204|
                  |L12.184|
0000b8  4646              MOV      r6,r8                 ;357
0000ba  e7f8              B        |L12.174|
                  |L12.188|
;;;402    		{
;;;403    			portYIELD_WITHIN_API();
0000bc  4911              LDR      r1,|L12.260|
0000be  f04f5080          MOV      r0,#0x10000000
0000c2  6008              STR      r0,[r1,#0]
0000c4  f3bf8f4f          DSB      
0000c8  f3bf8f6f          ISB      
                  |L12.204|
;;;404    		}
;;;405    		else
;;;406    		{
;;;407    			mtCOVERAGE_TEST_MARKER();
;;;408    		}
;;;409    
;;;410    		/* The task blocked to wait for its required bits to be set - at this
;;;411    		point either the required bits were set or the block time expired.  If
;;;412    		the required bits were set they will have been stored in the task's
;;;413    		event list item, and they should now be retrieved then cleared. */
;;;414    		uxReturn = uxTaskResetEventItemValue();
0000cc  f7fffffe          BL       uxTaskResetEventItemValue
0000d0  4606              MOV      r6,r0
;;;415    
;;;416    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0000d2  0180              LSLS     r0,r0,#6
0000d4  d410              BMI      |L12.248|
;;;417    		{
;;;418    			taskENTER_CRITICAL();
0000d6  f7fffffe          BL       vPortEnterCritical
;;;419    			{
;;;420    				/* The task timed out, just return the current event bit value. */
;;;421    				uxReturn = pxEventBits->uxEventBits;
;;;422    
;;;423    				/* It is possible that the event bits were updated between this
;;;424    				task leaving the Blocked state and running again. */
;;;425    				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
0000da  6826              LDR      r6,[r4,#0]
0000dc  4652              MOV      r2,r10
0000de  4629              MOV      r1,r5
0000e0  4630              MOV      r0,r6
0000e2  f7fffffe          BL       prvTestWaitCondition
0000e6  b128              CBZ      r0,|L12.244|
;;;426    				{
;;;427    					if( xClearOnExit != pdFALSE )
0000e8  f1b90f00          CMP      r9,#0
0000ec  d002              BEQ      |L12.244|
;;;428    					{
;;;429    						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0000ee  6820              LDR      r0,[r4,#0]
0000f0  43a8              BICS     r0,r0,r5
0000f2  6020              STR      r0,[r4,#0]
                  |L12.244|
;;;430    					}
;;;431    					else
;;;432    					{
;;;433    						mtCOVERAGE_TEST_MARKER();
;;;434    					}
;;;435    				}
;;;436    				else
;;;437    				{
;;;438    					mtCOVERAGE_TEST_MARKER();
;;;439    				}
;;;440    				xTimeoutOccurred = pdTRUE;
;;;441    			}
;;;442    			taskEXIT_CRITICAL();
0000f4  f7fffffe          BL       vPortExitCritical
                  |L12.248|
;;;443    		}
;;;444    		else
;;;445    		{
;;;446    			/* The task unblocked because the bits were set. */
;;;447    		}
;;;448    
;;;449    		/* The task blocked so control bits may have been set. */
;;;450    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0000f8  f026467f          BIC      r6,r6,#0xff000000
                  |L12.252|
;;;451    	}
;;;452    	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
;;;453    
;;;454    	/* Prevent compiler warnings when trace macros are not used. */
;;;455    	( void ) xTimeoutOccurred;
;;;456    
;;;457    	return uxReturn;
0000fc  4630              MOV      r0,r6
;;;458    }
0000fe  e8bd87f0          POP      {r4-r10,pc}
;;;459    /*-----------------------------------------------------------*/
                          ENDP

000102  0000              DCW      0x0000
                  |L12.260|
                          DCD      0xe000ed04

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\event_groups.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_event_groups_c_5f98c4ce____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_event_groups_c_5f98c4ce____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_event_groups_c_5f98c4ce____REVSH|
#line 402
|__asm___14_event_groups_c_5f98c4ce____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_event_groups_c_5f98c4ce____RRX|
#line 587
|__asm___14_event_groups_c_5f98c4ce____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
