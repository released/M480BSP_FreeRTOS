; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\port.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\port.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -I..\CPU -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\port.crf ..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM4F\port.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;501    
;;;502    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
000002  2050              MOVS     r0,#0x50
000004  f3808811          MSR      BASEPRI,r0
000008  f3bf8f4f          DSB      
00000c  f3bf8f6f          ISB      
;;;503    {
;;;504    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;505    	executes all interrupts must be unmasked.  There is therefore no need to
;;;506    	save and then restore the interrupt mask value as its value is already
;;;507    	known - therefore the slightly faster vPortRaiseBASEPRI() function is used
;;;508    	in place of portSET_INTERRUPT_MASK_FROM_ISR(). */
;;;509    	vPortRaiseBASEPRI();
;;;510    	{
;;;511    		/* Increment the RTOS tick. */
;;;512    		if( xTaskIncrementTick() != pdFALSE )
000010  f7fffffe          BL       xTaskIncrementTick
000014  b118              CBZ      r0,|L1.30|
;;;513    		{
;;;514    			/* A context switch is required.  Context switching is performed in
;;;515    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;516    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000016  4904              LDR      r1,|L1.40|
000018  f04f5080          MOV      r0,#0x10000000
00001c  6008              STR      r0,[r1,#0]
                  |L1.30|
00001e  2000              MOVS     r0,#0
000020  f3808811          MSR      BASEPRI,r0
;;;517    		}
;;;518    	}
;;;519    	vPortClearBASEPRIFromISR();
;;;520    }
000024  bd10              POP      {r4,pc}
;;;521    /*-----------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0xe000ed04

                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=2

                  prvTaskExitError PROC
;;;221    
;;;222    static void prvTaskExitError( void )
000000  4808              LDR      r0,|L2.36|
;;;223    {
;;;224    	/* A function that implements a task must not exit or attempt to return to
;;;225    	its caller as there is nothing to return to.  If a task wants to exit it
;;;226    	should instead call vTaskDelete( NULL ).
;;;227    
;;;228    	Artificially force an assert() to be triggered if configASSERT() is
;;;229    	defined, then stop here so application writers can catch the error. */
;;;230    	configASSERT( uxCriticalNesting == ~0UL );
000002  6840              LDR      r0,[r0,#4]  ; uxCriticalNesting
000004  1c40              ADDS     r0,r0,#1
000006  f04f0050          MOV      r0,#0x50
00000a  f3808811          MSR      BASEPRI,r0
00000e  d004              BEQ      |L2.26|
000010  f3bf8f4f          DSB                            ;223
000014  f3bf8f6f          ISB                            ;223
                  |L2.24|
000018  e7fe              B        |L2.24|
                  |L2.26|
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
                  |L2.34|
;;;231    	portDISABLE_INTERRUPTS();
;;;232    	for( ;; );
000022  e7fe              B        |L2.34|
;;;233    }
;;;234    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.36|
                          DCD      ||.data||

                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;191     */
;;;192    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  b510              PUSH     {r4,lr}
;;;193    {
;;;194    	/* Simulate the stack frame as it would be created by a context switch
;;;195    	interrupt. */
;;;196    
;;;197    	/* Offset added to account for the way the MCU uses the stack on entry/exit
;;;198    	of interrupts, and to ensure alignment. */
;;;199    	pxTopOfStack--;
000002  1f03              SUBS     r3,r0,#4
;;;200    
;;;201    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000004  f04f7480          MOV      r4,#0x1000000
;;;202    	pxTopOfStack--;
;;;203    	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
;;;204    	pxTopOfStack--;
;;;205    	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
;;;206    
;;;207    	/* Save code space by skipping register initialisation. */
;;;208    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
;;;209    	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
;;;210    
;;;211    	/* A save method is being used that requires each task to maintain its
;;;212    	own exec return value. */
;;;213    	pxTopOfStack--;
;;;214    	*pxTopOfStack = portINITIAL_EXC_RETURN;
;;;215    
;;;216    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
;;;217    
;;;218    	return pxTopOfStack;
000008  601c              STR      r4,[r3,#0]
00000a  1f1b              SUBS     r3,r3,#4
00000c  f0210101          BIC      r1,r1,#1              ;203
000010  6019              STR      r1,[r3,#0]
000012  1f19              SUBS     r1,r3,#4
000014  4b04              LDR      r3,|L3.40|
000016  600b              STR      r3,[r1,#0]
000018  3914              SUBS     r1,r1,#0x14
00001a  600a              STR      r2,[r1,#0]
00001c  1f09              SUBS     r1,r1,#4
00001e  f06f0202          MVN      r2,#2                 ;214
000022  3844              SUBS     r0,r0,#0x44           ;214
000024  600a              STR      r2,[r1,#0]            ;214
;;;219    }
000026  bd10              POP      {r4,pc}
;;;220    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.40|
                          DCD      prvTaskExitError

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=2

                  vPortEndScheduler PROC
;;;403    
;;;404    void vPortEndScheduler( void )
000000  4806              LDR      r0,|L4.28|
;;;405    {
;;;406    	/* Not implemented in ports where there is nothing to return to.
;;;407    	Artificially force an assert. */
;;;408    	configASSERT( uxCriticalNesting == 1000UL );
000002  6840              LDR      r0,[r0,#4]  ; uxCriticalNesting
000004  f5b07f7a          CMP      r0,#0x3e8
000008  d007              BEQ      |L4.26|
00000a  2050              MOVS     r0,#0x50              ;405
00000c  f3808811          MSR      BASEPRI,r0            ;405
000010  f3bf8f4f          DSB                            ;405
000014  f3bf8f6f          ISB                            ;405
                  |L4.24|
000018  e7fe              B        |L4.24|
                  |L4.26|
;;;409    }
00001a  4770              BX       lr
;;;410    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.28|
                          DCD      ||.data||

                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;411    
;;;412    void vPortEnterCritical( void )
000000  2050              MOVS     r0,#0x50
000002  f3808811          MSR      BASEPRI,r0
000006  f3bf8f4f          DSB      
00000a  f3bf8f6f          ISB      
;;;413    {
;;;414    	portDISABLE_INTERRUPTS();
;;;415    	uxCriticalNesting++;
00000e  490a              LDR      r1,|L5.56|
000010  6848              LDR      r0,[r1,#4]  ; uxCriticalNesting
000012  1c40              ADDS     r0,r0,#1
;;;416    
;;;417    	/* This is not the interrupt safe version of the enter critical function so
;;;418    	assert() if it is being called from an interrupt context.  Only API
;;;419    	functions that end in "FromISR" can be used in an interrupt.  Only assert if
;;;420    	the critical nesting count is 1 to protect against recursive calls if the
;;;421    	assert function also uses a critical section. */
;;;422    	if( uxCriticalNesting == 1 )
000014  6048              STR      r0,[r1,#4]  ; uxCriticalNesting
000016  2801              CMP      r0,#1
000018  d10c              BNE      |L5.52|
;;;423    	{
;;;424    		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
00001a  4808              LDR      r0,|L5.60|
00001c  6800              LDR      r0,[r0,#0]
00001e  f0100fff          TST      r0,#0xff
000022  d007              BEQ      |L5.52|
000024  2050              MOVS     r0,#0x50
000026  f3808811          MSR      BASEPRI,r0
00002a  f3bf8f4f          DSB      
00002e  f3bf8f6f          ISB      
                  |L5.50|
000032  e7fe              B        |L5.50|
                  |L5.52|
;;;425    	}
;;;426    }
000034  4770              BX       lr
;;;427    /*-----------------------------------------------------------*/
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      ||.data||
                  |L5.60|
                          DCD      0xe000ed04

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;428    
;;;429    void vPortExitCritical( void )
000000  4908              LDR      r1,|L6.36|
;;;430    {
000002  6848              LDR      r0,[r1,#4]  ; uxCriticalNesting
000004  b128              CBZ      r0,|L6.18|
000006  1e40              SUBS     r0,r0,#1
;;;431    	configASSERT( uxCriticalNesting );
;;;432    	uxCriticalNesting--;
;;;433    	if( uxCriticalNesting == 0 )
000008  6048              STR      r0,[r1,#4]  ; uxCriticalNesting
00000a  d101              BNE      |L6.16|
00000c  f3808811          MSR      BASEPRI,r0
                  |L6.16|
;;;434    	{
;;;435    		portENABLE_INTERRUPTS();
;;;436    	}
;;;437    }
000010  4770              BX       lr
                  |L6.18|
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L6.32|
000020  e7fe              B        |L6.32|
;;;438    /*-----------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      ||.data||

                          AREA ||i.vPortSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  vPortSetupTimerInterrupt PROC
;;;696    
;;;697    	void vPortSetupTimerInterrupt( void )
000000  f04f20e0          MOV      r0,#0xe000e000
;;;698    	{
;;;699    		/* Calculate the constants required to configure the tick interrupt. */
;;;700    		#if( configUSE_TICKLESS_IDLE == 1 )
;;;701    		{
;;;702    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;703    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;704    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;705    		}
;;;706    		#endif /* configUSE_TICKLESS_IDLE */
;;;707    
;;;708    		/* Stop and clear the SysTick. */
;;;709    		portNVIC_SYSTICK_CTRL_REG = 0UL;
000004  2100              MOVS     r1,#0
000006  6101              STR      r1,[r0,#0x10]
;;;710    		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
000008  6181              STR      r1,[r0,#0x18]
;;;711    
;;;712    		/* Configure SysTick to interrupt at the requested rate. */
;;;713    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
00000a  4905              LDR      r1,|L7.32|
00000c  f44f727a          MOV      r2,#0x3e8
000010  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000012  fbb1f1f2          UDIV     r1,r1,r2
000016  1e49              SUBS     r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
;;;714    		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
00001a  2107              MOVS     r1,#7
00001c  6101              STR      r1,[r0,#0x10]
;;;715    	}
00001e  4770              BX       lr
;;;716    
                          ENDP

                  |L7.32|
                          DCD      SystemCoreClock

                          AREA ||i.vPortValidateInterruptPriority||, CODE, READONLY, ALIGN=2

                  vPortValidateInterruptPriority PROC
;;;730    
;;;731    	void vPortValidateInterruptPriority( void )
000000  b510              PUSH     {r4,lr}
;;;732    	{
;;;733    	uint32_t ulCurrentInterrupt;
;;;734    	uint8_t ucCurrentPriority;
;;;735    
;;;736    		/* Obtain the number of the currently executing interrupt. */
;;;737    		ulCurrentInterrupt = vPortGetIPSR();
000002  f7fffffe          BL       vPortGetIPSR
;;;738    
;;;739    		/* Is the interrupt number a user defined interrupt? */
;;;740    		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
;;;741    		{
;;;742    			/* Look up the interrupt's priority. */
;;;743    			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
;;;744    
;;;745    			/* The following assertion will fail if a service routine (ISR) for
;;;746    			an interrupt that has been assigned a priority above
;;;747    			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
;;;748    			function.  ISR safe FreeRTOS API functions must *only* be called
;;;749    			from interrupts that have been assigned a priority at or below
;;;750    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;751    
;;;752    			Numerically low interrupt priority numbers represent logically high
;;;753    			interrupt priorities, therefore the priority of the interrupt must
;;;754    			be set to a value equal to or numerically *higher* than
;;;755    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;756    
;;;757    			Interrupts that	use the FreeRTOS API must not be left at their
;;;758    			default priority of	zero as that is the highest possible priority,
;;;759    			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
;;;760    			and	therefore also guaranteed to be invalid.
;;;761    
;;;762    			FreeRTOS maintains separate thread and ISR API functions to ensure
;;;763    			interrupt entry is as fast and simple as possible.
;;;764    
;;;765    			The following links provide detailed information:
;;;766    			http://www.freertos.org/RTOS-Cortex-M3-M4.html
;;;767    			http://www.freertos.org/FAQHelp.html */
;;;768    			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
000006  4911              LDR      r1,|L8.76|
000008  2810              CMP      r0,#0x10              ;740
00000a  d30e              BCC      |L8.42|
00000c  f10020e0          ADD      r0,r0,#0xe000e000     ;740
000010  f89003f0          LDRB     r0,[r0,#0x3f0]        ;743
000014  780a              LDRB     r2,[r1,#0]  ; ucMaxSysCallPriority
000016  4290              CMP      r0,r2
000018  d207              BCS      |L8.42|
00001a  2050              MOVS     r0,#0x50
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
                  |L8.40|
000028  e7fe              B        |L8.40|
                  |L8.42|
;;;769    		}
;;;770    
;;;771    		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
;;;772    		that define each interrupt's priority to be split between bits that
;;;773    		define the interrupt's pre-emption priority bits and bits that define
;;;774    		the interrupt's sub-priority.  For simplicity all bits must be defined
;;;775    		to be pre-emption priority bits.  The following assertion will fail if
;;;776    		this is not the case (if some bits represent a sub-priority).
;;;777    
;;;778    		If the application only uses CMSIS libraries for interrupt
;;;779    		configuration then the correct setting can be achieved on all Cortex-M
;;;780    		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
;;;781    		scheduler.  Note however that some vendor specific peripheral libraries
;;;782    		assume a non-zero priority group setting, in which cases using a value
;;;783    		of zero will result in unpredictable behaviour. */
;;;784    		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
00002a  4809              LDR      r0,|L8.80|
00002c  6800              LDR      r0,[r0,#0]
00002e  6889              LDR      r1,[r1,#8]  ; ulMaxPRIGROUPValue
000030  f40060e0          AND      r0,r0,#0x700
000034  4288              CMP      r0,r1
000036  d907              BLS      |L8.72|
000038  2050              MOVS     r0,#0x50
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
                  |L8.70|
000046  e7fe              B        |L8.70|
                  |L8.72|
;;;785    	}
000048  bd10              POP      {r4,pc}
;;;786    
                          ENDP

00004a  0000              DCW      0x0000
                  |L8.76|
                          DCD      ||.data||
                  |L8.80|
                          DCD      0xe000ed0c

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;300     */
;;;301    BaseType_t xPortStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;302    {
;;;303    	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
;;;304    	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
;;;305    	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
;;;306    
;;;307    	/* This port can be used on all revisions of the Cortex-M7 core other than
;;;308    	the r0p1 parts.  r0p1 parts should use the port from the
;;;309    	/source/portable/GCC/ARM_CM7/r0p1 directory. */
;;;310    	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
000002  4837              LDR      r0,|L9.224|
000004  6801              LDR      r1,[r0,#0]
000006  4a37              LDR      r2,|L9.228|
000008  4291              CMP      r1,r2
00000a  d107              BNE      |L9.28|
00000c  2050              MOVS     r0,#0x50              ;302
00000e  f3808811          MSR      BASEPRI,r0            ;302
000012  f3bf8f4f          DSB                            ;302
000016  f3bf8f6f          ISB                            ;302
                  |L9.26|
00001a  e7fe              B        |L9.26|
                  |L9.28|
;;;311    	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
00001c  6800              LDR      r0,[r0,#0]
00001e  4931              LDR      r1,|L9.228|
000020  1e49              SUBS     r1,r1,#1
000022  4288              CMP      r0,r1
000024  d107              BNE      |L9.54|
000026  2050              MOVS     r0,#0x50
000028  f3808811          MSR      BASEPRI,r0
00002c  f3bf8f4f          DSB      
000030  f3bf8f6f          ISB      
                  |L9.52|
000034  e7fe              B        |L9.52|
                  |L9.54|
;;;312    
;;;313    	#if( configASSERT_DEFINED == 1 )
;;;314    	{
;;;315    		volatile uint32_t ulOriginalPriority;
;;;316    		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
000036  492c              LDR      r1,|L9.232|
;;;317    		volatile uint8_t ucMaxPriorityValue;
;;;318    
;;;319    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;320    		functions can be called.  ISR safe functions are those that end in
;;;321    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;322    		ensure interrupt entry is as fast and simple as possible.
;;;323    
;;;324    		Save the interrupt priority value that is about to be clobbered. */
;;;325    		ulOriginalPriority = *pucFirstUserPriorityRegister;
000038  7808              LDRB     r0,[r1,#0]
;;;326    
;;;327    		/* Determine the number of priority bits available.  First write to all
;;;328    		possible bits. */
;;;329    		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
00003a  9001              STR      r0,[sp,#4]
00003c  20ff              MOVS     r0,#0xff
00003e  7008              STRB     r0,[r1,#0]
;;;330    
;;;331    		/* Read the value back to see how many bits stuck. */
;;;332    		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
000040  7808              LDRB     r0,[r1,#0]
000042  f88d0000          STRB     r0,[sp,#0]
;;;333    
;;;334    		/* The kernel interrupt priority should be set to the lowest
;;;335    		priority. */
;;;336    		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
000046  f89d0000          LDRB     r0,[sp,#0]
00004a  f89d2000          LDRB     r2,[sp,#0]
00004e  f00000f0          AND      r0,r0,#0xf0
000052  4290              CMP      r0,r2
000054  d007              BEQ      |L9.102|
000056  2050              MOVS     r0,#0x50
000058  f3808811          MSR      BASEPRI,r0
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
                  |L9.100|
000064  e7fe              B        |L9.100|
                  |L9.102|
;;;337    
;;;338    		/* Use the same mask on the maximum system call priority. */
;;;339    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
000066  f89d0000          LDRB     r0,[sp,#0]
00006a  4b20              LDR      r3,|L9.236|
00006c  f0000050          AND      r0,r0,#0x50
000070  7018              STRB     r0,[r3,#0]
;;;340    
;;;341    		/* Calculate the maximum acceptable priority group value for the number
;;;342    		of bits read back. */
;;;343    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
000072  2007              MOVS     r0,#7
;;;344    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
000074  6098              STR      r0,[r3,#8]  ; ulMaxPRIGROUPValue
000076  e006              B        |L9.134|
                  |L9.120|
000078  1e40              SUBS     r0,r0,#1
;;;345    		{
;;;346    			ulMaxPRIGROUPValue--;
;;;347    			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
00007a  6098              STR      r0,[r3,#8]  ; ulMaxPRIGROUPValue
00007c  f89d0000          LDRB     r0,[sp,#0]
000080  0040              LSLS     r0,r0,#1
000082  f88d0000          STRB     r0,[sp,#0]
                  |L9.134|
000086  f89d0000          LDRB     r0,[sp,#0]            ;344
00008a  0600              LSLS     r0,r0,#24             ;344
00008c  6898              LDR      r0,[r3,#8]            ;344  ; ulMaxPRIGROUPValue
00008e  d4f3              BMI      |L9.120|
;;;348    		}
;;;349    
;;;350    		#ifdef __NVIC_PRIO_BITS
;;;351    		{
;;;352    			/* Check the CMSIS configuration that defines the number of
;;;353    			priority bits matches the number of priority bits actually queried
;;;354    			from the hardware. */
;;;355    			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
000090  2803              CMP      r0,#3
000092  d007              BEQ      |L9.164|
000094  2050              MOVS     r0,#0x50
000096  f3808811          MSR      BASEPRI,r0
00009a  f3bf8f4f          DSB      
00009e  f3bf8f6f          ISB      
                  |L9.162|
0000a2  e7fe              B        |L9.162|
                  |L9.164|
;;;356    		}
;;;357    		#endif
;;;358    
;;;359    		#ifdef configPRIO_BITS
;;;360    		{
;;;361    			/* Check the FreeRTOS configuration that defines the number of
;;;362    			priority bits matches the number of priority bits actually queried
;;;363    			from the hardware. */
;;;364    			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
;;;365    		}
;;;366    		#endif
;;;367    
;;;368    		/* Shift the priority group value back to its position within the AIRCR
;;;369    		register. */
;;;370    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
0000a4  f44f7040          MOV      r0,#0x300
;;;371    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
;;;372    
;;;373    		/* Restore the clobbered interrupt priority register to its original
;;;374    		value. */
;;;375    		*pucFirstUserPriorityRegister = ulOriginalPriority;
0000a8  6098              STR      r0,[r3,#8]  ; ulMaxPRIGROUPValue
0000aa  9801              LDR      r0,[sp,#4]
0000ac  7008              STRB     r0,[r1,#0]
;;;376    	}
;;;377    	#endif /* conifgASSERT_DEFINED */
;;;378    
;;;379    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;380    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
0000ae  480c              LDR      r0,|L9.224|
0000b0  3020              ADDS     r0,r0,#0x20
0000b2  6801              LDR      r1,[r0,#0]
0000b4  f4410170          ORR      r1,r1,#0xf00000
0000b8  6001              STR      r1,[r0,#0]
;;;381    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
0000ba  6801              LDR      r1,[r0,#0]
0000bc  f0414170          ORR      r1,r1,#0xf0000000
0000c0  6001              STR      r1,[r0,#0]
;;;382    
;;;383    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;384    	here already. */
;;;385    	vPortSetupTimerInterrupt();
0000c2  f7fffffe          BL       vPortSetupTimerInterrupt
;;;386    
;;;387    	/* Initialise the critical nesting count ready for the first task. */
;;;388    	uxCriticalNesting = 0;
0000c6  2000              MOVS     r0,#0
;;;389    
;;;390    	/* Ensure the VFP is enabled - it should be anyway. */
;;;391    	prvEnableVFP();
0000c8  6058              STR      r0,[r3,#4]  ; uxCriticalNesting
0000ca  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvEnableVFP
;;;392    
;;;393    	/* Lazy save always. */
;;;394    	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
0000ce  4808              LDR      r0,|L9.240|
0000d0  6801              LDR      r1,[r0,#0]
0000d2  f0414140          ORR      r1,r1,#0xc0000000
0000d6  6001              STR      r1,[r0,#0]
;;;395    
;;;396    	/* Start the first task. */
;;;397    	prvStartFirstTask();
0000d8  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;398    
;;;399    	/* Should not get here! */
;;;400    	return 0;
0000dc  2000              MOVS     r0,#0
;;;401    }
0000de  bd1c              POP      {r2-r4,pc}
;;;402    /*-----------------------------------------------------------*/
                          ENDP

                  |L9.224|
                          DCD      0xe000ed00
                  |L9.228|
                          DCD      0x410fc271
                  |L9.232|
                          DCD      0xe000e400
                  |L9.236|
                          DCD      ||.data||
                  |L9.240|
                          DCD      0xe000ef34

                          AREA ||.data||, DATA, ALIGN=2

                  ucMaxSysCallPriority
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  uxCriticalNesting
                          DCD      0xaaaaaaaa
                  ulMaxPRIGROUPValue
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\portable\\RVDS\\ARM_CM4F\\port.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_port_c_39a90d8d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d____REVSH|
#line 402
|__asm___6_port_c_39a90d8d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d____RRX|
#line 587
|__asm___6_port_c_39a90d8d____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SVC_Handler|
#line 236 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\portable\\RVDS\\ARM_CM4F\\port.c"
|SVC_Handler| PROC
#line 237

 PRESERVE8

 
 ldr r3, =pxCurrentTCB
 ldr r1, [r3]
 ldr r0, [r1]
 
 ldmia r0!, {r4-r11, r14}
 msr psp, r0
 isb
 mov r0, #0
 msr basepri, r0
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 254
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 255

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]
 
 msr msp, r0
#line 267
 
 mov r0, #0
 msr control, r0
 
 cpsie i
 cpsie f
 dsb
 isb
 
 svc 0
 nop
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvEnableVFP|
#line 282
|__asm___6_port_c_39a90d8d__prvEnableVFP| PROC
#line 283

 PRESERVE8

 
 ldr.w r0, =0xE000ED88
 ldr r1, [r0]

 
 orr r1, r1, #( 0xf << 20 )
 str r1, [r0]
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
#line 440
|PendSV_Handler| PROC
#line 441

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp
 isb
 
 ldr r3, =pxCurrentTCB
 ldr r2, [r3]

 
 tst r14, #0x10
 it eq
 vstmdbeq r0!, {s16-s31}

 
 stmdb r0!, {r4-r11, r14}

 
 str r0, [r2]

 stmdb sp!, {r0, r3}
 mov r0, #( 5 << (8 - 4) )
 msr basepri, r0
 dsb
 isb
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r0, r3}

 
 ldr r1, [r3]
 ldr r0, [r1]

 
 ldmia r0!, {r4-r11, r14}

#line 483
 
 tst r14, #0x10
 it eq
 vldmiaeq r0!, {s16-s31}

 msr psp, r0
 isb
 
#line 497

 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortGetIPSR|
#line 720
|vPortGetIPSR| PROC
#line 721

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
