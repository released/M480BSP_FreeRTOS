; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\heap_4.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\heap_4.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -I..\CPU -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\heap_4.crf ..\..\..\ThirdParty\FreeRTOS\Source\portable\MemMang\heap_4.c]
                          THUMB

                          AREA ||i.prvHeapInit||, CODE, READONLY, ALIGN=2

                  prvHeapInit PROC
;;;329    
;;;330    static void prvHeapInit( void )
000000  4810              LDR      r0,|L1.68|
;;;331    {
;;;332    BlockLink_t *pxFirstFreeBlock;
;;;333    uint8_t *pucAlignedHeap;
;;;334    size_t uxAddress;
;;;335    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
000002  f44f4180          MOV      r1,#0x4000
;;;336    
;;;337    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;338    	uxAddress = ( size_t ) ucHeap;
;;;339    
;;;340    	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
000006  0742              LSLS     r2,r0,#29
000008  d006              BEQ      |L1.24|
00000a  1dc0              ADDS     r0,r0,#7              ;331
;;;341    	{
;;;342    		uxAddress += ( portBYTE_ALIGNMENT - 1 );
;;;343    		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
;;;344    		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
00000c  490d              LDR      r1,|L1.68|
00000e  f0200007          BIC      r0,r0,#7              ;343
000012  1a41              SUBS     r1,r0,r1
000014  f5c14180          RSB      r1,r1,#0x4000
                  |L1.24|
;;;345    	}
;;;346    
;;;347    	pucAlignedHeap = ( uint8_t * ) uxAddress;
;;;348    
;;;349    	/* xStart is used to hold a pointer to the first item in the list of free
;;;350    	blocks.  The void cast is used to prevent compiler warnings. */
;;;351    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
000018  4a0b              LDR      r2,|L1.72|
;;;352    	xStart.xBlockSize = ( size_t ) 0;
00001a  2300              MOVS     r3,#0
;;;353    
;;;354    	/* pxEnd is used to mark the end of the list of free blocks and is inserted
;;;355    	at the end of the heap space. */
;;;356    	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
00001c  4401              ADD      r1,r1,r0
00001e  e9c20300          STRD     r0,r3,[r2,#0]         ;352
000022  3908              SUBS     r1,r1,#8
;;;357    	uxAddress -= xHeapStructSize;
;;;358    	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
;;;359    	pxEnd = ( void * ) uxAddress;
000024  3a10              SUBS     r2,r2,#0x10
000026  f0210107          BIC      r1,r1,#7              ;358
;;;360    	pxEnd->xBlockSize = 0;
00002a  6011              STR      r1,[r2,#0]  ; pxEnd
;;;361    	pxEnd->pxNextFreeBlock = NULL;
00002c  604b              STR      r3,[r1,#4]
;;;362    
;;;363    	/* To start with there is a single free block that is sized to take up the
;;;364    	entire heap space, minus the space taken by pxEnd. */
;;;365    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
;;;366    	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
00002e  600b              STR      r3,[r1,#0]
000030  1a0b              SUBS     r3,r1,r0
000032  e9c01300          STRD     r1,r3,[r0,#0]
;;;367    	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
;;;368    
;;;369    	/* Only one block exists - and it covers the entire usable heap space. */
;;;370    	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
;;;371    	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
000036  6093              STR      r3,[r2,#8]  ; xMinimumEverFreeBytesRemaining
;;;372    
;;;373    	/* Work out the position of the top bit in a size_t variable. */
;;;374    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
000038  f04f4000          MOV      r0,#0x80000000
00003c  6053              STR      r3,[r2,#4]  ; xFreeBytesRemaining
00003e  60d0              STR      r0,[r2,#0xc]  ; xBlockAllocatedBit
;;;375    }
000040  4770              BX       lr
;;;376    /*-----------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      ||.bss||
                  |L1.72|
                          DCD      ||.data||+0x10

                          AREA ||i.prvInsertBlockIntoFreeList||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;377    
;;;378    static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
000000  b530              PUSH     {r4,r5,lr}
;;;379    {
;;;380    BlockLink_t *pxIterator;
;;;381    uint8_t *puc;
;;;382    
;;;383    	/* Iterate through the list until a block is found that has a higher address
;;;384    	than the block being inserted. */
;;;385    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000002  4911              LDR      r1,|L2.72|
000004  e000              B        |L2.8|
                  |L2.6|
000006  4611              MOV      r1,r2                 ;379
                  |L2.8|
000008  680a              LDR      r2,[r1,#0]
00000a  4282              CMP      r2,r0
00000c  d3fb              BCC      |L2.6|
;;;386    	{
;;;387    		/* Nothing to do here, just iterate to the right position. */
;;;388    	}
;;;389    
;;;390    	/* Do the block being inserted, and the block it is being inserted after
;;;391    	make a contiguous block of memory? */
;;;392    	puc = ( uint8_t * ) pxIterator;
;;;393    	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
00000e  684b              LDR      r3,[r1,#4]
000010  185c              ADDS     r4,r3,r1
000012  4284              CMP      r4,r0
000014  d103              BNE      |L2.30|
;;;394    	{
;;;395    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
000016  6840              LDR      r0,[r0,#4]
000018  4418              ADD      r0,r0,r3
;;;396    		pxBlockToInsert = pxIterator;
00001a  6048              STR      r0,[r1,#4]
00001c  4608              MOV      r0,r1
                  |L2.30|
;;;397    	}
;;;398    	else
;;;399    	{
;;;400    		mtCOVERAGE_TEST_MARKER();
;;;401    	}
;;;402    
;;;403    	/* Do the block being inserted, and the block it is being inserted before
;;;404    	make a contiguous block of memory? */
;;;405    	puc = ( uint8_t * ) pxBlockToInsert;
;;;406    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
00001e  6843              LDR      r3,[r0,#4]
000020  181c              ADDS     r4,r3,r0
000022  4294              CMP      r4,r2
000024  d109              BNE      |L2.58|
;;;407    	{
;;;408    		if( pxIterator->pxNextFreeBlock != pxEnd )
000026  4c08              LDR      r4,|L2.72|
000028  3c10              SUBS     r4,r4,#0x10
00002a  6824              LDR      r4,[r4,#0]  ; pxEnd
00002c  42a2              CMP      r2,r4
00002e  d009              BEQ      |L2.68|
;;;409    		{
;;;410    			/* Form one big block from the two blocks. */
;;;411    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
000030  6852              LDR      r2,[r2,#4]
000032  441a              ADD      r2,r2,r3
;;;412    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000034  6042              STR      r2,[r0,#4]
000036  680a              LDR      r2,[r1,#0]
000038  6812              LDR      r2,[r2,#0]
                  |L2.58|
;;;413    		}
;;;414    		else
;;;415    		{
;;;416    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
;;;417    		}
;;;418    	}
;;;419    	else
;;;420    	{
;;;421    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
00003a  6002              STR      r2,[r0,#0]
                  |L2.60|
;;;422    	}
;;;423    
;;;424    	/* If the block being inserted plugged a gab, so was merged with the block
;;;425    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;426    	already been set, and should not be set here as that would make it point
;;;427    	to itself. */
;;;428    	if( pxIterator != pxBlockToInsert )
00003c  4281              CMP      r1,r0
00003e  d000              BEQ      |L2.66|
;;;429    	{
;;;430    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
000040  6008              STR      r0,[r1,#0]
                  |L2.66|
;;;431    	}
;;;432    	else
;;;433    	{
;;;434    		mtCOVERAGE_TEST_MARKER();
;;;435    	}
;;;436    }
000042  bd30              POP      {r4,r5,pc}
                  |L2.68|
000044  6004              STR      r4,[r0,#0]            ;416
000046  e7f9              B        |L2.60|
;;;437    
                          ENDP

                  |L2.72|
                          DCD      ||.data||+0x10

                          AREA ||i.pvPortMalloc||, CODE, READONLY, ALIGN=2

                  pvPortMalloc PROC
;;;113    
;;;114    void *pvPortMalloc( size_t xWantedSize )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;115    {
000004  4605              MOV      r5,r0
;;;116    BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;117    void *pvReturn = NULL;
000006  2600              MOVS     r6,#0
;;;118    
;;;119    	vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;120    	{
;;;121    		/* If this is the first call to malloc then the heap will require
;;;122    		initialisation to setup the list of free blocks. */
;;;123    		if( pxEnd == NULL )
00000c  4f32              LDR      r7,|L3.216|
00000e  6838              LDR      r0,[r7,#0]  ; pxEnd
000010  b908              CBNZ     r0,|L3.22|
;;;124    		{
;;;125    			prvHeapInit();
000012  f7fffffe          BL       prvHeapInit
                  |L3.22|
;;;126    		}
;;;127    		else
;;;128    		{
;;;129    			mtCOVERAGE_TEST_MARKER();
;;;130    		}
;;;131    
;;;132    		/* Check the requested block size is not so large that the top bit is
;;;133    		set.  The top bit of the block size member of the BlockLink_t structure
;;;134    		is used to determine who owns the block - the application or the
;;;135    		kernel, so it must be free. */
;;;136    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
000016  68f8              LDR      r0,[r7,#0xc]  ; xBlockAllocatedBit
000018  4205              TST      r5,r0
00001a  d14b              BNE      |L3.180|
;;;137    		{
;;;138    			/* The wanted size is increased so it can contain a BlockLink_t
;;;139    			structure in addition to the requested amount of bytes. */
;;;140    			if( xWantedSize > 0 )
00001c  b3c5              CBZ      r5,|L3.144|
00001e  3508              ADDS     r5,r5,#8
;;;141    			{
;;;142    				xWantedSize += xHeapStructSize;
;;;143    
;;;144    				/* Ensure that blocks are always aligned to the required number
;;;145    				of bytes. */
;;;146    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
000020  0768              LSLS     r0,r5,#29
000022  d00e              BEQ      |L3.66|
;;;147    				{
;;;148    					/* Byte alignment required. */
;;;149    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
000024  f0050007          AND      r0,r5,#7
000028  f1c00008          RSB      r0,r0,#8
00002c  4405              ADD      r5,r5,r0
;;;150    					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
00002e  0768              LSLS     r0,r5,#29
000030  d007              BEQ      |L3.66|
000032  2050              MOVS     r0,#0x50
000034  f3808811          MSR      BASEPRI,r0
000038  f3bf8f4f          DSB      
00003c  f3bf8f6f          ISB      
                  |L3.64|
000040  e7fe              B        |L3.64|
                  |L3.66|
;;;151    				}
;;;152    				else
;;;153    				{
;;;154    					mtCOVERAGE_TEST_MARKER();
;;;155    				}
;;;156    			}
;;;157    			else
;;;158    			{
;;;159    				mtCOVERAGE_TEST_MARKER();
;;;160    			}
;;;161    
;;;162    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
000042  b32d              CBZ      r5,|L3.144|
000044  6878              LDR      r0,[r7,#4]  ; xFreeBytesRemaining
000046  4285              CMP      r5,r0
000048  d834              BHI      |L3.180|
;;;163    			{
;;;164    				/* Traverse the list from the start	(lowest address) block until
;;;165    				one	of adequate size is found. */
;;;166    				pxPreviousBlock = &xStart;
00004a  4923              LDR      r1,|L3.216|
00004c  3110              ADDS     r1,r1,#0x10
;;;167    				pxBlock = xStart.pxNextFreeBlock;
00004e  4608              MOV      r0,r1
;;;168    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
000050  6804              LDR      r4,[r0,#0]  ; xStart
000052  e001              B        |L3.88|
                  |L3.84|
;;;169    				{
;;;170    					pxPreviousBlock = pxBlock;
000054  4621              MOV      r1,r4
;;;171    					pxBlock = pxBlock->pxNextFreeBlock;
000056  4604              MOV      r4,r0
                  |L3.88|
000058  6860              LDR      r0,[r4,#4]            ;168
00005a  42a8              CMP      r0,r5                 ;168
00005c  d202              BCS      |L3.100|
00005e  6820              LDR      r0,[r4,#0]            ;168
000060  2800              CMP      r0,#0                 ;168
000062  d1f7              BNE      |L3.84|
                  |L3.100|
;;;172    				}
;;;173    
;;;174    				/* If the end marker was reached then a block of adequate size
;;;175    				was	not found. */
;;;176    				if( pxBlock != pxEnd )
000064  6838              LDR      r0,[r7,#0]  ; pxEnd
000066  4284              CMP      r4,r0
000068  d024              BEQ      |L3.180|
;;;177    				{
;;;178    					/* Return the memory space pointed to - jumping over the
;;;179    					BlockLink_t structure at its start. */
;;;180    					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
;;;181    
;;;182    					/* This block is being returned for use so must be taken out
;;;183    					of the list of free blocks. */
;;;184    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
00006a  680e              LDR      r6,[r1,#0]
00006c  6820              LDR      r0,[r4,#0]
;;;185    
;;;186    					/* If the block is larger than required it can be split into
;;;187    					two. */
;;;188    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
00006e  6008              STR      r0,[r1,#0]
000070  6860              LDR      r0,[r4,#4]
000072  3608              ADDS     r6,r6,#8
000074  1b41              SUBS     r1,r0,r5
000076  2910              CMP      r1,#0x10
000078  d90f              BLS      |L3.154|
;;;189    					{
;;;190    						/* This block is to be split into two.  Create a new
;;;191    						block following the number of bytes requested. The void
;;;192    						cast is used to prevent byte alignment warnings from the
;;;193    						compiler. */
;;;194    						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
00007a  1960              ADDS     r0,r4,r5
;;;195    						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
00007c  0742              LSLS     r2,r0,#29
00007e  d008              BEQ      |L3.146|
000080  2050              MOVS     r0,#0x50
000082  f3808811          MSR      BASEPRI,r0
000086  f3bf8f4f          DSB      
00008a  f3bf8f6f          ISB      
                  |L3.142|
00008e  e7fe              B        |L3.142|
                  |L3.144|
000090  e010              B        |L3.180|
                  |L3.146|
;;;196    
;;;197    						/* Calculate the sizes of two blocks split from the
;;;198    						single block. */
;;;199    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
;;;200    						pxBlock->xBlockSize = xWantedSize;
000092  6041              STR      r1,[r0,#4]
;;;201    
;;;202    						/* Insert the new block into the list of free blocks. */
;;;203    						prvInsertBlockIntoFreeList( pxNewBlockLink );
000094  6065              STR      r5,[r4,#4]
000096  f7fffffe          BL       prvInsertBlockIntoFreeList
                  |L3.154|
;;;204    					}
;;;205    					else
;;;206    					{
;;;207    						mtCOVERAGE_TEST_MARKER();
;;;208    					}
;;;209    
;;;210    					xFreeBytesRemaining -= pxBlock->xBlockSize;
00009a  6861              LDR      r1,[r4,#4]
00009c  6878              LDR      r0,[r7,#4]  ; xFreeBytesRemaining
00009e  1a40              SUBS     r0,r0,r1
;;;211    
;;;212    					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
0000a0  6078              STR      r0,[r7,#4]  ; xFreeBytesRemaining
0000a2  68ba              LDR      r2,[r7,#8]  ; xMinimumEverFreeBytesRemaining
0000a4  4290              CMP      r0,r2
0000a6  d200              BCS      |L3.170|
;;;213    					{
;;;214    						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
0000a8  60b8              STR      r0,[r7,#8]  ; xMinimumEverFreeBytesRemaining
                  |L3.170|
;;;215    					}
;;;216    					else
;;;217    					{
;;;218    						mtCOVERAGE_TEST_MARKER();
;;;219    					}
;;;220    
;;;221    					/* The block is being returned - it is allocated and owned
;;;222    					by the application and has no "next" block. */
;;;223    					pxBlock->xBlockSize |= xBlockAllocatedBit;
0000aa  68f8              LDR      r0,[r7,#0xc]  ; xBlockAllocatedBit
0000ac  4301              ORRS     r1,r1,r0
;;;224    					pxBlock->pxNextFreeBlock = NULL;
0000ae  2000              MOVS     r0,#0
0000b0  e9c40100          STRD     r0,r1,[r4,#0]
                  |L3.180|
;;;225    				}
;;;226    				else
;;;227    				{
;;;228    					mtCOVERAGE_TEST_MARKER();
;;;229    				}
;;;230    			}
;;;231    			else
;;;232    			{
;;;233    				mtCOVERAGE_TEST_MARKER();
;;;234    			}
;;;235    		}
;;;236    		else
;;;237    		{
;;;238    			mtCOVERAGE_TEST_MARKER();
;;;239    		}
;;;240    
;;;241    		traceMALLOC( pvReturn, xWantedSize );
;;;242    	}
;;;243    	( void ) xTaskResumeAll();
0000b4  f7fffffe          BL       xTaskResumeAll
;;;244    
;;;245    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;246    	{
;;;247    		if( pvReturn == NULL )
0000b8  b90e              CBNZ     r6,|L3.190|
;;;248    		{
;;;249    			extern void vApplicationMallocFailedHook( void );
;;;250    			vApplicationMallocFailedHook();
0000ba  f7fffffe          BL       vApplicationMallocFailedHook
                  |L3.190|
;;;251    		}
;;;252    		else
;;;253    		{
;;;254    			mtCOVERAGE_TEST_MARKER();
;;;255    		}
;;;256    	}
;;;257    	#endif
;;;258    
;;;259    	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
0000be  0770              LSLS     r0,r6,#29
0000c0  d007              BEQ      |L3.210|
0000c2  2050              MOVS     r0,#0x50
0000c4  f3808811          MSR      BASEPRI,r0
0000c8  f3bf8f4f          DSB      
0000cc  f3bf8f6f          ISB      
                  |L3.208|
0000d0  e7fe              B        |L3.208|
                  |L3.210|
;;;260    	return pvReturn;
0000d2  4630              MOV      r0,r6
;;;261    }
0000d4  e8bd81f0          POP      {r4-r8,pc}
;;;262    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.216|
                          DCD      ||.data||

                          AREA ||i.vPortFree||, CODE, READONLY, ALIGN=2

                  vPortFree PROC
;;;263    
;;;264    void vPortFree( void *pv )
000000  b570              PUSH     {r4-r6,lr}
;;;265    {
000002  2800              CMP      r0,#0
000004  d027              BEQ      |L4.86|
;;;266    uint8_t *puc = ( uint8_t * ) pv;
;;;267    BlockLink_t *pxLink;
;;;268    
;;;269    	if( pv != NULL )
;;;270    	{
;;;271    		/* The memory being freed will have an BlockLink_t structure immediately
;;;272    		before it. */
;;;273    		puc -= xHeapStructSize;
;;;274    
;;;275    		/* This casting is to keep the compiler from issuing warnings. */
;;;276    		pxLink = ( void * ) puc;
;;;277    
;;;278    		/* Check the block is actually allocated. */
;;;279    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
000006  4d14              LDR      r5,|L4.88|
000008  f1a00408          SUB      r4,r0,#8              ;265
00000c  6860              LDR      r0,[r4,#4]
00000e  68e9              LDR      r1,[r5,#0xc]  ; xBlockAllocatedBit
000010  4208              TST      r0,r1
000012  d107              BNE      |L4.36|
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
                  |L4.34|
000022  e7fe              B        |L4.34|
                  |L4.36|
;;;280    		configASSERT( pxLink->pxNextFreeBlock == NULL );
000024  6822              LDR      r2,[r4,#0]
000026  b13a              CBZ      r2,|L4.56|
000028  2050              MOVS     r0,#0x50
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L4.54|
000036  e7fe              B        |L4.54|
                  |L4.56|
;;;281    
;;;282    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
;;;283    		{
;;;284    			if( pxLink->pxNextFreeBlock == NULL )
;;;285    			{
;;;286    				/* The block is being returned to the heap - it is no longer
;;;287    				allocated. */
;;;288    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
000038  4388              BICS     r0,r0,r1
;;;289    
;;;290    				vTaskSuspendAll();
00003a  6060              STR      r0,[r4,#4]
00003c  f7fffffe          BL       vTaskSuspendAll
;;;291    				{
;;;292    					/* Add this block to the list of free blocks. */
;;;293    					xFreeBytesRemaining += pxLink->xBlockSize;
000040  6860              LDR      r0,[r4,#4]
000042  6869              LDR      r1,[r5,#4]  ; xFreeBytesRemaining
000044  4408              ADD      r0,r0,r1
;;;294    					traceFREE( pv, pxLink->xBlockSize );
;;;295    					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
000046  6068              STR      r0,[r5,#4]  ; xFreeBytesRemaining
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       prvInsertBlockIntoFreeList
;;;296    				}
;;;297    				( void ) xTaskResumeAll();
00004e  e8bd4070          POP      {r4-r6,lr}
000052  f7ffbffe          B.W      xTaskResumeAll
                  |L4.86|
;;;298    			}
;;;299    			else
;;;300    			{
;;;301    				mtCOVERAGE_TEST_MARKER();
;;;302    			}
;;;303    		}
;;;304    		else
;;;305    		{
;;;306    			mtCOVERAGE_TEST_MARKER();
;;;307    		}
;;;308    	}
;;;309    }
000056  bd70              POP      {r4-r6,pc}
;;;310    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.88|
                          DCD      ||.data||

                          AREA ||i.vPortInitialiseBlocks||, CODE, READONLY, ALIGN=1

                  vPortInitialiseBlocks PROC
;;;323    
;;;324    void vPortInitialiseBlocks( void )
000000  4770              BX       lr
;;;325    {
;;;326    	/* This just exists to keep the linker quiet. */
;;;327    }
;;;328    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xPortGetFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetFreeHeapSize PROC
;;;311    
;;;312    size_t xPortGetFreeHeapSize( void )
000000  4801              LDR      r0,|L6.8|
;;;313    {
;;;314    	return xFreeBytesRemaining;
000002  6840              LDR      r0,[r0,#4]  ; xFreeBytesRemaining
;;;315    }
000004  4770              BX       lr
;;;316    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||.data||

                          AREA ||i.xPortGetMinimumEverFreeHeapSize||, CODE, READONLY, ALIGN=2

                  xPortGetMinimumEverFreeHeapSize PROC
;;;317    
;;;318    size_t xPortGetMinimumEverFreeHeapSize( void )
000000  4801              LDR      r0,|L7.8|
;;;319    {
;;;320    	return xMinimumEverFreeBytesRemaining;
000002  6880              LDR      r0,[r0,#8]  ; xMinimumEverFreeBytesRemaining
;;;321    }
000004  4770              BX       lr
;;;322    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        16384

                          AREA ||.data||, DATA, ALIGN=2

                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x00000000
                  xMinimumEverFreeBytesRemaining
                          DCD      0x00000000
                  xBlockAllocatedBit
                          DCD      0x00000000
                  xStart
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\portable\\MemMang\\heap_4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_heap_4_c_94e30ff9____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_heap_4_c_94e30ff9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_heap_4_c_94e30ff9____REVSH|
#line 402
|__asm___8_heap_4_c_94e30ff9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_heap_4_c_94e30ff9____RRX|
#line 587
|__asm___8_heap_4_c_94e30ff9____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
