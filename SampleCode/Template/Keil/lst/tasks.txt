; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tasks.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\tasks.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -I..\CPU -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\tasks.crf ..\..\..\ThirdParty\FreeRTOS\Source\tasks.c]
                          THUMB

                          AREA ||i.eTaskGetState||, CODE, READONLY, ALIGN=2

                  eTaskGetState PROC
;;;1332   
;;;1333   	eTaskState eTaskGetState( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1334   	{
000002  0005              MOVS     r5,r0
000004  d005              BEQ      |L1.18|
;;;1335   	eTaskState eReturn;
;;;1336   	List_t *pxStateList;
;;;1337   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
;;;1338   
;;;1339   		configASSERT( pxTCB );
;;;1340   
;;;1341   		if( pxTCB == pxCurrentTCB )
000006  4e16              LDR      r6,|L1.96|
000008  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
00000a  4285              CMP      r5,r0
00000c  d109              BNE      |L1.34|
;;;1342   		{
;;;1343   			/* The task calling this function is querying its own state. */
;;;1344   			eReturn = eRunning;
00000e  2000              MOVS     r0,#0
;;;1345   		}
;;;1346   		else
;;;1347   		{
;;;1348   			taskENTER_CRITICAL();
;;;1349   			{
;;;1350   				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
;;;1351   			}
;;;1352   			taskEXIT_CRITICAL();
;;;1353   
;;;1354   			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
;;;1355   			{
;;;1356   				/* The task being queried is referenced from one of the Blocked
;;;1357   				lists. */
;;;1358   				eReturn = eBlocked;
;;;1359   			}
;;;1360   
;;;1361   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1362   				else if( pxStateList == &xSuspendedTaskList )
;;;1363   				{
;;;1364   					/* The task being queried is referenced from the suspended
;;;1365   					list.  Is it genuinely suspended or is it block
;;;1366   					indefinitely? */
;;;1367   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
;;;1368   					{
;;;1369   						eReturn = eSuspended;
;;;1370   					}
;;;1371   					else
;;;1372   					{
;;;1373   						eReturn = eBlocked;
;;;1374   					}
;;;1375   				}
;;;1376   			#endif
;;;1377   
;;;1378   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1379   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
;;;1380   				{
;;;1381   					/* The task being queried is referenced from the deleted
;;;1382   					tasks list, or it is not referenced from any lists at
;;;1383   					all. */
;;;1384   					eReturn = eDeleted;
;;;1385   				}
;;;1386   			#endif
;;;1387   
;;;1388   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1389   			{
;;;1390   				/* If the task is not in any other state, it must be in the
;;;1391   				Ready (including pending ready) state. */
;;;1392   				eReturn = eReady;
;;;1393   			}
;;;1394   		}
;;;1395   
;;;1396   		return eReturn;
;;;1397   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000010  bd70              POP      {r4-r6,pc}
                  |L1.18|
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L1.32|
000020  e7fe              B        |L1.32|
                  |L1.34|
000022  f7fffffe          BL       vPortEnterCritical
000026  696c              LDR      r4,[r5,#0x14]         ;1352
000028  f7fffffe          BL       vPortExitCritical
00002c  6b70              LDR      r0,[r6,#0x34]         ;1354  ; pxDelayedTaskList
00002e  4284              CMP      r4,r0                 ;1354
000030  d002              BEQ      |L1.56|
000032  6bb0              LDR      r0,[r6,#0x38]         ;1354  ; pxOverflowDelayedTaskList
000034  4284              CMP      r4,r0                 ;1354
000036  d101              BNE      |L1.60|
                  |L1.56|
000038  2002              MOVS     r0,#2                 ;1358
00003a  bd70              POP      {r4-r6,pc}
                  |L1.60|
00003c  4809              LDR      r0,|L1.100|
00003e  4284              CMP      r4,r0                 ;1362
000040  d104              BNE      |L1.76|
000042  6aa8              LDR      r0,[r5,#0x28]         ;1367
000044  2800              CMP      r0,#0                 ;1367
000046  d1f7              BNE      |L1.56|
000048  2003              MOVS     r0,#3                 ;1369
00004a  bd70              POP      {r4-r6,pc}
                  |L1.76|
00004c  4805              LDR      r0,|L1.100|
00004e  3814              SUBS     r0,r0,#0x14           ;1379
000050  4284              CMP      r4,r0                 ;1379
000052  d002              BEQ      |L1.90|
000054  b10c              CBZ      r4,|L1.90|
000056  2001              MOVS     r0,#1                 ;1392
000058  bd70              POP      {r4-r6,pc}
                  |L1.90|
00005a  2004              MOVS     r0,#4                 ;1384
00005c  bd70              POP      {r4-r6,pc}
;;;1398   
                          ENDP

00005e  0000              DCW      0x0000
                  |L1.96|
                          DCD      ||.data||
                  |L1.100|
                          DCD      ||.bss||+0xb4

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                  pcTaskGetName PROC
;;;2268   
;;;2269   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  b908              CBNZ     r0,|L2.6|
;;;2270   {
;;;2271   TCB_t *pxTCB;
;;;2272   
;;;2273   	/* If null is passed in here then the name of the calling task is being
;;;2274   	queried. */
;;;2275   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000002  4806              LDR      r0,|L2.28|
000004  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
                  |L2.6|
;;;2276   	configASSERT( pxTCB );
000006  b108              CBZ      r0,|L2.12|
000008  3034              ADDS     r0,r0,#0x34
;;;2277   	return &( pxTCB->pcTaskName[ 0 ] );
;;;2278   }
00000a  4770              BX       lr
                  |L2.12|
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
                  |L2.26|
00001a  e7fe              B        |L2.26|
;;;2279   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.28|
                          DCD      ||.data||

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;4908   
;;;4909   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4910   {
;;;4911   TickType_t xTimeToWake;
;;;4912   const TickType_t xConstTickCount = xTickCount;
000004  4e18              LDR      r6,|L3.104|
000006  460f              MOV      r7,r1                 ;4910
000008  4604              MOV      r4,r0                 ;4910
00000a  68f5              LDR      r5,[r6,#0xc]  ; xTickCount
;;;4913   
;;;4914   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;4915   	{
;;;4916   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;4917   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;4918   		when the task leaves the Blocked state. */
;;;4919   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;4920   	}
;;;4921   	#endif
;;;4922   
;;;4923   	/* Remove the task from the ready list before adding it to the blocked list
;;;4924   	as the same list item is used for both lists. */
;;;4925   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000c  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
00000e  1d00              ADDS     r0,r0,#4
000010  f7fffffe          BL       uxListRemove
000014  b938              CBNZ     r0,|L3.38|
;;;4926   	{
;;;4927   		/* The current task must be in a ready list, so there is no need to
;;;4928   		check, and the port reset macro can be called directly. */
;;;4929   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000016  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
000018  f890102c          LDRB     r1,[r0,#0x2c]
00001c  2001              MOVS     r0,#1
00001e  4088              LSLS     r0,r0,r1
000020  6931              LDR      r1,[r6,#0x10]  ; uxTopReadyPriority
000022  4381              BICS     r1,r1,r0
000024  6131              STR      r1,[r6,#0x10]  ; uxTopReadyPriority
                  |L3.38|
;;;4930   	}
;;;4931   	else
;;;4932   	{
;;;4933   		mtCOVERAGE_TEST_MARKER();
;;;4934   	}
;;;4935   
;;;4936   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;4937   	{
;;;4938   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
000026  1c60              ADDS     r0,r4,#1
000028  d107              BNE      |L3.58|
00002a  b137              CBZ      r7,|L3.58|
;;;4939   		{
;;;4940   			/* Add the task to the suspended task list instead of a delayed task
;;;4941   			list to ensure it is not woken by a timing event.  It will block
;;;4942   			indefinitely. */
;;;4943   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
00002c  6831              LDR      r1,[r6,#0]  ; pxCurrentTCB
00002e  e8bd41f0          POP      {r4-r8,lr}
000032  480e              LDR      r0,|L3.108|
000034  1d09              ADDS     r1,r1,#4
000036  f7ffbffe          B.W      vListInsertEnd
                  |L3.58|
;;;4944   		}
;;;4945   		else
;;;4946   		{
;;;4947   			/* Calculate the time at which the task should be woken if the event
;;;4948   			does not occur.  This may overflow but this doesn't matter, the
;;;4949   			kernel will manage it correctly. */
;;;4950   			xTimeToWake = xConstTickCount + xTicksToWait;
;;;4951   
;;;4952   			/* The list item will be inserted in wake time order. */
;;;4953   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
00003a  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
00003c  442c              ADD      r4,r4,r5              ;4950
;;;4954   
;;;4955   			if( xTimeToWake < xConstTickCount )
00003e  42ac              CMP      r4,r5
000040  6044              STR      r4,[r0,#4]
;;;4956   			{
;;;4957   				/* Wake time has overflowed.  Place this item in the overflow
;;;4958   				list. */
;;;4959   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4960   			}
;;;4961   			else
;;;4962   			{
;;;4963   				/* The wake time has not overflowed, so the current block list
;;;4964   				is used. */
;;;4965   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
000042  6831              LDR      r1,[r6,#0]  ; pxCurrentTCB
000044  d205              BCS      |L3.82|
000046  6bb0              LDR      r0,[r6,#0x38]         ;4959  ; pxOverflowDelayedTaskList
000048  e8bd41f0          POP      {r4-r8,lr}            ;4959
00004c  1d09              ADDS     r1,r1,#4              ;4959
00004e  f7ffbffe          B.W      vListInsert
                  |L3.82|
000052  6b70              LDR      r0,[r6,#0x34]  ; pxDelayedTaskList
000054  1d09              ADDS     r1,r1,#4
000056  f7fffffe          BL       vListInsert
;;;4966   
;;;4967   				/* If the task entering the blocked state was placed at the
;;;4968   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;4969   				needs to be updated too. */
;;;4970   				if( xTimeToWake < xNextTaskUnblockTime )
00005a  6ab0              LDR      r0,[r6,#0x28]  ; xNextTaskUnblockTime
00005c  4284              CMP      r4,r0
00005e  d200              BCS      |L3.98|
;;;4971   				{
;;;4972   					xNextTaskUnblockTime = xTimeToWake;
000060  62b4              STR      r4,[r6,#0x28]  ; xNextTaskUnblockTime
                  |L3.98|
;;;4973   				}
;;;4974   				else
;;;4975   				{
;;;4976   					mtCOVERAGE_TEST_MARKER();
;;;4977   				}
;;;4978   			}
;;;4979   		}
;;;4980   	}
;;;4981   	#else /* INCLUDE_vTaskSuspend */
;;;4982   	{
;;;4983   		/* Calculate the time at which the task should be woken if the event
;;;4984   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;4985   		will manage it correctly. */
;;;4986   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;4987   
;;;4988   		/* The list item will be inserted in wake time order. */
;;;4989   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;4990   
;;;4991   		if( xTimeToWake < xConstTickCount )
;;;4992   		{
;;;4993   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;4994   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4995   		}
;;;4996   		else
;;;4997   		{
;;;4998   			/* The wake time has not overflowed, so the current block list is used. */
;;;4999   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5000   
;;;5001   			/* If the task entering the blocked state was placed at the head of the
;;;5002   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;5003   			too. */
;;;5004   			if( xTimeToWake < xNextTaskUnblockTime )
;;;5005   			{
;;;5006   				xNextTaskUnblockTime = xTimeToWake;
;;;5007   			}
;;;5008   			else
;;;5009   			{
;;;5010   				mtCOVERAGE_TEST_MARKER();
;;;5011   			}
;;;5012   		}
;;;5013   
;;;5014   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;5015   		( void ) xCanBlockIndefinitely;
;;;5016   	}
;;;5017   	#endif /* INCLUDE_vTaskSuspend */
;;;5018   }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;5019   
                          ENDP

000066  0000              DCW      0x0000
                  |L3.104|
                          DCD      ||.data||
                  |L3.108|
                          DCD      ||.bss||+0xb4

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;1026   
;;;1027   static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1028   {
000004  4605              MOV      r5,r0
;;;1029   	/* Ensure interrupts don't access the task lists while the lists are being
;;;1030   	updated. */
;;;1031   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1032   	{
;;;1033   		uxCurrentNumberOfTasks++;
00000a  4e2e              LDR      r6,|L4.196|
00000c  68b0              LDR      r0,[r6,#8]  ; uxCurrentNumberOfTasks
00000e  1c40              ADDS     r0,r0,#1
000010  60b0              STR      r0,[r6,#8]  ; uxCurrentNumberOfTasks
;;;1034   		if( pxCurrentTCB == NULL )
000012  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
000014  4f2c              LDR      r7,|L4.200|
000016  b110              CBZ      r0,|L4.30|
;;;1035   		{
;;;1036   			/* There are no other tasks, or all the other tasks are in
;;;1037   			the suspended state - make this the current task. */
;;;1038   			pxCurrentTCB = pxNewTCB;
;;;1039   
;;;1040   			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
;;;1041   			{
;;;1042   				/* This is the first task to be created so do the preliminary
;;;1043   				initialisation required.  We will not recover if this call
;;;1044   				fails, but we will report the failure. */
;;;1045   				prvInitialiseTaskLists();
;;;1046   			}
;;;1047   			else
;;;1048   			{
;;;1049   				mtCOVERAGE_TEST_MARKER();
;;;1050   			}
;;;1051   		}
;;;1052   		else
;;;1053   		{
;;;1054   			/* If the scheduler is not already running, make this task the
;;;1055   			current task if it is the highest priority task to be created
;;;1056   			so far. */
;;;1057   			if( xSchedulerRunning == pdFALSE )
000018  6970              LDR      r0,[r6,#0x14]  ; xSchedulerRunning
00001a  b340              CBZ      r0,|L4.110|
00001c  e02d              B        |L4.122|
                  |L4.30|
00001e  6035              STR      r5,[r6,#0]            ;1038  ; pxCurrentTCB
000020  68b0              LDR      r0,[r6,#8]            ;1040  ; uxCurrentNumberOfTasks
000022  2801              CMP      r0,#1                 ;1040
000024  d129              BNE      |L4.122|
000026  2400              MOVS     r4,#0                 ;1040
                  |L4.40|
000028  eb040084          ADD      r0,r4,r4,LSL #2       ;1040
00002c  eb070080          ADD      r0,r7,r0,LSL #2       ;1040
000030  f7fffffe          BL       vListInitialise
000034  1c64              ADDS     r4,r4,#1              ;1040
000036  2c05              CMP      r4,#5                 ;1040
000038  d3f6              BCC      |L4.40|
00003a  4823              LDR      r0,|L4.200|
00003c  3064              ADDS     r0,r0,#0x64           ;1040
00003e  f7fffffe          BL       vListInitialise
000042  4821              LDR      r0,|L4.200|
000044  3078              ADDS     r0,r0,#0x78           ;1040
000046  f7fffffe          BL       vListInitialise
00004a  481f              LDR      r0,|L4.200|
00004c  308c              ADDS     r0,r0,#0x8c           ;1040
00004e  f7fffffe          BL       vListInitialise
000052  481d              LDR      r0,|L4.200|
000054  30a0              ADDS     r0,r0,#0xa0           ;1040
000056  f7fffffe          BL       vListInitialise
00005a  481b              LDR      r0,|L4.200|
00005c  30b4              ADDS     r0,r0,#0xb4           ;1040
00005e  f7fffffe          BL       vListInitialise
000062  4819              LDR      r0,|L4.200|
000064  3064              ADDS     r0,r0,#0x64           ;1040
000066  6370              STR      r0,[r6,#0x34]         ;1040  ; pxDelayedTaskList
000068  3014              ADDS     r0,r0,#0x14           ;1040
00006a  63b0              STR      r0,[r6,#0x38]         ;1040  ; pxOverflowDelayedTaskList
00006c  e005              B        |L4.122|
                  |L4.110|
;;;1058   			{
;;;1059   				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
00006e  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
000070  6ae9              LDR      r1,[r5,#0x2c]
000072  6ac0              LDR      r0,[r0,#0x2c]
000074  4288              CMP      r0,r1
000076  d800              BHI      |L4.122|
;;;1060   				{
;;;1061   					pxCurrentTCB = pxNewTCB;
000078  6035              STR      r5,[r6,#0]  ; pxCurrentTCB
                  |L4.122|
;;;1062   				}
;;;1063   				else
;;;1064   				{
;;;1065   					mtCOVERAGE_TEST_MARKER();
;;;1066   				}
;;;1067   			}
;;;1068   			else
;;;1069   			{
;;;1070   				mtCOVERAGE_TEST_MARKER();
;;;1071   			}
;;;1072   		}
;;;1073   
;;;1074   		uxTaskNumber++;
00007a  6a70              LDR      r0,[r6,#0x24]  ; uxTaskNumber
;;;1075   
;;;1076   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1077   		{
;;;1078   			/* Add a counter into the TCB for tracing only. */
;;;1079   			pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;1080   		}
;;;1081   		#endif /* configUSE_TRACE_FACILITY */
;;;1082   		traceTASK_CREATE( pxNewTCB );
;;;1083   
;;;1084   		prvAddTaskToReadyList( pxNewTCB );
00007c  2101              MOVS     r1,#1
00007e  1c40              ADDS     r0,r0,#1              ;1074
000080  6270              STR      r0,[r6,#0x24]         ;1079  ; uxTaskNumber
000082  6468              STR      r0,[r5,#0x44]
000084  6ae8              LDR      r0,[r5,#0x2c]
000086  6932              LDR      r2,[r6,#0x10]  ; uxTopReadyPriority
000088  4081              LSLS     r1,r1,r0
00008a  4311              ORRS     r1,r1,r2
00008c  6131              STR      r1,[r6,#0x10]  ; uxTopReadyPriority
00008e  eb000080          ADD      r0,r0,r0,LSL #2
000092  eb070080          ADD      r0,r7,r0,LSL #2
000096  1d29              ADDS     r1,r5,#4
000098  f7fffffe          BL       vListInsertEnd
;;;1085   
;;;1086   		portSETUP_TCB( pxNewTCB );
;;;1087   	}
;;;1088   	taskEXIT_CRITICAL();
00009c  f7fffffe          BL       vPortExitCritical
;;;1089   
;;;1090   	if( xSchedulerRunning != pdFALSE )
0000a0  6970              LDR      r0,[r6,#0x14]  ; xSchedulerRunning
0000a2  2800              CMP      r0,#0
0000a4  d00c              BEQ      |L4.192|
;;;1091   	{
;;;1092   		/* If the created task is of a higher priority than the current task
;;;1093   		then it should run now. */
;;;1094   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
0000a6  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
0000a8  6ae9              LDR      r1,[r5,#0x2c]
0000aa  6ac0              LDR      r0,[r0,#0x2c]
0000ac  4288              CMP      r0,r1
0000ae  d207              BCS      |L4.192|
;;;1095   		{
;;;1096   			taskYIELD_IF_USING_PREEMPTION();
0000b0  4906              LDR      r1,|L4.204|
0000b2  f04f5080          MOV      r0,#0x10000000
0000b6  6008              STR      r0,[r1,#0]
0000b8  f3bf8f4f          DSB      
0000bc  f3bf8f6f          ISB      
                  |L4.192|
;;;1097   		}
;;;1098   		else
;;;1099   		{
;;;1100   			mtCOVERAGE_TEST_MARKER();
;;;1101   		}
;;;1102   	}
;;;1103   	else
;;;1104   	{
;;;1105   		mtCOVERAGE_TEST_MARKER();
;;;1106   	}
;;;1107   }
0000c0  e8bd81f0          POP      {r4-r8,pc}
;;;1108   /*-----------------------------------------------------------*/
                          ENDP

                  |L4.196|
                          DCD      ||.data||
                  |L4.200|
                          DCD      ||.bss||
                  |L4.204|
                          DCD      0xe000ed04

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3675   
;;;3676   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3677   	{
000002  4604              MOV      r4,r0
;;;3678   		/* This call is required specifically for the TriCore port.  It must be
;;;3679   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3680   		want to allocate and clean RAM statically. */
;;;3681   		portCLEAN_UP_TCB( pxTCB );
;;;3682   
;;;3683   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3684   		to the task to free any memory allocated at the application level. */
;;;3685   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3686   		{
;;;3687   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3688   		}
;;;3689   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3690   
;;;3691   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3692   		{
;;;3693   			/* The task can only have been allocated dynamically - free both
;;;3694   			the stack and TCB. */
;;;3695   			vPortFree( pxTCB->pxStack );
000004  6b00              LDR      r0,[r0,#0x30]
000006  f7fffffe          BL       vPortFree
;;;3696   			vPortFree( pxTCB );
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      vPortFree
;;;3697   		}
;;;3698   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
;;;3699   		{
;;;3700   			/* The task could have been allocated statically or dynamically, so
;;;3701   			check what was statically allocated before trying to free the
;;;3702   			memory. */
;;;3703   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
;;;3704   			{
;;;3705   				/* Both the stack and TCB were allocated dynamically, so both
;;;3706   				must be freed. */
;;;3707   				vPortFree( pxTCB->pxStack );
;;;3708   				vPortFree( pxTCB );
;;;3709   			}
;;;3710   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
;;;3711   			{
;;;3712   				/* Only the stack was statically allocated, so the TCB is the
;;;3713   				only memory that must be freed. */
;;;3714   				vPortFree( pxTCB );
;;;3715   			}
;;;3716   			else
;;;3717   			{
;;;3718   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3719   				nothing needs to be freed. */
;;;3720   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
;;;3721   				mtCOVERAGE_TEST_MARKER();
;;;3722   			}
;;;3723   		}
;;;3724   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3725   	}
;;;3726   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;3223    */
;;;3224   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  4e14              LDR      r6,|L6.84|
000002  4d15              LDR      r5,|L6.88|
;;;3225   {
;;;3226   	/* Stop warnings. */
;;;3227   	( void ) pvParameters;
;;;3228   
;;;3229   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3230   	SCHEDULER IS STARTED. **/
;;;3231   
;;;3232   	/* In case a task that has a secure context deletes itself, in which case
;;;3233   	the idle task is responsible for deleting the task's secure context, if
;;;3234   	any. */
;;;3235   	portTASK_CALLS_SECURE_FUNCTIONS();
;;;3236   
;;;3237   	for( ;; )
;;;3238   	{
;;;3239   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3240   		is responsible for freeing the deleted task's TCB and stack. */
;;;3241   		prvCheckTasksWaitingTermination();
;;;3242   
;;;3243   		#if ( configUSE_PREEMPTION == 0 )
;;;3244   		{
;;;3245   			/* If we are not using preemption we keep forcing a task switch to
;;;3246   			see if any other task has become available.  If we are using
;;;3247   			preemption we don't need to do this as any task becoming available
;;;3248   			will automatically get the processor anyway. */
;;;3249   			taskYIELD();
;;;3250   		}
;;;3251   		#endif /* configUSE_PREEMPTION */
;;;3252   
;;;3253   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3254   		{
;;;3255   			/* When using preemption tasks of equal priority will be
;;;3256   			timesliced.  If a task that is sharing the idle priority is ready
;;;3257   			to run then the idle task should yield before the end of the
;;;3258   			timeslice.
;;;3259   
;;;3260   			A critical region is not required here as we are just reading from
;;;3261   			the list, and an occasional incorrect value will not matter.  If
;;;3262   			the ready list at the idle priority contains more than one task
;;;3263   			then a task other than the idle task is ready to execute. */
;;;3264   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000004  f1a607a0          SUB      r7,r6,#0xa0
;;;3265   			{
;;;3266   				taskYIELD();
000008  f04f5880          MOV      r8,#0x10000000
00000c  f8df904c          LDR      r9,|L6.92|
000010  e011              B        |L6.54|
                  |L6.18|
000012  f7fffffe          BL       vPortEnterCritical
000016  68f0              LDR      r0,[r6,#0xc]  ; xTasksWaitingTermination
000018  68c4              LDR      r4,[r0,#0xc]
00001a  1d20              ADDS     r0,r4,#4
00001c  f7fffffe          BL       uxListRemove
000020  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
000022  1e40              SUBS     r0,r0,#1
000024  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
000026  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
000028  1e40              SUBS     r0,r0,#1
00002a  6068              STR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
00002c  f7fffffe          BL       vPortExitCritical
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       prvDeleteTCB
                  |L6.54|
000036  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
000038  2800              CMP      r0,#0
00003a  d1ea              BNE      |L6.18|
00003c  6838              LDR      r0,[r7,#0]            ;3264  ; pxReadyTasksLists
00003e  2801              CMP      r0,#1                 ;3264
000040  d905              BLS      |L6.78|
000042  f8c98000          STR      r8,[r9,#0]
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
                  |L6.78|
;;;3267   			}
;;;3268   			else
;;;3269   			{
;;;3270   				mtCOVERAGE_TEST_MARKER();
;;;3271   			}
;;;3272   		}
;;;3273   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3274   
;;;3275   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3276   		{
;;;3277   			extern void vApplicationIdleHook( void );
;;;3278   
;;;3279   			/* Call the user defined function from within the idle task.  This
;;;3280   			allows the application designer to add background functionality
;;;3281   			without the overhead of a separate task.
;;;3282   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3283   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3284   			vApplicationIdleHook();
00004e  f7fffffe          BL       vApplicationIdleHook
000052  e7f0              B        |L6.54|
;;;3285   		}
;;;3286   		#endif /* configUSE_IDLE_HOOK */
;;;3287   
;;;3288   		/* This conditional compilation should use inequality to 0, not equality
;;;3289   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3290   		user defined low power mode	implementations require
;;;3291   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3292   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3293   		{
;;;3294   		TickType_t xExpectedIdleTime;
;;;3295   
;;;3296   			/* It is not desirable to suspend then resume the scheduler on
;;;3297   			each iteration of the idle task.  Therefore, a preliminary
;;;3298   			test of the expected idle time is performed without the
;;;3299   			scheduler suspended.  The result here is not necessarily
;;;3300   			valid. */
;;;3301   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3302   
;;;3303   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3304   			{
;;;3305   				vTaskSuspendAll();
;;;3306   				{
;;;3307   					/* Now the scheduler is suspended, the expected idle
;;;3308   					time can be sampled again, and this time its value can
;;;3309   					be used. */
;;;3310   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3311   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3312   
;;;3313   					/* Define the following macro to set xExpectedIdleTime to 0
;;;3314   					if the application does not want
;;;3315   					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
;;;3316   					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
;;;3317   
;;;3318   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3319   					{
;;;3320   						traceLOW_POWER_IDLE_BEGIN();
;;;3321   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3322   						traceLOW_POWER_IDLE_END();
;;;3323   					}
;;;3324   					else
;;;3325   					{
;;;3326   						mtCOVERAGE_TEST_MARKER();
;;;3327   					}
;;;3328   				}
;;;3329   				( void ) xTaskResumeAll();
;;;3330   			}
;;;3331   			else
;;;3332   			{
;;;3333   				mtCOVERAGE_TEST_MARKER();
;;;3334   			}
;;;3335   		}
;;;3336   		#endif /* configUSE_TICKLESS_IDLE */
;;;3337   	}
;;;3338   }
;;;3339   /*-----------------------------------------------------------*/
                          ENDP

                  |L6.84|
                          DCD      ||.bss||+0xa0
                  |L6.88|
                          DCD      ||.data||
                  |L6.92|
                          DCD      0xe000ed04

                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTask PROC
;;;822    
;;;823    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;824    									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;825    									const uint32_t ulStackDepth,
;;;826    									void * const pvParameters,
;;;827    									UBaseType_t uxPriority,
;;;828    									TaskHandle_t * const pxCreatedTask,
;;;829    									TCB_t *pxNewTCB,
;;;830    									const MemoryRegion_t * const xRegions )
;;;831    {
000004  460e              MOV      r6,r1
000006  e9dd8409          LDRD     r8,r4,[sp,#0x24]
00000a  4617              MOV      r7,r2
00000c  4682              MOV      r10,r0
;;;832    StackType_t *pxTopOfStack;
;;;833    UBaseType_t x;
;;;834    
;;;835    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;836    		/* Should the task be created in privileged mode? */
;;;837    		BaseType_t xRunPrivileged;
;;;838    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;839    		{
;;;840    			xRunPrivileged = pdTRUE;
;;;841    		}
;;;842    		else
;;;843    		{
;;;844    			xRunPrivileged = pdFALSE;
;;;845    		}
;;;846    		uxPriority &= ~portPRIVILEGE_BIT;
;;;847    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;848    
;;;849    	/* Avoid dependency on memset() if it is not required. */
;;;850    	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
;;;851    	{
;;;852    		/* Fill the stack with a known value to assist debugging. */
;;;853    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
00000e  0091              LSLS     r1,r2,#2
000010  4699              MOV      r9,r3                 ;831
000012  9d08              LDR      r5,[sp,#0x20]
000014  22a5              MOVS     r2,#0xa5
000016  6b20              LDR      r0,[r4,#0x30]
000018  f7fffffe          BL       __aeabi_memset
;;;854    	}
;;;855    	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
;;;856    
;;;857    	/* Calculate the top of stack address.  This depends on whether the stack
;;;858    	grows from high memory to low (as per the 80x86) or vice versa.
;;;859    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;860    	by the port. */
;;;861    	#if( portSTACK_GROWTH < 0 )
;;;862    	{
;;;863    		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
00001c  f06f0103          MVN      r1,#3
000020  6b20              LDR      r0,[r4,#0x30]
000022  eb010187          ADD      r1,r1,r7,LSL #2
000026  4408              ADD      r0,r0,r1
;;;864    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
000028  f0200707          BIC      r7,r0,#7
;;;865    
;;;866    		/* Check the alignment of the calculated top of stack is correct. */
;;;867    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
00002c  0778              LSLS     r0,r7,#29
00002e  d007              BEQ      |L7.64|
000030  2050              MOVS     r0,#0x50
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
                  |L7.62|
00003e  e7fe              B        |L7.62|
                  |L7.64|
;;;868    
;;;869    		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
;;;870    		{
;;;871    			/* Also record the stack's high address, which may assist
;;;872    			debugging. */
;;;873    			pxNewTCB->pxEndOfStack = pxTopOfStack;
;;;874    		}
;;;875    		#endif /* configRECORD_STACK_HIGH_ADDRESS */
;;;876    	}
;;;877    	#else /* portSTACK_GROWTH */
;;;878    	{
;;;879    		pxTopOfStack = pxNewTCB->pxStack;
;;;880    
;;;881    		/* Check the alignment of the stack buffer is correct. */
;;;882    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;883    
;;;884    		/* The other extreme of the stack space is required if stack checking is
;;;885    		performed. */
;;;886    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;887    	}
;;;888    	#endif /* portSTACK_GROWTH */
;;;889    
;;;890    	/* Store the task name in the TCB. */
;;;891    	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
;;;892    	{
;;;893    		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
000040  1822              ADDS     r2,r4,r0
000042  5c31              LDRB     r1,[r6,r0]
000044  f8821034          STRB     r1,[r2,#0x34]
;;;894    
;;;895    		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;896    		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;897    		string is not accessible (extremely unlikely). */
;;;898    		if( pcName[ x ] == 0x00 )
000048  5c31              LDRB     r1,[r6,r0]
00004a  b111              CBZ      r1,|L7.82|
00004c  1c40              ADDS     r0,r0,#1
00004e  2810              CMP      r0,#0x10              ;891
000050  d3f6              BCC      |L7.64|
                  |L7.82|
;;;899    		{
;;;900    			break;
;;;901    		}
;;;902    		else
;;;903    		{
;;;904    			mtCOVERAGE_TEST_MARKER();
;;;905    		}
;;;906    	}
;;;907    
;;;908    	/* Ensure the name string is terminated in the case that the string length
;;;909    	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;910    	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
000052  2600              MOVS     r6,#0
000054  f8846043          STRB     r6,[r4,#0x43]
;;;911    
;;;912    	/* This is used as an array index so must ensure it's not too large.  First
;;;913    	remove the privilege bit if one is present. */
;;;914    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000058  2d05              CMP      r5,#5
00005a  d300              BCC      |L7.94|
;;;915    	{
;;;916    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
00005c  2504              MOVS     r5,#4
                  |L7.94|
;;;917    	}
;;;918    	else
;;;919    	{
;;;920    		mtCOVERAGE_TEST_MARKER();
;;;921    	}
;;;922    
;;;923    	pxNewTCB->uxPriority = uxPriority;
;;;924    	#if ( configUSE_MUTEXES == 1 )
;;;925    	{
;;;926    		pxNewTCB->uxBasePriority = uxPriority;
;;;927    		pxNewTCB->uxMutexesHeld = 0;
;;;928    	}
;;;929    	#endif /* configUSE_MUTEXES */
;;;930    
;;;931    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
00005e  62e5              STR      r5,[r4,#0x2c]
000060  e9c45613          STRD     r5,r6,[r4,#0x4c]
000064  1d20              ADDS     r0,r4,#4
000066  f7fffffe          BL       vListInitialiseItem
;;;932    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
00006a  f1040018          ADD      r0,r4,#0x18
00006e  f7fffffe          BL       vListInitialiseItem
;;;933    
;;;934    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;935    	back to	the containing TCB from a generic item in a list. */
;;;936    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
000072  6124              STR      r4,[r4,#0x10]
;;;937    
;;;938    	/* Event lists are always in priority order. */
;;;939    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000074  f1c50005          RSB      r0,r5,#5
;;;940    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000078  6264              STR      r4,[r4,#0x24]
00007a  61a0              STR      r0,[r4,#0x18]
;;;941    
;;;942    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;943    	{
;;;944    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;945    	}
;;;946    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;947    
;;;948    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;949    	{
;;;950    		pxNewTCB->pxTaskTag = NULL;
;;;951    	}
;;;952    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;953    
;;;954    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;955    	{
;;;956    		pxNewTCB->ulRunTimeCounter = 0UL;
;;;957    	}
;;;958    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;959    
;;;960    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;961    	{
;;;962    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;963    	}
;;;964    	#else
;;;965    	{
;;;966    		/* Avoid compiler warning about unreferenced parameter. */
;;;967    		( void ) xRegions;
;;;968    	}
;;;969    	#endif
;;;970    
;;;971    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;972    	{
;;;973    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;974    		{
;;;975    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;976    		}
;;;977    	}
;;;978    	#endif
;;;979    
;;;980    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;981    	{
;;;982    		pxNewTCB->ulNotifiedValue = 0;
00007c  6566              STR      r6,[r4,#0x54]
;;;983    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00007e  f8846058          STRB     r6,[r4,#0x58]
;;;984    	}
;;;985    	#endif
;;;986    
;;;987    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;988    	{
;;;989    		/* Initialise this task's Newlib reent structure. */
;;;990    		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;991    	}
;;;992    	#endif
;;;993    
;;;994    	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;995    	{
;;;996    		pxNewTCB->ucDelayAborted = pdFALSE;
;;;997    	}
;;;998    	#endif
;;;999    
;;;1000   	/* Initialize the TCB stack to look as if the task was already running,
;;;1001   	but had been interrupted by the scheduler.  The return address is set
;;;1002   	to the start of the task function. Once the stack has been initialised
;;;1003   	the top of stack variable is updated. */
;;;1004   	#if( portUSING_MPU_WRAPPERS == 1 )
;;;1005   	{
;;;1006   		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1007   	}
;;;1008   	#else /* portUSING_MPU_WRAPPERS */
;;;1009   	{
;;;1010   		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000082  464a              MOV      r2,r9
000084  4651              MOV      r1,r10
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       pxPortInitialiseStack
;;;1011   	}
;;;1012   	#endif /* portUSING_MPU_WRAPPERS */
;;;1013   
;;;1014   	if( ( void * ) pxCreatedTask != NULL )
00008c  6020              STR      r0,[r4,#0]
00008e  f1b80f00          CMP      r8,#0
000092  d001              BEQ      |L7.152|
;;;1015   	{
;;;1016   		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;1017   		change the created task's priority, delete the created task, etc.*/
;;;1018   		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
000094  f8c84000          STR      r4,[r8,#0]
                  |L7.152|
;;;1019   	}
;;;1020   	else
;;;1021   	{
;;;1022   		mtCOVERAGE_TEST_MARKER();
;;;1023   	}
;;;1024   }
000098  e8bd87f0          POP      {r4-r10,pc}
;;;1025   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvListTasksWithinSingleList||, CODE, READONLY, ALIGN=1

                  prvListTasksWithinSingleList PROC
;;;3594   
;;;3595   	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3596   	{
000004  4681              MOV      r9,r0
;;;3597   	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
;;;3598   	UBaseType_t uxTask = 0;
;;;3599   
;;;3600   		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
000006  6808              LDR      r0,[r1,#0]
000008  4692              MOV      r10,r2                ;3596
00000a  460c              MOV      r4,r1                 ;3596
00000c  2500              MOVS     r5,#0                 ;3598
00000e  b1f8              CBZ      r0,|L8.80|
;;;3601   		{
;;;3602   			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
000010  6848              LDR      r0,[r1,#4]
000012  f1010608          ADD      r6,r1,#8
000016  6840              LDR      r0,[r0,#4]
000018  6048              STR      r0,[r1,#4]
00001a  42b0              CMP      r0,r6
00001c  d101              BNE      |L8.34|
00001e  6840              LDR      r0,[r0,#4]
000020  6048              STR      r0,[r1,#4]
                  |L8.34|
000022  f8d0800c          LDR      r8,[r0,#0xc]
                  |L8.38|
;;;3603   
;;;3604   			/* Populate an TaskStatus_t structure within the
;;;3605   			pxTaskStatusArray array for each task that is referenced from
;;;3606   			pxList.  See the definition of TaskStatus_t in task.h for the
;;;3607   			meaning of each TaskStatus_t structure member. */
;;;3608   			do
;;;3609   			{
;;;3610   				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
000026  6860              LDR      r0,[r4,#4]
000028  6842              LDR      r2,[r0,#4]
00002a  6062              STR      r2,[r4,#4]
00002c  42b2              CMP      r2,r6
00002e  d101              BNE      |L8.52|
000030  6851              LDR      r1,[r2,#4]
000032  6061              STR      r1,[r4,#4]
                  |L8.52|
000034  6860              LDR      r0,[r4,#4]
;;;3611   				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
000036  eb0501c5          ADD      r1,r5,r5,LSL #3
00003a  eb090181          ADD      r1,r9,r1,LSL #2
00003e  68c7              LDR      r7,[r0,#0xc]
000040  4653              MOV      r3,r10
000042  2201              MOVS     r2,#1
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       vTaskGetInfo
00004a  1c6d              ADDS     r5,r5,#1
;;;3612   				uxTask++;
;;;3613   			} while( pxNextTCB != pxFirstTCB );
00004c  4547              CMP      r7,r8
00004e  d1ea              BNE      |L8.38|
                  |L8.80|
;;;3614   		}
;;;3615   		else
;;;3616   		{
;;;3617   			mtCOVERAGE_TEST_MARKER();
;;;3618   		}
;;;3619   
;;;3620   		return uxTask;
000050  4628              MOV      r0,r5
;;;3621   	}
000052  e8bd87f0          POP      {r4-r10,pc}
;;;3622   
                          ENDP


                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3729   
;;;3730   static void prvResetNextTaskUnblockTime( void )
000000  4806              LDR      r0,|L9.28|
;;;3731   {
;;;3732   TCB_t *pxTCB;
;;;3733   
;;;3734   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6b41              LDR      r1,[r0,#0x34]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  b129              CBZ      r1,|L9.20|
;;;3735   	{
;;;3736   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3737   		the maximum possible value so it is	extremely unlikely that the
;;;3738   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3739   		there is an item in the delayed list. */
;;;3740   		xNextTaskUnblockTime = portMAX_DELAY;
;;;3741   	}
;;;3742   	else
;;;3743   	{
;;;3744   		/* The new current delayed list is not empty, get the value of
;;;3745   		the item at the head of the delayed list.  This is the time at
;;;3746   		which the task at the head of the delayed list should be removed
;;;3747   		from the Blocked state. */
;;;3748   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
000008  6b41              LDR      r1,[r0,#0x34]  ; pxDelayedTaskList
00000a  68c9              LDR      r1,[r1,#0xc]
00000c  68c9              LDR      r1,[r1,#0xc]
;;;3749   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
00000e  6849              LDR      r1,[r1,#4]
                  |L9.16|
000010  6281              STR      r1,[r0,#0x28]         ;3740  ; xNextTaskUnblockTime
;;;3750   	}
;;;3751   }
000012  4770              BX       lr
                  |L9.20|
000014  f04f31ff          MOV      r1,#0xffffffff        ;3740
000018  e7fa              B        |L9.16|
;;;3752   /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      ||.data||

                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1730   
;;;1731   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  2100              MOVS     r1,#0
;;;1732   	{
000002  b150              CBZ      r0,|L10.26|
;;;1733   	BaseType_t xReturn = pdFALSE;
;;;1734   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
;;;1735   
;;;1736   		/* Accesses xPendingReadyList so must be called from a critical
;;;1737   		section. */
;;;1738   
;;;1739   		/* It does not make sense to check if the calling task is suspended. */
;;;1740   		configASSERT( xTask );
;;;1741   
;;;1742   		/* Is the task being resumed actually in the suspended list? */
;;;1743   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000004  4b0a              LDR      r3,|L10.48|
000006  6942              LDR      r2,[r0,#0x14]
000008  429a              CMP      r2,r3
00000a  d10f              BNE      |L10.44|
;;;1744   		{
;;;1745   			/* Has the task already been resumed from within an ISR? */
;;;1746   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
00000c  6a80              LDR      r0,[r0,#0x28]
00000e  f1a30228          SUB      r2,r3,#0x28
000012  4290              CMP      r0,r2
000014  d00a              BEQ      |L10.44|
;;;1747   			{
;;;1748   				/* Is it in the suspended list because it is in the	Suspended
;;;1749   				state, or because is is blocked with no timeout? */
;;;1750   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
000016  b140              CBZ      r0,|L10.42|
000018  e008              B        |L10.44|
                  |L10.26|
00001a  2050              MOVS     r0,#0x50
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
                  |L10.40|
000028  e7fe              B        |L10.40|
                  |L10.42|
;;;1751   				{
;;;1752   					xReturn = pdTRUE;
00002a  2101              MOVS     r1,#1
                  |L10.44|
;;;1753   				}
;;;1754   				else
;;;1755   				{
;;;1756   					mtCOVERAGE_TEST_MARKER();
;;;1757   				}
;;;1758   			}
;;;1759   			else
;;;1760   			{
;;;1761   				mtCOVERAGE_TEST_MARKER();
;;;1762   			}
;;;1763   		}
;;;1764   		else
;;;1765   		{
;;;1766   			mtCOVERAGE_TEST_MARKER();
;;;1767   		}
;;;1768   
;;;1769   		return xReturn;
00002c  4608              MOV      r0,r1
;;;1770   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00002e  4770              BX       lr
;;;1771   
                          ENDP

                  |L10.48|
                          DCD      ||.bss||+0xb4

                          AREA ||i.pvTaskIncrementMutexHeldCount||, CODE, READONLY, ALIGN=2

                  pvTaskIncrementMutexHeldCount PROC
;;;4394   
;;;4395   	void *pvTaskIncrementMutexHeldCount( void )
000000  4904              LDR      r1,|L11.20|
;;;4396   	{
;;;4397   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;4398   		then pxCurrentTCB will be NULL. */
;;;4399   		if( pxCurrentTCB != NULL )
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000004  b118              CBZ      r0,|L11.14|
;;;4400   		{
;;;4401   			( pxCurrentTCB->uxMutexesHeld )++;
000006  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000008  6d02              LDR      r2,[r0,#0x50]
00000a  1c52              ADDS     r2,r2,#1
00000c  6502              STR      r2,[r0,#0x50]
                  |L11.14|
;;;4402   		}
;;;4403   
;;;4404   		return pxCurrentTCB;
00000e  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;4405   	}
000010  4770              BX       lr
;;;4406   
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      ||.data||

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4411   
;;;4412   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;4413   	{
000002  460c              MOV      r4,r1
000004  4606              MOV      r6,r0
;;;4414   	uint32_t ulReturn;
;;;4415   
;;;4416   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4417   		{
;;;4418   			/* Only block if the notification count is not already non-zero. */
;;;4419   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000a  4d15              LDR      r5,|L12.96|
00000c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00000e  6d40              LDR      r0,[r0,#0x54]
000010  b980              CBNZ     r0,|L12.52|
;;;4420   			{
;;;4421   				/* Mark this task as waiting for a notification. */
;;;4422   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000012  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000014  2001              MOVS     r0,#1
000016  f8810058          STRB     r0,[r1,#0x58]
;;;4423   
;;;4424   				if( xTicksToWait > ( TickType_t ) 0 )
00001a  b15c              CBZ      r4,|L12.52|
;;;4425   				{
;;;4426   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4427   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4428   
;;;4429   					/* All ports are written to allow a yield in a critical
;;;4430   					section (some will yield immediately, others wait until the
;;;4431   					critical section exits) - but it is not something that
;;;4432   					application code should ever do. */
;;;4433   					portYIELD_WITHIN_API();
000024  490f              LDR      r1,|L12.100|
000026  f04f5080          MOV      r0,#0x10000000
00002a  6008              STR      r0,[r1,#0]
00002c  f3bf8f4f          DSB      
000030  f3bf8f6f          ISB      
                  |L12.52|
;;;4434   				}
;;;4435   				else
;;;4436   				{
;;;4437   					mtCOVERAGE_TEST_MARKER();
;;;4438   				}
;;;4439   			}
;;;4440   			else
;;;4441   			{
;;;4442   				mtCOVERAGE_TEST_MARKER();
;;;4443   			}
;;;4444   		}
;;;4445   		taskEXIT_CRITICAL();
000034  f7fffffe          BL       vPortExitCritical
;;;4446   
;;;4447   		taskENTER_CRITICAL();
000038  f7fffffe          BL       vPortEnterCritical
;;;4448   		{
;;;4449   			traceTASK_NOTIFY_TAKE();
;;;4450   			ulReturn = pxCurrentTCB->ulNotifiedValue;
00003c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00003e  6d44              LDR      r4,[r0,#0x54]
000040  2000              MOVS     r0,#0
;;;4451   
;;;4452   			if( ulReturn != 0UL )
000042  b134              CBZ      r4,|L12.82|
;;;4453   			{
;;;4454   				if( xClearCountOnExit != pdFALSE )
000044  b116              CBZ      r6,|L12.76|
;;;4455   				{
;;;4456   					pxCurrentTCB->ulNotifiedValue = 0UL;
000046  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000048  6548              STR      r0,[r1,#0x54]
00004a  e002              B        |L12.82|
                  |L12.76|
;;;4457   				}
;;;4458   				else
;;;4459   				{
;;;4460   					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
00004c  682a              LDR      r2,[r5,#0]  ; pxCurrentTCB
00004e  1e61              SUBS     r1,r4,#1
000050  6551              STR      r1,[r2,#0x54]
                  |L12.82|
;;;4461   				}
;;;4462   			}
;;;4463   			else
;;;4464   			{
;;;4465   				mtCOVERAGE_TEST_MARKER();
;;;4466   			}
;;;4467   
;;;4468   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000052  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000054  f8810058          STRB     r0,[r1,#0x58]
;;;4469   		}
;;;4470   		taskEXIT_CRITICAL();
000058  f7fffffe          BL       vPortExitCritical
;;;4471   
;;;4472   		return ulReturn;
00005c  4620              MOV      r0,r4
;;;4473   	}
00005e  bd70              POP      {r4-r6,pc}
;;;4474   
                          ENDP

                  |L12.96|
                          DCD      ||.data||
                  |L12.100|
                          DCD      0xe000ed04

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2260   
;;;2261   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L13.8|
;;;2262   {
;;;2263   	/* A critical section is not required because the variables are of type
;;;2264   	BaseType_t. */
;;;2265   	return uxCurrentNumberOfTasks;
000002  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
;;;2266   }
000004  4770              BX       lr
;;;2267   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.data||

                          AREA ||i.uxTaskGetSystemState||, CODE, READONLY, ALIGN=2

                  uxTaskGetSystemState PROC
;;;2408   
;;;2409   	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2410   	{
000004  4617              MOV      r7,r2
000006  460a              MOV      r2,r1
000008  4606              MOV      r6,r0
;;;2411   	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
00000a  2400              MOVS     r4,#0
00000c  2505              MOVS     r5,#5
;;;2412   
;;;2413   		vTaskSuspendAll();
00000e  f7fffffe          BL       vTaskSuspendAll
;;;2414   		{
;;;2415   			/* Is there a space in the array for each task in the system? */
;;;2416   			if( uxArraySize >= uxCurrentNumberOfTasks )
000012  f8df808c          LDR      r8,|L14.160|
000016  f8d80008          LDR      r0,[r8,#8]  ; uxCurrentNumberOfTasks
00001a  4282              CMP      r2,r0
00001c  d33b              BCC      |L14.150|
;;;2417   			{
;;;2418   				/* Fill in an TaskStatus_t structure with information on each
;;;2419   				task in the Ready state. */
;;;2420   				do
;;;2421   				{
;;;2422   					uxQueue--;
;;;2423   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
00001e  f8df9084          LDR      r9,|L14.164|
                  |L14.34|
000022  1e6d              SUBS     r5,r5,#1
000024  eb050185          ADD      r1,r5,r5,LSL #2
000028  eb0400c4          ADD      r0,r4,r4,LSL #3
00002c  eb090181          ADD      r1,r9,r1,LSL #2
000030  eb060080          ADD      r0,r6,r0,LSL #2
000034  2201              MOVS     r2,#1
000036  f7fffffe          BL       prvListTasksWithinSingleList
00003a  4404              ADD      r4,r4,r0
;;;2424   
;;;2425   				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00003c  2d00              CMP      r5,#0
00003e  d1f0              BNE      |L14.34|
;;;2426   
;;;2427   				/* Fill in an TaskStatus_t structure with information on each
;;;2428   				task in the Blocked state. */
;;;2429   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
000040  eb0400c4          ADD      r0,r4,r4,LSL #3
000044  eb060080          ADD      r0,r6,r0,LSL #2
000048  2202              MOVS     r2,#2
00004a  4645              MOV      r5,r8
00004c  f8d81034          LDR      r1,[r8,#0x34]  ; pxDelayedTaskList
000050  f7fffffe          BL       prvListTasksWithinSingleList
000054  4404              ADD      r4,r4,r0
;;;2430   				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
000056  eb0400c4          ADD      r0,r4,r4,LSL #3
00005a  eb060080          ADD      r0,r6,r0,LSL #2
00005e  2202              MOVS     r2,#2
000060  6ba9              LDR      r1,[r5,#0x38]  ; pxOverflowDelayedTaskList
000062  f7fffffe          BL       prvListTasksWithinSingleList
000066  4404              ADD      r4,r4,r0
;;;2431   
;;;2432   				#if( INCLUDE_vTaskDelete == 1 )
;;;2433   				{
;;;2434   					/* Fill in an TaskStatus_t structure with information on
;;;2435   					each task that has been deleted but not yet cleaned up. */
;;;2436   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
000068  490e              LDR      r1,|L14.164|
00006a  eb0400c4          ADD      r0,r4,r4,LSL #3
00006e  eb060080          ADD      r0,r6,r0,LSL #2
000072  2204              MOVS     r2,#4
000074  31a0              ADDS     r1,r1,#0xa0
000076  f7fffffe          BL       prvListTasksWithinSingleList
00007a  4404              ADD      r4,r4,r0
;;;2437   				}
;;;2438   				#endif
;;;2439   
;;;2440   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;2441   				{
;;;2442   					/* Fill in an TaskStatus_t structure with information on
;;;2443   					each task in the Suspended state. */
;;;2444   					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
00007c  4909              LDR      r1,|L14.164|
00007e  eb0400c4          ADD      r0,r4,r4,LSL #3
000082  eb060080          ADD      r0,r6,r0,LSL #2
000086  2203              MOVS     r2,#3
000088  31b4              ADDS     r1,r1,#0xb4
00008a  f7fffffe          BL       prvListTasksWithinSingleList
00008e  4404              ADD      r4,r4,r0
;;;2445   				}
;;;2446   				#endif
;;;2447   
;;;2448   				#if ( configGENERATE_RUN_TIME_STATS == 1)
;;;2449   				{
;;;2450   					if( pulTotalRunTime != NULL )
;;;2451   					{
;;;2452   						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2453   							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
;;;2454   						#else
;;;2455   							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2456   						#endif
;;;2457   					}
;;;2458   				}
;;;2459   				#else
;;;2460   				{
;;;2461   					if( pulTotalRunTime != NULL )
000090  b10f              CBZ      r7,|L14.150|
;;;2462   					{
;;;2463   						*pulTotalRunTime = 0;
000092  2000              MOVS     r0,#0
000094  6038              STR      r0,[r7,#0]
                  |L14.150|
;;;2464   					}
;;;2465   				}
;;;2466   				#endif
;;;2467   			}
;;;2468   			else
;;;2469   			{
;;;2470   				mtCOVERAGE_TEST_MARKER();
;;;2471   			}
;;;2472   		}
;;;2473   		( void ) xTaskResumeAll();
000096  f7fffffe          BL       xTaskResumeAll
;;;2474   
;;;2475   		return uxTask;
00009a  4620              MOV      r0,r4
;;;2476   	}
00009c  e8bd87f0          POP      {r4-r10,pc}
;;;2477   
                          ENDP

                  |L14.160|
                          DCD      ||.data||
                  |L14.164|
                          DCD      ||.bss||

                          AREA ||i.uxTaskGetTaskNumber||, CODE, READONLY, ALIGN=1

                  uxTaskGetTaskNumber PROC
;;;3176   
;;;3177   	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
000000  2800              CMP      r0,#0
;;;3178   	{
000002  d000              BEQ      |L15.6|
;;;3179   	UBaseType_t uxReturn;
;;;3180   	TCB_t *pxTCB;
;;;3181   
;;;3182   		if( xTask != NULL )
;;;3183   		{
;;;3184   			pxTCB = ( TCB_t * ) xTask;
;;;3185   			uxReturn = pxTCB->uxTaskNumber;
000004  6c80              LDR      r0,[r0,#0x48]
                  |L15.6|
;;;3186   		}
;;;3187   		else
;;;3188   		{
;;;3189   			uxReturn = 0U;
;;;3190   		}
;;;3191   
;;;3192   		return uxReturn;
;;;3193   	}
000006  4770              BX       lr
;;;3194   
                          ENDP


                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1403   
;;;1404   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1405   	{
000002  4604              MOV      r4,r0
;;;1406   	TCB_t *pxTCB;
;;;1407   	UBaseType_t uxReturn;
;;;1408   
;;;1409   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1410   		{
;;;1411   			/* If null is passed in here then it is the priority of the that
;;;1412   			called uxTaskPriorityGet() that is being queried. */
;;;1413   			pxTCB = prvGetTCBFromHandle( xTask );
000008  b90c              CBNZ     r4,|L16.14|
00000a  4803              LDR      r0,|L16.24|
00000c  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L16.14|
;;;1414   			uxReturn = pxTCB->uxPriority;
00000e  6ae4              LDR      r4,[r4,#0x2c]
;;;1415   		}
;;;1416   		taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;1417   
;;;1418   		return uxReturn;
000014  4620              MOV      r0,r4
;;;1419   	}
000016  bd10              POP      {r4,pc}
;;;1420   
                          ENDP

                  |L16.24|
                          DCD      ||.data||

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1425   
;;;1426   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1427   	{
000002  4604              MOV      r4,r0
;;;1428   	TCB_t *pxTCB;
;;;1429   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1430   
;;;1431   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1432   		maximum	system call (or maximum API call) interrupt priority.
;;;1433   		Interrupts that are	above the maximum system call priority are keep
;;;1434   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1435   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1436   		is defined in FreeRTOSConfig.h then
;;;1437   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1438   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1439   		been assigned a priority above the configured maximum system call
;;;1440   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1441   		from interrupts	that have been assigned a priority at or (logically)
;;;1442   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1443   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1444   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1445   		provided on the following link:
;;;1446   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1447   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000004  f7fffffe          BL       vPortValidateInterruptPriority
000008  2050              MOVS     r0,#0x50
00000a  f3ef8111          MRS      r1,BASEPRI
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
;;;1448   
;;;1449   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1450   		{
;;;1451   			/* If null is passed in here then it is the priority of the calling
;;;1452   			task that is being queried. */
;;;1453   			pxTCB = prvGetTCBFromHandle( xTask );
00001a  b90c              CBNZ     r4,|L17.32|
00001c  4802              LDR      r0,|L17.40|
00001e  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L17.32|
000020  6ae0              LDR      r0,[r4,#0x2c]
000022  f3818811          MSR      BASEPRI,r1
;;;1454   			uxReturn = pxTCB->uxPriority;
;;;1455   		}
;;;1456   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
;;;1457   
;;;1458   		return uxReturn;
;;;1459   	}
000026  bd10              POP      {r4,pc}
;;;1460   
                          ENDP

                  |L17.40|
                          DCD      ||.data||

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4378   
;;;4379   TickType_t uxTaskResetEventItemValue( void )
000000  4904              LDR      r1,|L18.20|
;;;4380   {
;;;4381   TickType_t uxReturn;
;;;4382   
;;;4383   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;4384   
;;;4385   	/* Reset the event list item to its normal value - so it can be used with
;;;4386   	queues and semaphores. */
;;;4387   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000004  680a              LDR      r2,[r1,#0]  ; pxCurrentTCB
000006  6980              LDR      r0,[r0,#0x18]         ;4383
000008  6ad2              LDR      r2,[r2,#0x2c]
00000a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000c  f1c20205          RSB      r2,r2,#5
000010  618a              STR      r2,[r1,#0x18]
;;;4388   
;;;4389   	return uxReturn;
;;;4390   }
000012  4770              BX       lr
;;;4391   /*-----------------------------------------------------------*/
                          ENDP

                  |L18.20|
                          DCD      ||.data||

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;1287   
;;;1288   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b510              PUSH     {r4,lr}
;;;1289   	{
000002  0002              MOVS     r2,r0
000004  d014              BEQ      |L19.48|
;;;1290   	BaseType_t xAlreadyYielded = pdFALSE;
;;;1291   
;;;1292   		/* A delay time of zero just forces a reschedule. */
;;;1293   		if( xTicksToDelay > ( TickType_t ) 0U )
;;;1294   		{
;;;1295   			configASSERT( uxSchedulerSuspended == 0 );
000006  480f              LDR      r0,|L19.68|
000008  6b00              LDR      r0,[r0,#0x30]  ; uxSchedulerSuspended
00000a  b138              CBZ      r0,|L19.28|
00000c  2050              MOVS     r0,#0x50
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
                  |L19.26|
00001a  e7fe              B        |L19.26|
                  |L19.28|
;;;1296   			vTaskSuspendAll();
00001c  f7fffffe          BL       vTaskSuspendAll
;;;1297   			{
;;;1298   				traceTASK_DELAY();
;;;1299   
;;;1300   				/* A task that is removed from the event list while the
;;;1301   				scheduler is suspended will not get placed in the ready
;;;1302   				list or removed from the blocked list until the scheduler
;;;1303   				is resumed.
;;;1304   
;;;1305   				This task cannot be in an event list as it is the currently
;;;1306   				executing task. */
;;;1307   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
000020  2100              MOVS     r1,#0
000022  4610              MOV      r0,r2
000024  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1308   			}
;;;1309   			xAlreadyYielded = xTaskResumeAll();
000028  f7fffffe          BL       xTaskResumeAll
00002c  2800              CMP      r0,#0
00002e  d107              BNE      |L19.64|
                  |L19.48|
;;;1310   		}
;;;1311   		else
;;;1312   		{
;;;1313   			mtCOVERAGE_TEST_MARKER();
;;;1314   		}
;;;1315   
;;;1316   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1317   		have put ourselves to sleep. */
;;;1318   		if( xAlreadyYielded == pdFALSE )
;;;1319   		{
;;;1320   			portYIELD_WITHIN_API();
000030  4905              LDR      r1,|L19.72|
000032  f04f5080          MOV      r0,#0x10000000
000036  6008              STR      r0,[r1,#0]
000038  f3bf8f4f          DSB      
00003c  f3bf8f6f          ISB      
                  |L19.64|
;;;1321   		}
;;;1322   		else
;;;1323   		{
;;;1324   			mtCOVERAGE_TEST_MARKER();
;;;1325   		}
;;;1326   	}
000040  bd10              POP      {r4,pc}
;;;1327   
                          ENDP

000042  0000              DCW      0x0000
                  |L19.68|
                          DCD      ||.data||
                  |L19.72|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;1203   
;;;1204   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  b570              PUSH     {r4-r6,lr}
;;;1205   	{
000002  460e              MOV      r6,r1
000004  0005              MOVS     r5,r0
;;;1206   	TickType_t xTimeToWake;
;;;1207   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000006  f04f0300          MOV      r3,#0
00000a  d00b              BEQ      |L20.36|
;;;1208   
;;;1209   		configASSERT( pxPreviousWakeTime );
;;;1210   		configASSERT( ( xTimeIncrement > 0U ) );
00000c  b196              CBZ      r6,|L20.52|
;;;1211   		configASSERT( uxSchedulerSuspended == 0 );
00000e  4a1e              LDR      r2,|L20.136|
000010  6b10              LDR      r0,[r2,#0x30]  ; uxSchedulerSuspended
000012  b1b8              CBZ      r0,|L20.68|
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
                  |L20.34|
000022  e7fe              B        |L20.34|
                  |L20.36|
000024  2050              MOVS     r0,#0x50
000026  f3808811          MSR      BASEPRI,r0
00002a  f3bf8f4f          DSB      
00002e  f3bf8f6f          ISB      
                  |L20.50|
000032  e7fe              B        |L20.50|
                  |L20.52|
000034  2050              MOVS     r0,#0x50              ;1209
000036  f3808811          MSR      BASEPRI,r0            ;1209
00003a  f3bf8f4f          DSB                            ;1209
00003e  f3bf8f6f          ISB                            ;1209
                  |L20.66|
000042  e7fe              B        |L20.66|
                  |L20.68|
;;;1212   
;;;1213   		vTaskSuspendAll();
000044  f7fffffe          BL       vTaskSuspendAll
;;;1214   		{
;;;1215   			/* Minor optimisation.  The tick count cannot change in this
;;;1216   			block. */
;;;1217   			const TickType_t xConstTickCount = xTickCount;
000048  68d2              LDR      r2,[r2,#0xc]  ; xTickCount
;;;1218   
;;;1219   			/* Generate the tick time at which the task wants to wake. */
;;;1220   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
00004a  682c              LDR      r4,[r5,#0]
00004c  19a1              ADDS     r1,r4,r6
;;;1221   
;;;1222   			if( xConstTickCount < *pxPreviousWakeTime )
00004e  4294              CMP      r4,r2
000050  d902              BLS      |L20.88|
;;;1223   			{
;;;1224   				/* The tick count has overflowed since this function was
;;;1225   				lasted called.  In this case the only time we should ever
;;;1226   				actually delay is if the wake time has also	overflowed,
;;;1227   				and the wake time is greater than the tick time.  When this
;;;1228   				is the case it is as if neither time had overflowed. */
;;;1229   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
000052  428c              CMP      r4,r1
000054  d802              BHI      |L20.92|
000056  e004              B        |L20.98|
                  |L20.88|
;;;1230   				{
;;;1231   					xShouldDelay = pdTRUE;
;;;1232   				}
;;;1233   				else
;;;1234   				{
;;;1235   					mtCOVERAGE_TEST_MARKER();
;;;1236   				}
;;;1237   			}
;;;1238   			else
;;;1239   			{
;;;1240   				/* The tick time has not overflowed.  In this case we will
;;;1241   				delay if either the wake time has overflowed, and/or the
;;;1242   				tick time is less than the wake time. */
;;;1243   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
000058  428c              CMP      r4,r1
00005a  d801              BHI      |L20.96|
                  |L20.92|
00005c  4291              CMP      r1,r2
00005e  d900              BLS      |L20.98|
                  |L20.96|
;;;1244   				{
;;;1245   					xShouldDelay = pdTRUE;
000060  2301              MOVS     r3,#1
                  |L20.98|
;;;1246   				}
;;;1247   				else
;;;1248   				{
;;;1249   					mtCOVERAGE_TEST_MARKER();
;;;1250   				}
;;;1251   			}
;;;1252   
;;;1253   			/* Update the wake time ready for the next call. */
;;;1254   			*pxPreviousWakeTime = xTimeToWake;
;;;1255   
;;;1256   			if( xShouldDelay != pdFALSE )
000062  6029              STR      r1,[r5,#0]
000064  b11b              CBZ      r3,|L20.110|
;;;1257   			{
;;;1258   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1259   
;;;1260   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1261   				the time to wake, so subtract the current tick count. */
;;;1262   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
000066  1a88              SUBS     r0,r1,r2
000068  2100              MOVS     r1,#0
00006a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L20.110|
;;;1263   			}
;;;1264   			else
;;;1265   			{
;;;1266   				mtCOVERAGE_TEST_MARKER();
;;;1267   			}
;;;1268   		}
;;;1269   		xAlreadyYielded = xTaskResumeAll();
00006e  f7fffffe          BL       xTaskResumeAll
;;;1270   
;;;1271   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1272   		have put ourselves to sleep. */
;;;1273   		if( xAlreadyYielded == pdFALSE )
000072  2800              CMP      r0,#0
000074  d107              BNE      |L20.134|
;;;1274   		{
;;;1275   			portYIELD_WITHIN_API();
000076  4905              LDR      r1,|L20.140|
000078  f04f5080          MOV      r0,#0x10000000
00007c  6008              STR      r0,[r1,#0]
00007e  f3bf8f4f          DSB      
000082  f3bf8f6f          ISB      
                  |L20.134|
;;;1276   		}
;;;1277   		else
;;;1278   		{
;;;1279   			mtCOVERAGE_TEST_MARKER();
;;;1280   		}
;;;1281   	}
000086  bd70              POP      {r4-r6,pc}
;;;1282   
                          ENDP

                  |L20.136|
                          DCD      ||.data||
                  |L20.140|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;1111   
;;;1112   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;1113   	{
000002  4604              MOV      r4,r0
;;;1114   	TCB_t *pxTCB;
;;;1115   
;;;1116   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1117   		{
;;;1118   			/* If null is passed in here then it is the calling task that is
;;;1119   			being deleted. */
;;;1120   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  4d25              LDR      r5,|L21.160|
00000a  b904              CBNZ     r4,|L21.14|
00000c  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L21.14|
;;;1121   
;;;1122   			/* Remove task from the ready list. */
;;;1123   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
000014  b958              CBNZ     r0,|L21.46|
;;;1124   			{
;;;1125   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000016  6ae0              LDR      r0,[r4,#0x2c]
000018  4a22              LDR      r2,|L21.164|
00001a  eb000180          ADD      r1,r0,r0,LSL #2
00001e  f8521021          LDR      r1,[r2,r1,LSL #2]
000022  b921              CBNZ     r1,|L21.46|
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
00002a  4388              BICS     r0,r0,r1
00002c  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L21.46|
;;;1126   			}
;;;1127   			else
;;;1128   			{
;;;1129   				mtCOVERAGE_TEST_MARKER();
;;;1130   			}
;;;1131   
;;;1132   			/* Is the task waiting on an event also? */
;;;1133   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00002e  6aa0              LDR      r0,[r4,#0x28]
000030  b118              CBZ      r0,|L21.58|
;;;1134   			{
;;;1135   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000032  f1040018          ADD      r0,r4,#0x18
000036  f7fffffe          BL       uxListRemove
                  |L21.58|
;;;1136   			}
;;;1137   			else
;;;1138   			{
;;;1139   				mtCOVERAGE_TEST_MARKER();
;;;1140   			}
;;;1141   
;;;1142   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1143   			detect that the task lists need re-generating.  This is done before
;;;1144   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1145   			not return. */
;;;1146   			uxTaskNumber++;
00003a  6a68              LDR      r0,[r5,#0x24]  ; uxTaskNumber
00003c  1c40              ADDS     r0,r0,#1
;;;1147   
;;;1148   			if( pxTCB == pxCurrentTCB )
00003e  6268              STR      r0,[r5,#0x24]  ; uxTaskNumber
000040  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000042  4284              CMP      r4,r0
000044  d108              BNE      |L21.88|
;;;1149   			{
;;;1150   				/* A task is deleting itself.  This cannot complete within the
;;;1151   				task itself, as a context switch to another task is required.
;;;1152   				Place the task in the termination list.  The idle task will
;;;1153   				check the termination list and free up any memory allocated by
;;;1154   				the scheduler for the TCB and stack of the deleted task. */
;;;1155   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
000046  4817              LDR      r0,|L21.164|
000048  1d21              ADDS     r1,r4,#4
00004a  30a0              ADDS     r0,r0,#0xa0
00004c  f7fffffe          BL       vListInsertEnd
;;;1156   
;;;1157   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1158   				there is a task that has been deleted and that it should therefore
;;;1159   				check the xTasksWaitingTermination list. */
;;;1160   				++uxDeletedTasksWaitingCleanUp;
000050  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
000052  1c40              ADDS     r0,r0,#1
000054  6068              STR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
000056  e007              B        |L21.104|
                  |L21.88|
;;;1161   
;;;1162   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1163   				in which Windows specific clean up operations are performed,
;;;1164   				after which it is not possible to yield away from this task -
;;;1165   				hence xYieldPending is used to latch that a context switch is
;;;1166   				required. */
;;;1167   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1168   			}
;;;1169   			else
;;;1170   			{
;;;1171   				--uxCurrentNumberOfTasks;
000058  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
00005a  1e40              SUBS     r0,r0,#1
00005c  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;1172   				prvDeleteTCB( pxTCB );
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       prvDeleteTCB
;;;1173   
;;;1174   				/* Reset the next expected unblock time in case it referred to
;;;1175   				the task that has just been deleted. */
;;;1176   				prvResetNextTaskUnblockTime();
000064  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L21.104|
;;;1177   			}
;;;1178   
;;;1179   			traceTASK_DELETE( pxTCB );
;;;1180   		}
;;;1181   		taskEXIT_CRITICAL();
000068  f7fffffe          BL       vPortExitCritical
;;;1182   
;;;1183   		/* Force a reschedule if it is the currently running task that has just
;;;1184   		been deleted. */
;;;1185   		if( xSchedulerRunning != pdFALSE )
00006c  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
00006e  2800              CMP      r0,#0
000070  d014              BEQ      |L21.156|
;;;1186   		{
;;;1187   			if( pxTCB == pxCurrentTCB )
000072  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000074  4284              CMP      r4,r0
000076  d111              BNE      |L21.156|
;;;1188   			{
;;;1189   				configASSERT( uxSchedulerSuspended == 0 );
000078  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00007a  b138              CBZ      r0,|L21.140|
00007c  2050              MOVS     r0,#0x50
00007e  f3808811          MSR      BASEPRI,r0
000082  f3bf8f4f          DSB      
000086  f3bf8f6f          ISB      
                  |L21.138|
00008a  e7fe              B        |L21.138|
                  |L21.140|
;;;1190   				portYIELD_WITHIN_API();
00008c  4906              LDR      r1,|L21.168|
00008e  f04f5080          MOV      r0,#0x10000000
000092  6008              STR      r0,[r1,#0]
000094  f3bf8f4f          DSB      
000098  f3bf8f6f          ISB      
                  |L21.156|
;;;1191   			}
;;;1192   			else
;;;1193   			{
;;;1194   				mtCOVERAGE_TEST_MARKER();
;;;1195   			}
;;;1196   		}
;;;1197   	}
00009c  bd70              POP      {r4-r6,pc}
;;;1198   
                          ENDP

00009e  0000              DCW      0x0000
                  |L21.160|
                          DCD      ||.data||
                  |L21.164|
                          DCD      ||.bss||
                  |L21.168|
                          DCD      0xe000ed04

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;2020   
;;;2021   void vTaskEndScheduler( void )
000000  2050              MOVS     r0,#0x50
000002  f3808811          MSR      BASEPRI,r0
000006  f3bf8f4f          DSB      
00000a  f3bf8f6f          ISB      
;;;2022   {
;;;2023   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;2024   	routine so the original ISRs can be restored if necessary.  The port
;;;2025   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;2026   	portDISABLE_INTERRUPTS();
;;;2027   	xSchedulerRunning = pdFALSE;
00000e  4902              LDR      r1,|L22.24|
000010  2000              MOVS     r0,#0
000012  6148              STR      r0,[r1,#0x14]  ; xSchedulerRunning
;;;2028   	vPortEndScheduler();
000014  f7ffbffe          B.W      vPortEndScheduler
;;;2029   }
;;;2030   /*----------------------------------------------------------*/
                          ENDP

                  |L22.24|
                          DCD      ||.data||

                          AREA ||i.vTaskGetInfo||, CODE, READONLY, ALIGN=2

                  vTaskGetInfo PROC
;;;3498   
;;;3499   	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3500   	{
000004  460c              MOV      r4,r1
;;;3501   	TCB_t *pxTCB;
;;;3502   
;;;3503   		/* xTask is NULL then get the state of the calling task. */
;;;3504   		pxTCB = prvGetTCBFromHandle( xTask );
000006  491d              LDR      r1,|L23.124|
000008  4617              MOV      r7,r2                 ;3500
00000a  b1a8              CBZ      r0,|L23.56|
00000c  4605              MOV      r5,r0
                  |L23.14|
;;;3505   
;;;3506   		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
;;;3507   		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
00000e  f1050034          ADD      r0,r5,#0x34
000012  e9c45000          STRD     r5,r0,[r4,#0]
;;;3508   		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
000016  6ae8              LDR      r0,[r5,#0x2c]
;;;3509   		pxTaskStatus->pxStackBase = pxTCB->pxStack;
000018  6120              STR      r0,[r4,#0x10]
00001a  6b28              LDR      r0,[r5,#0x30]
;;;3510   		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
00001c  61e0              STR      r0,[r4,#0x1c]
00001e  6c68              LDR      r0,[r5,#0x44]
;;;3511   
;;;3512   		#if ( configUSE_MUTEXES == 1 )
;;;3513   		{
;;;3514   			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
000020  60a0              STR      r0,[r4,#8]
;;;3515   		}
;;;3516   		#else
;;;3517   		{
;;;3518   			pxTaskStatus->uxBasePriority = 0;
;;;3519   		}
;;;3520   		#endif
;;;3521   
;;;3522   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;3523   		{
;;;3524   			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
;;;3525   		}
;;;3526   		#else
;;;3527   		{
;;;3528   			pxTaskStatus->ulRunTimeCounter = 0;
000022  2600              MOVS     r6,#0
;;;3529   		}
;;;3530   		#endif
;;;3531   
;;;3532   		/* Obtaining the task state is a little fiddly, so is only done if the
;;;3533   		value of eState passed into this function is eInvalid - otherwise the
;;;3534   		state is just set to whatever is passed in. */
;;;3535   		if( eState != eInvalid )
000024  6ce8              LDR      r0,[r5,#0x4c]
000026  e9c40605          STRD     r0,r6,[r4,#0x14]
00002a  2b05              CMP      r3,#5
00002c  d012              BEQ      |L23.84|
;;;3536   		{
;;;3537   			if( pxTCB == pxCurrentTCB )
00002e  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000030  4285              CMP      r5,r0
000032  d103              BNE      |L23.60|
;;;3538   			{
;;;3539   				pxTaskStatus->eCurrentState = eRunning;
000034  7326              STRB     r6,[r4,#0xc]
000036  e011              B        |L23.92|
                  |L23.56|
000038  680d              LDR      r5,[r1,#0]            ;3504  ; pxCurrentTCB
00003a  e7e8              B        |L23.14|
                  |L23.60|
;;;3540   			}
;;;3541   			else
;;;3542   			{
;;;3543   				pxTaskStatus->eCurrentState = eState;
00003c  7323              STRB     r3,[r4,#0xc]
;;;3544   
;;;3545   				#if ( INCLUDE_vTaskSuspend == 1 )
;;;3546   				{
;;;3547   					/* If the task is in the suspended list then there is a
;;;3548   					chance it is actually just blocked indefinitely - so really
;;;3549   					it should be reported as being in the Blocked state. */
;;;3550   					if( eState == eSuspended )
00003e  2b03              CMP      r3,#3
000040  d10c              BNE      |L23.92|
;;;3551   					{
;;;3552   						vTaskSuspendAll();
000042  f7fffffe          BL       vTaskSuspendAll
;;;3553   						{
;;;3554   							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000046  6aa8              LDR      r0,[r5,#0x28]
000048  b108              CBZ      r0,|L23.78|
;;;3555   							{
;;;3556   								pxTaskStatus->eCurrentState = eBlocked;
00004a  2002              MOVS     r0,#2
00004c  7320              STRB     r0,[r4,#0xc]
                  |L23.78|
;;;3557   							}
;;;3558   						}
;;;3559   						( void ) xTaskResumeAll();
00004e  f7fffffe          BL       xTaskResumeAll
000052  e003              B        |L23.92|
                  |L23.84|
;;;3560   					}
;;;3561   				}
;;;3562   				#endif /* INCLUDE_vTaskSuspend */
;;;3563   			}
;;;3564   		}
;;;3565   		else
;;;3566   		{
;;;3567   			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       eTaskGetState
00005a  7320              STRB     r0,[r4,#0xc]
                  |L23.92|
;;;3568   		}
;;;3569   
;;;3570   		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
;;;3571   		parameter is provided to allow it to be skipped. */
;;;3572   		if( xGetFreeStackSpace != pdFALSE )
00005c  b15f              CBZ      r7,|L23.118|
00005e  2100              MOVS     r1,#0
;;;3573   		{
;;;3574   			#if ( portSTACK_GROWTH > 0 )
;;;3575   			{
;;;3576   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
;;;3577   			}
;;;3578   			#else
;;;3579   			{
;;;3580   				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
000060  6b28              LDR      r0,[r5,#0x30]
000062  e001              B        |L23.104|
                  |L23.100|
000064  1c40              ADDS     r0,r0,#1
000066  1c49              ADDS     r1,r1,#1
                  |L23.104|
000068  7802              LDRB     r2,[r0,#0]
00006a  2aa5              CMP      r2,#0xa5
00006c  d0fa              BEQ      |L23.100|
00006e  0888              LSRS     r0,r1,#2
000070  8420              STRH     r0,[r4,#0x20]
                  |L23.114|
;;;3581   			}
;;;3582   			#endif
;;;3583   		}
;;;3584   		else
;;;3585   		{
;;;3586   			pxTaskStatus->usStackHighWaterMark = 0;
;;;3587   		}
;;;3588   	}
000072  e8bd81f0          POP      {r4-r8,pc}
                  |L23.118|
000076  8426              STRH     r6,[r4,#0x20]         ;3586
000078  e7fb              B        |L23.114|
;;;3589   
                          ENDP

00007a  0000              DCW      0x0000
                  |L23.124|
                          DCD      ||.data||

                          AREA ||i.vTaskInternalSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskInternalSetTimeOutState PROC
;;;3097   
;;;3098   void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  4902              LDR      r1,|L24.12|
;;;3099   {
;;;3100   	/* For internal use only as it does not use a critical section. */
;;;3101   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000002  6a0a              LDR      r2,[r1,#0x20]  ; xNumOfOverflows
;;;3102   	pxTimeOut->xTimeOnEntering = xTickCount;
000004  6002              STR      r2,[r0,#0]
000006  68c9              LDR      r1,[r1,#0xc]  ; xTickCount
000008  6041              STR      r1,[r0,#4]
;;;3103   }
00000a  4770              BX       lr
;;;3104   /*-----------------------------------------------------------*/
                          ENDP

                  |L24.12|
                          DCD      ||.data||

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3168   
;;;3169   void vTaskMissedYield( void )
000000  4901              LDR      r1,|L25.8|
;;;3170   {
;;;3171   	xYieldPending = pdTRUE;
000002  2001              MOVS     r0,#1
000004  61c8              STR      r0,[r1,#0x1c]  ; xYieldPending
;;;3172   }
000006  4770              BX       lr
;;;3173   /*-----------------------------------------------------------*/
                          ENDP

                  |L25.8|
                          DCD      ||.data||

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;4789   
;;;4790   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4791   	{
000004  4688              MOV      r8,r1
000006  0004              MOVS     r4,r0
000008  d015              BEQ      |L26.54|
;;;4792   	TCB_t * pxTCB;
;;;4793   	uint8_t ucOriginalNotifyState;
;;;4794   	UBaseType_t uxSavedInterruptStatus;
;;;4795   
;;;4796   		configASSERT( xTaskToNotify );
;;;4797   
;;;4798   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4799   		maximum	system call (or maximum API call) interrupt priority.
;;;4800   		Interrupts that are	above the maximum system call priority are keep
;;;4801   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4802   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4803   		is defined in FreeRTOSConfig.h then
;;;4804   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4805   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4806   		been assigned a priority above the configured maximum system call
;;;4807   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4808   		from interrupts	that have been assigned a priority at or (logically)
;;;4809   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4810   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4811   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4812   		provided on the following link:
;;;4813   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4814   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00000a  f7fffffe          BL       vPortValidateInterruptPriority
00000e  2050              MOVS     r0,#0x50
000010  f3ef8711          MRS      r7,BASEPRI
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
;;;4815   
;;;4816   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4817   
;;;4818   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;4819   		{
;;;4820   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000020  f8940058          LDRB     r0,[r4,#0x58]
;;;4821   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000024  2102              MOVS     r1,#2
000026  f8841058          STRB     r1,[r4,#0x58]
;;;4822   
;;;4823   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4824   			semaphore. */
;;;4825   			( pxTCB->ulNotifiedValue )++;
00002a  6d61              LDR      r1,[r4,#0x54]
00002c  1c49              ADDS     r1,r1,#1
00002e  6561              STR      r1,[r4,#0x54]
;;;4826   
;;;4827   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4828   
;;;4829   			/* If the task is in the blocked state specifically to wait for a
;;;4830   			notification then unblock it now. */
;;;4831   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000030  2801              CMP      r0,#1
000032  d008              BEQ      |L26.70|
000034  e037              B        |L26.166|
                  |L26.54|
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
                  |L26.68|
000044  e7fe              B        |L26.68|
                  |L26.70|
;;;4832   			{
;;;4833   				/* The task should not have been on an event list. */
;;;4834   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000046  6aa0              LDR      r0,[r4,#0x28]
000048  b138              CBZ      r0,|L26.90|
00004a  2050              MOVS     r0,#0x50
00004c  f3808811          MSR      BASEPRI,r0
000050  f3bf8f4f          DSB      
000054  f3bf8f6f          ISB      
                  |L26.88|
000058  e7fe              B        |L26.88|
                  |L26.90|
;;;4835   
;;;4836   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00005a  4d15              LDR      r5,|L26.176|
00005c  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00005e  2601              MOVS     r6,#1                 ;4793
000060  b178              CBZ      r0,|L26.130|
;;;4837   				{
;;;4838   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;4839   					prvAddTaskToReadyList( pxTCB );
;;;4840   				}
;;;4841   				else
;;;4842   				{
;;;4843   					/* The delayed and ready lists cannot be accessed, so hold
;;;4844   					this task pending until the scheduler is resumed. */
;;;4845   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000062  f1040118          ADD      r1,r4,#0x18
000066  4813              LDR      r0,|L26.180|
                  |L26.104|
000068  f7fffffe          BL       vListInsertEnd
;;;4846   				}
;;;4847   
;;;4848   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00006c  6ae0              LDR      r0,[r4,#0x2c]
00006e  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000070  6ac9              LDR      r1,[r1,#0x2c]
000072  4288              CMP      r0,r1
000074  d917              BLS      |L26.166|
;;;4849   				{
;;;4850   					/* The notified task has a priority above the currently
;;;4851   					executing task so a yield is required. */
;;;4852   					if( pxHigherPriorityTaskWoken != NULL )
000076  f1b80f00          CMP      r8,#0
00007a  d013              BEQ      |L26.164|
;;;4853   					{
;;;4854   						*pxHigherPriorityTaskWoken = pdTRUE;
00007c  f8c86000          STR      r6,[r8,#0]
000080  e011              B        |L26.166|
                  |L26.130|
000082  1d20              ADDS     r0,r4,#4              ;4838
000084  f7fffffe          BL       uxListRemove
000088  6ae0              LDR      r0,[r4,#0x2c]         ;4839
00008a  692a              LDR      r2,[r5,#0x10]         ;4839  ; uxTopReadyPriority
00008c  fa06f100          LSL      r1,r6,r0              ;4839
000090  4311              ORRS     r1,r1,r2              ;4839
000092  6129              STR      r1,[r5,#0x10]         ;4839  ; uxTopReadyPriority
000094  4907              LDR      r1,|L26.180|
000096  eb000080          ADD      r0,r0,r0,LSL #2       ;4839
00009a  398c              SUBS     r1,r1,#0x8c           ;4839
00009c  eb010080          ADD      r0,r1,r0,LSL #2       ;4839
0000a0  1d21              ADDS     r1,r4,#4              ;4839
0000a2  e7e1              B        |L26.104|
                  |L26.164|
;;;4855   					}
;;;4856   					else
;;;4857   					{
;;;4858   						/* Mark that a yield is pending in case the user is not
;;;4859   						using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;4860   						safe FreeRTOS function. */
;;;4861   						xYieldPending = pdTRUE;
0000a4  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L26.166|
0000a6  f3878811          MSR      BASEPRI,r7
;;;4862   					}
;;;4863   				}
;;;4864   				else
;;;4865   				{
;;;4866   					mtCOVERAGE_TEST_MARKER();
;;;4867   				}
;;;4868   			}
;;;4869   		}
;;;4870   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;4871   	}
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;4872   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L26.176|
                          DCD      ||.data||
                  |L26.180|
                          DCD      ||.bss||+0x8c

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;2909   
;;;2910   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b510              PUSH     {r4,lr}
;;;2911   {
000002  460c              MOV      r4,r1
000004  b150              CBZ      r0,|L27.28|
;;;2912   	configASSERT( pxEventList );
;;;2913   
;;;2914   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2915   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2916   
;;;2917   	/* Place the event list item of the TCB in the appropriate event list.
;;;2918   	This is placed in the list in priority order so the highest priority task
;;;2919   	is the first to be woken by the event.  The queue that contains the event
;;;2920   	list is locked, preventing simultaneous access from interrupts. */
;;;2921   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000006  4909              LDR      r1,|L27.44|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  3118              ADDS     r1,r1,#0x18
00000c  f7fffffe          BL       vListInsert
;;;2922   
;;;2923   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  2101              MOVS     r1,#1
000018  f7ffbffe          B.W      prvAddCurrentTaskToDelayedList
                  |L27.28|
00001c  2050              MOVS     r0,#0x50
00001e  f3808811          MSR      BASEPRI,r0
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
                  |L27.42|
00002a  e7fe              B        |L27.42|
;;;2924   }
;;;2925   /*-----------------------------------------------------------*/
                          ENDP

                  |L27.44|
                          DCD      ||.data||

                          AREA ||i.vTaskPlaceOnEventListRestricted||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventListRestricted PROC
;;;2952   
;;;2953   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;2954   	{
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  b168              CBZ      r0,|L28.36|
;;;2955   		configASSERT( pxEventList );
;;;2956   
;;;2957   		/* This function should not be called by application code hence the
;;;2958   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2959   		designed for use by kernel code, and has special calling requirements -
;;;2960   		it should be called with the scheduler suspended. */
;;;2961   
;;;2962   
;;;2963   		/* Place the event list item of the TCB in the appropriate event list.
;;;2964   		In this case it is assume that this is the only task that is going to
;;;2965   		be waiting on this event list, so the faster vListInsertEnd() function
;;;2966   		can be used in place of vListInsert. */
;;;2967   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000008  490a              LDR      r1,|L28.52|
00000a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000c  3118              ADDS     r1,r1,#0x18
00000e  f7fffffe          BL       vListInsertEnd
;;;2968   
;;;2969   		/* If the task should block indefinitely then set the block time to a
;;;2970   		value that will be recognised as an indefinite delay inside the
;;;2971   		prvAddCurrentTaskToDelayedList() function. */
;;;2972   		if( xWaitIndefinitely != pdFALSE )
000012  b10c              CBZ      r4,|L28.24|
;;;2973   		{
;;;2974   			xTicksToWait = portMAX_DELAY;
000014  f04f35ff          MOV      r5,#0xffffffff
                  |L28.24|
;;;2975   		}
;;;2976   
;;;2977   		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
;;;2978   		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
000018  4621              MOV      r1,r4
00001a  4628              MOV      r0,r5
00001c  e8bd4070          POP      {r4-r6,lr}
000020  f7ffbffe          B.W      prvAddCurrentTaskToDelayedList
                  |L28.36|
000024  2050              MOVS     r0,#0x50
000026  f3808811          MSR      BASEPRI,r0
00002a  f3bf8f4f          DSB      
00002e  f3bf8f6f          ISB      
                  |L28.50|
000032  e7fe              B        |L28.50|
;;;2979   	}
;;;2980   
                          ENDP

                  |L28.52|
                          DCD      ||.data||

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;2926   
;;;2927   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b510              PUSH     {r4,lr}
;;;2928   {
000002  4614              MOV      r4,r2
000004  b180              CBZ      r0,|L29.40|
;;;2929   	configASSERT( pxEventList );
;;;2930   
;;;2931   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2932   	the event groups implementation. */
;;;2933   	configASSERT( uxSchedulerSuspended != 0 );
000006  4b10              LDR      r3,|L29.72|
000008  6b1a              LDR      r2,[r3,#0x30]  ; uxSchedulerSuspended
00000a  b1aa              CBZ      r2,|L29.56|
;;;2934   
;;;2935   	/* Store the item value in the event list item.  It is safe to access the
;;;2936   	event list item here as interrupts won't access the event list item of a
;;;2937   	task that is not in the Blocked state. */
;;;2938   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
00000c  681a              LDR      r2,[r3,#0]  ; pxCurrentTCB
00000e  f0414100          ORR      r1,r1,#0x80000000
;;;2939   
;;;2940   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2941   	list.  It is safe to access the event list here because it is part of an
;;;2942   	event group implementation - and interrupts don't access event groups
;;;2943   	directly (instead they access them indirectly by pending function calls to
;;;2944   	the task level). */
;;;2945   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000012  6191              STR      r1,[r2,#0x18]
000014  6819              LDR      r1,[r3,#0]  ; pxCurrentTCB
000016  3118              ADDS     r1,r1,#0x18
000018  f7fffffe          BL       vListInsertEnd
;;;2946   
;;;2947   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001c  4620              MOV      r0,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2101              MOVS     r1,#1
000024  f7ffbffe          B.W      prvAddCurrentTaskToDelayedList
                  |L29.40|
000028  2050              MOVS     r0,#0x50
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L29.54|
000036  e7fe              B        |L29.54|
                  |L29.56|
000038  2050              MOVS     r0,#0x50              ;2929
00003a  f3808811          MSR      BASEPRI,r0            ;2929
00003e  f3bf8f4f          DSB                            ;2929
000042  f3bf8f6f          ISB                            ;2929
                  |L29.70|
000046  e7fe              B        |L29.70|
;;;2948   }
;;;2949   /*-----------------------------------------------------------*/
                          ENDP

                  |L29.72|
                          DCD      ||.data||

                          AREA ||i.vTaskPriorityDisinheritAfterTimeout||, CODE, READONLY, ALIGN=2

                  vTaskPriorityDisinheritAfterTimeout PROC
;;;3967   
;;;3968   	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
000000  b570              PUSH     {r4-r6,lr}
;;;3969   	{
000002  460b              MOV      r3,r1
;;;3970   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  0004              MOVS     r4,r0
000006  d04b              BEQ      |L30.160|
;;;3971   	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
;;;3972   	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
;;;3973   
;;;3974   		if( pxMutexHolder != NULL )
;;;3975   		{
;;;3976   			/* If pxMutexHolder is not NULL then the holder must hold at least
;;;3977   			one mutex. */
;;;3978   			configASSERT( pxTCB->uxMutexesHeld );
000008  6d22              LDR      r2,[r4,#0x50]
00000a  b1a2              CBZ      r2,|L30.54|
;;;3979   
;;;3980   			/* Determine the priority to which the priority of the task that
;;;3981   			holds the mutex should be set.  This will be the greater of the
;;;3982   			holding task's base priority and the priority of the highest
;;;3983   			priority task that is waiting to obtain the mutex. */
;;;3984   			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
00000c  6ce1              LDR      r1,[r4,#0x4c]
00000e  4299              CMP      r1,r3
000010  d200              BCS      |L30.20|
;;;3985   			{
;;;3986   				uxPriorityToUse = uxHighestPriorityWaitingTask;
000012  4619              MOV      r1,r3
                  |L30.20|
;;;3987   			}
;;;3988   			else
;;;3989   			{
;;;3990   				uxPriorityToUse = pxTCB->uxBasePriority;
;;;3991   			}
;;;3992   
;;;3993   			/* Does the priority need to change? */
;;;3994   			if( pxTCB->uxPriority != uxPriorityToUse )
000014  6ae0              LDR      r0,[r4,#0x2c]
000016  4288              CMP      r0,r1
000018  d042              BEQ      |L30.160|
;;;3995   			{
;;;3996   				/* Only disinherit if no other mutexes are held.  This is a
;;;3997   				simplification in the priority inheritance implementation.  If
;;;3998   				the task that holds the mutex is also holding other mutexes then
;;;3999   				the other mutexes may have caused the priority inheritance. */
;;;4000   				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
00001a  2a01              CMP      r2,#1
00001c  d140              BNE      |L30.160|
;;;4001   				{
;;;4002   					/* If a task has timed out because it already holds the
;;;4003   					mutex it was trying to obtain then it cannot of inherited
;;;4004   					its own priority. */
;;;4005   					configASSERT( pxTCB != pxCurrentTCB );
00001e  4d21              LDR      r5,|L30.164|
000020  682a              LDR      r2,[r5,#0]  ; pxCurrentTCB
000022  4294              CMP      r4,r2
000024  d10f              BNE      |L30.70|
000026  2050              MOVS     r0,#0x50
000028  f3808811          MSR      BASEPRI,r0
00002c  f3bf8f4f          DSB      
000030  f3bf8f6f          ISB      
                  |L30.52|
000034  e7fe              B        |L30.52|
                  |L30.54|
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
                  |L30.68|
000044  e7fe              B        |L30.68|
                  |L30.70|
;;;4006   
;;;4007   					/* Disinherit the priority, remembering the previous
;;;4008   					priority to facilitate determining the subject task's
;;;4009   					state. */
;;;4010   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;4011   					uxPriorityUsedOnEntry = pxTCB->uxPriority;
;;;4012   					pxTCB->uxPriority = uxPriorityToUse;
;;;4013   
;;;4014   					/* Only reset the event list item value if the value is not
;;;4015   					being used for anything else. */
;;;4016   					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000046  62e1              STR      r1,[r4,#0x2c]
000048  69a2              LDR      r2,[r4,#0x18]
00004a  2a00              CMP      r2,#0
00004c  db02              BLT      |L30.84|
;;;4017   					{
;;;4018   						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00004e  f1c10105          RSB      r1,r1,#5
000052  61a1              STR      r1,[r4,#0x18]
                  |L30.84|
;;;4019   					}
;;;4020   					else
;;;4021   					{
;;;4022   						mtCOVERAGE_TEST_MARKER();
;;;4023   					}
;;;4024   
;;;4025   					/* If the running task is not the task that holds the mutex
;;;4026   					then the task that holds the mutex could be in either the
;;;4027   					Ready, Blocked or Suspended states.  Only remove the task
;;;4028   					from its current state list if it is in the Ready state as
;;;4029   					the task's priority is going to change and there is one
;;;4030   					Ready list per priority. */
;;;4031   					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000054  4e14              LDR      r6,|L30.168|
000056  eb000080          ADD      r0,r0,r0,LSL #2
00005a  6961              LDR      r1,[r4,#0x14]
00005c  eb060080          ADD      r0,r6,r0,LSL #2
000060  4281              CMP      r1,r0
000062  d11d              BNE      |L30.160|
;;;4032   					{
;;;4033   						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000064  1d20              ADDS     r0,r4,#4
000066  f7fffffe          BL       uxListRemove
00006a  2101              MOVS     r1,#1                 ;3972
00006c  b950              CBNZ     r0,|L30.132|
;;;4034   						{
;;;4035   							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00006e  6ae0              LDR      r0,[r4,#0x2c]
000070  eb000280          ADD      r2,r0,r0,LSL #2
000074  f8562022          LDR      r2,[r6,r2,LSL #2]
000078  b922              CBNZ     r2,|L30.132|
00007a  fa01f200          LSL      r2,r1,r0
00007e  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
000080  4390              BICS     r0,r0,r2
000082  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L30.132|
;;;4036   						}
;;;4037   						else
;;;4038   						{
;;;4039   							mtCOVERAGE_TEST_MARKER();
;;;4040   						}
;;;4041   
;;;4042   						prvAddTaskToReadyList( pxTCB );
000084  6ae0              LDR      r0,[r4,#0x2c]
000086  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000088  4081              LSLS     r1,r1,r0
00008a  4311              ORRS     r1,r1,r2
00008c  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
00008e  eb000080          ADD      r0,r0,r0,LSL #2
000092  eb060080          ADD      r0,r6,r0,LSL #2
000096  1d21              ADDS     r1,r4,#4
000098  e8bd4070          POP      {r4-r6,lr}
00009c  f7ffbffe          B.W      vListInsertEnd
                  |L30.160|
;;;4043   					}
;;;4044   					else
;;;4045   					{
;;;4046   						mtCOVERAGE_TEST_MARKER();
;;;4047   					}
;;;4048   				}
;;;4049   				else
;;;4050   				{
;;;4051   					mtCOVERAGE_TEST_MARKER();
;;;4052   				}
;;;4053   			}
;;;4054   			else
;;;4055   			{
;;;4056   				mtCOVERAGE_TEST_MARKER();
;;;4057   			}
;;;4058   		}
;;;4059   		else
;;;4060   		{
;;;4061   			mtCOVERAGE_TEST_MARKER();
;;;4062   		}
;;;4063   	}
0000a0  bd70              POP      {r4-r6,pc}
;;;4064   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L30.164|
                          DCD      ||.data||
                  |L30.168|
                          DCD      ||.bss||

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1465   
;;;1466   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1467   	{
;;;1468   	TCB_t *pxTCB;
;;;1469   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1470   	BaseType_t xYieldRequired = pdFALSE;
000004  2600              MOVS     r6,#0
000006  460d              MOV      r5,r1                 ;1467
000008  4604              MOV      r4,r0                 ;1467
;;;1471   
;;;1472   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
00000a  2905              CMP      r1,#5
00000c  d307              BCC      |L31.30|
00000e  2050              MOVS     r0,#0x50              ;1467
000010  f3808811          MSR      BASEPRI,r0            ;1467
000014  f3bf8f4f          DSB                            ;1467
000018  f3bf8f6f          ISB                            ;1467
                  |L31.28|
00001c  e7fe              B        |L31.28|
                  |L31.30|
;;;1473   
;;;1474   		/* Ensure the new priority is valid. */
;;;1475   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
;;;1476   		{
;;;1477   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
;;;1478   		}
;;;1479   		else
;;;1480   		{
;;;1481   			mtCOVERAGE_TEST_MARKER();
;;;1482   		}
;;;1483   
;;;1484   		taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;1485   		{
;;;1486   			/* If null is passed in here then it is the priority of the calling
;;;1487   			task that is being changed. */
;;;1488   			pxTCB = prvGetTCBFromHandle( xTask );
000022  4f25              LDR      r7,|L31.184|
000024  b904              CBNZ     r4,|L31.40|
000026  683c              LDR      r4,[r7,#0]  ; pxCurrentTCB
                  |L31.40|
;;;1489   
;;;1490   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1491   
;;;1492   			#if ( configUSE_MUTEXES == 1 )
;;;1493   			{
;;;1494   				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;1495   			}
;;;1496   			#else
;;;1497   			{
;;;1498   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1499   			}
;;;1500   			#endif
;;;1501   
;;;1502   			if( uxCurrentBasePriority != uxNewPriority )
000028  6ce0              LDR      r0,[r4,#0x4c]
00002a  42a8              CMP      r0,r5
00002c  d03f              BEQ      |L31.174|
;;;1503   			{
;;;1504   				/* The priority change may have readied a task of higher
;;;1505   				priority than the calling task. */
;;;1506   				if( uxNewPriority > uxCurrentBasePriority )
;;;1507   				{
;;;1508   					if( pxTCB != pxCurrentTCB )
;;;1509   					{
;;;1510   						/* The priority of a task other than the currently
;;;1511   						running task is being raised.  Is the priority being
;;;1512   						raised above that of the running task? */
;;;1513   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
;;;1514   						{
;;;1515   							xYieldRequired = pdTRUE;
;;;1516   						}
;;;1517   						else
;;;1518   						{
;;;1519   							mtCOVERAGE_TEST_MARKER();
;;;1520   						}
;;;1521   					}
;;;1522   					else
;;;1523   					{
;;;1524   						/* The priority of the running task is being raised,
;;;1525   						but the running task must already be the highest
;;;1526   						priority task able to run so no yield is required. */
;;;1527   					}
;;;1528   				}
;;;1529   				else if( pxTCB == pxCurrentTCB )
00002e  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
000030  4285              CMP      r5,r0                 ;1506
000032  d906              BLS      |L31.66|
000034  428c              CMP      r4,r1                 ;1508
000036  d007              BEQ      |L31.72|
000038  6839              LDR      r1,[r7,#0]            ;1513  ; pxCurrentTCB
00003a  6ac9              LDR      r1,[r1,#0x2c]         ;1513
00003c  42a9              CMP      r1,r5                 ;1513
00003e  d902              BLS      |L31.70|
000040  e002              B        |L31.72|
                  |L31.66|
000042  428c              CMP      r4,r1
000044  d100              BNE      |L31.72|
                  |L31.70|
;;;1530   				{
;;;1531   					/* Setting the priority of the running task down means
;;;1532   					there may now be another task of higher priority that
;;;1533   					is ready to execute. */
;;;1534   					xYieldRequired = pdTRUE;
000046  2601              MOVS     r6,#1
                  |L31.72|
;;;1535   				}
;;;1536   				else
;;;1537   				{
;;;1538   					/* Setting the priority of any other task down does not
;;;1539   					require a yield as the running task must be above the
;;;1540   					new priority of the task being modified. */
;;;1541   				}
;;;1542   
;;;1543   				/* Remember the ready list the task might be referenced from
;;;1544   				before its uxPriority member is changed so the
;;;1545   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1546   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000048  6ae1              LDR      r1,[r4,#0x2c]
00004a  4688              MOV      r8,r1
;;;1547   
;;;1548   				#if ( configUSE_MUTEXES == 1 )
;;;1549   				{
;;;1550   					/* Only change the priority being used if the task is not
;;;1551   					currently using an inherited priority. */
;;;1552   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
00004c  4288              CMP      r0,r1
00004e  d100              BNE      |L31.82|
;;;1553   					{
;;;1554   						pxTCB->uxPriority = uxNewPriority;
000050  62e5              STR      r5,[r4,#0x2c]
                  |L31.82|
;;;1555   					}
;;;1556   					else
;;;1557   					{
;;;1558   						mtCOVERAGE_TEST_MARKER();
;;;1559   					}
;;;1560   
;;;1561   					/* The base priority gets set whatever. */
;;;1562   					pxTCB->uxBasePriority = uxNewPriority;
;;;1563   				}
;;;1564   				#else
;;;1565   				{
;;;1566   					pxTCB->uxPriority = uxNewPriority;
;;;1567   				}
;;;1568   				#endif
;;;1569   
;;;1570   				/* Only reset the event list item value if the value is not
;;;1571   				being used for anything else. */
;;;1572   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000052  64e5              STR      r5,[r4,#0x4c]
000054  69a0              LDR      r0,[r4,#0x18]
000056  2800              CMP      r0,#0
000058  db02              BLT      |L31.96|
;;;1573   				{
;;;1574   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00005a  f1c50005          RSB      r0,r5,#5
00005e  61a0              STR      r0,[r4,#0x18]
                  |L31.96|
;;;1575   				}
;;;1576   				else
;;;1577   				{
;;;1578   					mtCOVERAGE_TEST_MARKER();
;;;1579   				}
;;;1580   
;;;1581   				/* If the task is in the blocked or suspended list we need do
;;;1582   				nothing more than change its priority variable. However, if
;;;1583   				the task is in a ready list it needs to be removed and placed
;;;1584   				in the list appropriate to its new priority. */
;;;1585   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000060  4d16              LDR      r5,|L31.188|
000062  eb080088          ADD      r0,r8,r8,LSL #2
000066  6961              LDR      r1,[r4,#0x14]
000068  eb050080          ADD      r0,r5,r0,LSL #2
00006c  4281              CMP      r1,r0
00006e  d115              BNE      |L31.156|
;;;1586   				{
;;;1587   					/* The task is currently in its ready list - remove before
;;;1588   					adding it to it's new ready list.  As we are in a critical
;;;1589   					section we can do this even if the scheduler is suspended. */
;;;1590   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000070  1d20              ADDS     r0,r4,#4
000072  f7fffffe          BL       uxListRemove
000076  2101              MOVS     r1,#1                 ;1515
000078  b920              CBNZ     r0,|L31.132|
;;;1591   					{
;;;1592   						/* It is known that the task is in its ready list so
;;;1593   						there is no need to check again and the port level
;;;1594   						reset macro can be called directly. */
;;;1595   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
00007a  693a              LDR      r2,[r7,#0x10]  ; uxTopReadyPriority
00007c  fa01f008          LSL      r0,r1,r8
000080  4382              BICS     r2,r2,r0
000082  613a              STR      r2,[r7,#0x10]  ; uxTopReadyPriority
                  |L31.132|
;;;1596   					}
;;;1597   					else
;;;1598   					{
;;;1599   						mtCOVERAGE_TEST_MARKER();
;;;1600   					}
;;;1601   					prvAddTaskToReadyList( pxTCB );
000084  6ae0              LDR      r0,[r4,#0x2c]
000086  693a              LDR      r2,[r7,#0x10]  ; uxTopReadyPriority
000088  4081              LSLS     r1,r1,r0
00008a  4311              ORRS     r1,r1,r2
00008c  6139              STR      r1,[r7,#0x10]  ; uxTopReadyPriority
00008e  eb000080          ADD      r0,r0,r0,LSL #2
000092  eb050080          ADD      r0,r5,r0,LSL #2
000096  1d21              ADDS     r1,r4,#4
000098  f7fffffe          BL       vListInsertEnd
                  |L31.156|
;;;1602   				}
;;;1603   				else
;;;1604   				{
;;;1605   					mtCOVERAGE_TEST_MARKER();
;;;1606   				}
;;;1607   
;;;1608   				if( xYieldRequired != pdFALSE )
00009c  b13e              CBZ      r6,|L31.174|
;;;1609   				{
;;;1610   					taskYIELD_IF_USING_PREEMPTION();
00009e  4908              LDR      r1,|L31.192|
0000a0  f04f5080          MOV      r0,#0x10000000
0000a4  6008              STR      r0,[r1,#0]
0000a6  f3bf8f4f          DSB      
0000aa  f3bf8f6f          ISB      
                  |L31.174|
;;;1611   				}
;;;1612   				else
;;;1613   				{
;;;1614   					mtCOVERAGE_TEST_MARKER();
;;;1615   				}
;;;1616   
;;;1617   				/* Remove compiler warning about unused variables when the port
;;;1618   				optimised task selection is not being used. */
;;;1619   				( void ) uxPriorityUsedOnEntry;
;;;1620   			}
;;;1621   		}
;;;1622   		taskEXIT_CRITICAL();
0000ae  e8bd41f0          POP      {r4-r8,lr}
0000b2  f7ffbffe          B.W      vPortExitCritical
;;;1623   	}
;;;1624   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L31.184|
                          DCD      ||.data||
                  |L31.188|
                          DCD      ||.bss||
                  |L31.192|
                          DCD      0xe000ed04

                          AREA ||i.vTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskRemoveFromUnorderedEventList PROC
;;;3051   
;;;3052   void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  b570              PUSH     {r4-r6,lr}
;;;3053   {
;;;3054   TCB_t *pxUnblockedTCB;
;;;3055   
;;;3056   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;3057   	the event flags implementation. */
;;;3058   	configASSERT( uxSchedulerSuspended != pdFALSE );
000002  4d19              LDR      r5,|L32.104|
000004  6b2a              LDR      r2,[r5,#0x30]  ; uxSchedulerSuspended
000006  b1fa              CBZ      r2,|L32.72|
;;;3059   
;;;3060   	/* Store the new item value in the event list. */
;;;3061   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000008  f0414100          ORR      r1,r1,#0x80000000
;;;3062   
;;;3063   	/* Remove the event list form the event flag.  Interrupts do not access
;;;3064   	event flags. */
;;;3065   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
00000c  6001              STR      r1,[r0,#0]
;;;3066   	configASSERT( pxUnblockedTCB );
00000e  68c4              LDR      r4,[r0,#0xc]
000010  b314              CBZ      r4,|L32.88|
;;;3067   	( void ) uxListRemove( pxEventListItem );
000012  f7fffffe          BL       uxListRemove
;;;3068   
;;;3069   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;3070   	scheduler is suspended so interrupts will not be accessing the ready
;;;3071   	lists. */
;;;3072   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       uxListRemove
;;;3073   	prvAddTaskToReadyList( pxUnblockedTCB );
00001c  6ae0              LDR      r0,[r4,#0x2c]
00001e  2601              MOVS     r6,#1
000020  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000022  fa06f100          LSL      r1,r6,r0
000026  4311              ORRS     r1,r1,r2
000028  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
00002a  4910              LDR      r1,|L32.108|
00002c  eb000080          ADD      r0,r0,r0,LSL #2
000030  eb010080          ADD      r0,r1,r0,LSL #2
000034  1d21              ADDS     r1,r4,#4
000036  f7fffffe          BL       vListInsertEnd
;;;3074   
;;;3075   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00003a  6ae0              LDR      r0,[r4,#0x2c]
00003c  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00003e  6ac9              LDR      r1,[r1,#0x2c]
000040  4288              CMP      r0,r1
000042  d900              BLS      |L32.70|
;;;3076   	{
;;;3077   		/* The unblocked task has a priority above that of the calling task, so
;;;3078   		a context switch is required.  This function is called with the
;;;3079   		scheduler suspended so xYieldPending is set so the context switch
;;;3080   		occurs immediately that the scheduler is resumed (unsuspended). */
;;;3081   		xYieldPending = pdTRUE;
000044  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L32.70|
;;;3082   	}
;;;3083   }
000046  bd70              POP      {r4-r6,pc}
                  |L32.72|
000048  2050              MOVS     r0,#0x50
00004a  f3808811          MSR      BASEPRI,r0
00004e  f3bf8f4f          DSB      
000052  f3bf8f6f          ISB      
                  |L32.86|
000056  e7fe              B        |L32.86|
                  |L32.88|
000058  2050              MOVS     r0,#0x50              ;3058
00005a  f3808811          MSR      BASEPRI,r0            ;3058
00005e  f3bf8f4f          DSB                            ;3058
000062  f3bf8f6f          ISB                            ;3058
                  |L32.102|
000066  e7fe              B        |L32.102|
;;;3084   /*-----------------------------------------------------------*/
                          ENDP

                  |L32.104|
                          DCD      ||.data||
                  |L32.108|
                          DCD      ||.bss||

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1776   
;;;1777   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1778   	{
;;;1779   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000002  0004              MOVS     r4,r0
000004  d02b              BEQ      |L33.94|
;;;1780   
;;;1781   		/* It does not make sense to resume the calling task. */
;;;1782   		configASSERT( xTaskToResume );
;;;1783   
;;;1784   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1785   		currently executing task. */
;;;1786   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000006  4d1a              LDR      r5,|L33.112|
000008  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00000a  4284              CMP      r4,r0
00000c  d02f              BEQ      |L33.110|
;;;1787   		{
;;;1788   			taskENTER_CRITICAL();
00000e  f7fffffe          BL       vPortEnterCritical
;;;1789   			{
;;;1790   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       prvTaskIsTaskSuspended
000018  b1e8              CBZ      r0,|L33.86|
;;;1791   				{
;;;1792   					traceTASK_RESUME( pxTCB );
;;;1793   
;;;1794   					/* The ready list can be accessed even if the scheduler is
;;;1795   					suspended because this is inside a critical section. */
;;;1796   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
00001a  1d20              ADDS     r0,r4,#4
00001c  f7fffffe          BL       uxListRemove
;;;1797   					prvAddTaskToReadyList( pxTCB );
000020  6ae0              LDR      r0,[r4,#0x2c]
000022  2101              MOVS     r1,#1
000024  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000026  4081              LSLS     r1,r1,r0
000028  4311              ORRS     r1,r1,r2
00002a  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
00002c  4911              LDR      r1,|L33.116|
00002e  eb000080          ADD      r0,r0,r0,LSL #2
000032  eb010080          ADD      r0,r1,r0,LSL #2
000036  1d21              ADDS     r1,r4,#4
000038  f7fffffe          BL       vListInsertEnd
;;;1798   
;;;1799   					/* A higher priority task may have just been resumed. */
;;;1800   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00003c  6ae0              LDR      r0,[r4,#0x2c]
00003e  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000040  6ac9              LDR      r1,[r1,#0x2c]
000042  4288              CMP      r0,r1
000044  d307              BCC      |L33.86|
;;;1801   					{
;;;1802   						/* This yield may not cause the task just resumed to run,
;;;1803   						but will leave the lists in the correct state for the
;;;1804   						next yield. */
;;;1805   						taskYIELD_IF_USING_PREEMPTION();
000046  490c              LDR      r1,|L33.120|
000048  f04f5080          MOV      r0,#0x10000000
00004c  6008              STR      r0,[r1,#0]
00004e  f3bf8f4f          DSB      
000052  f3bf8f6f          ISB      
                  |L33.86|
;;;1806   					}
;;;1807   					else
;;;1808   					{
;;;1809   						mtCOVERAGE_TEST_MARKER();
;;;1810   					}
;;;1811   				}
;;;1812   				else
;;;1813   				{
;;;1814   					mtCOVERAGE_TEST_MARKER();
;;;1815   				}
;;;1816   			}
;;;1817   			taskEXIT_CRITICAL();
000056  e8bd4070          POP      {r4-r6,lr}
00005a  f7ffbffe          B.W      vPortExitCritical
                  |L33.94|
00005e  2050              MOVS     r0,#0x50
000060  f3808811          MSR      BASEPRI,r0
000064  f3bf8f4f          DSB      
000068  f3bf8f6f          ISB      
                  |L33.108|
00006c  e7fe              B        |L33.108|
                  |L33.110|
;;;1818   		}
;;;1819   		else
;;;1820   		{
;;;1821   			mtCOVERAGE_TEST_MARKER();
;;;1822   		}
;;;1823   	}
00006e  bd70              POP      {r4-r6,pc}
;;;1824   
                          ENDP

                  |L33.112|
                          DCD      ||.data||
                  |L33.116|
                          DCD      ||.bss||
                  |L33.120|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSetTaskNumber||, CODE, READONLY, ALIGN=1

                  vTaskSetTaskNumber PROC
;;;3199   
;;;3200   	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
000000  2800              CMP      r0,#0
;;;3201   	{
000002  d000              BEQ      |L34.6|
;;;3202   	TCB_t *pxTCB;
;;;3203   
;;;3204   		if( xTask != NULL )
;;;3205   		{
;;;3206   			pxTCB = ( TCB_t * ) xTask;
;;;3207   			pxTCB->uxTaskNumber = uxHandle;
000004  6481              STR      r1,[r0,#0x48]
                  |L34.6|
;;;3208   		}
;;;3209   	}
000006  4770              BX       lr
;;;3210   
                          ENDP


                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;3085   
;;;3086   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  b510              PUSH     {r4,lr}
;;;3087   {
000002  0004              MOVS     r4,r0
000004  d00a              BEQ      |L35.28|
;;;3088   	configASSERT( pxTimeOut );
;;;3089   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;3090   	{
;;;3091   		pxTimeOut->xOverflowCount = xNumOfOverflows;
00000a  4808              LDR      r0,|L35.44|
00000c  6a01              LDR      r1,[r0,#0x20]  ; xNumOfOverflows
;;;3092   		pxTimeOut->xTimeOnEntering = xTickCount;
00000e  6021              STR      r1,[r4,#0]
000010  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;3093   	}
;;;3094   	taskEXIT_CRITICAL();
000012  6060              STR      r0,[r4,#4]
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      vPortExitCritical
                  |L35.28|
00001c  2050              MOVS     r0,#0x50
00001e  f3808811          MSR      BASEPRI,r0
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
                  |L35.42|
00002a  e7fe              B        |L35.42|
;;;3095   }
;;;3096   /*-----------------------------------------------------------*/
                          ENDP

                  |L35.44|
                          DCD      ||.data||

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1900   
;;;1901   void vTaskStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;1902   {
;;;1903   BaseType_t xReturn;
;;;1904   
;;;1905   	/* Add the idle task at the lowest priority. */
;;;1906   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1907   	{
;;;1908   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
;;;1909   		StackType_t *pxIdleTaskStackBuffer = NULL;
;;;1910   		uint32_t ulIdleTaskStackSize;
;;;1911   
;;;1912   		/* The Idle task is created using user provided RAM - obtain the
;;;1913   		address of the RAM then create the idle task. */
;;;1914   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
;;;1915   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
;;;1916   												configIDLE_TASK_NAME,
;;;1917   												ulIdleTaskStackSize,
;;;1918   												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
;;;1919   												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1920   												pxIdleTaskStackBuffer,
;;;1921   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1922   
;;;1923   		if( xIdleTaskHandle != NULL )
;;;1924   		{
;;;1925   			xReturn = pdPASS;
;;;1926   		}
;;;1927   		else
;;;1928   		{
;;;1929   			xReturn = pdFAIL;
;;;1930   		}
;;;1931   	}
;;;1932   	#else
;;;1933   	{
;;;1934   		/* The Idle task is being created using dynamically allocated RAM. */
;;;1935   		xReturn = xTaskCreate(	prvIdleTask,
000002  4817              LDR      r0,|L36.96|
000004  2400              MOVS     r4,#0
000006  e9cd4000          STRD     r4,r0,[sp,#0]
00000a  4623              MOV      r3,r4
00000c  2280              MOVS     r2,#0x80
00000e  a115              ADR      r1,|L36.100|
000010  4816              LDR      r0,|L36.108|
000012  f7fffffe          BL       xTaskCreate
;;;1936   								configIDLE_TASK_NAME,
;;;1937   								configMINIMAL_STACK_SIZE,
;;;1938   								( void * ) NULL,
;;;1939   								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1940   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1941   	}
;;;1942   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;1943   
;;;1944   	#if ( configUSE_TIMERS == 1 )
;;;1945   	{
;;;1946   		if( xReturn == pdPASS )
000016  2801              CMP      r0,#1
000018  d103              BNE      |L36.34|
;;;1947   		{
;;;1948   			xReturn = xTimerCreateTimerTask();
00001a  f7fffffe          BL       xTimerCreateTimerTask
;;;1949   		}
;;;1950   		else
;;;1951   		{
;;;1952   			mtCOVERAGE_TEST_MARKER();
;;;1953   		}
;;;1954   	}
;;;1955   	#endif /* configUSE_TIMERS */
;;;1956   
;;;1957   	if( xReturn == pdPASS )
00001e  2801              CMP      r0,#1
000020  d009              BEQ      |L36.54|
                  |L36.34|
000022  1c40              ADDS     r0,r0,#1              ;1948
;;;1958   	{
;;;1959   		/* freertos_tasks_c_additions_init() should only be called if the user
;;;1960   		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
;;;1961   		the only macro called by the function. */
;;;1962   		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
;;;1963   		{
;;;1964   			freertos_tasks_c_additions_init();
;;;1965   		}
;;;1966   		#endif
;;;1967   
;;;1968   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1969   		before or during the call to xPortStartScheduler().  The stacks of
;;;1970   		the created tasks contain a status word with interrupts switched on
;;;1971   		so interrupts will automatically get re-enabled when the first task
;;;1972   		starts to run. */
;;;1973   		portDISABLE_INTERRUPTS();
;;;1974   
;;;1975   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1976   		{
;;;1977   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1978   			structure specific to the task that will run first. */
;;;1979   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1980   		}
;;;1981   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1982   
;;;1983   		xNextTaskUnblockTime = portMAX_DELAY;
;;;1984   		xSchedulerRunning = pdTRUE;
;;;1985   		xTickCount = ( TickType_t ) 0U;
;;;1986   
;;;1987   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1988   		macro must be defined to configure the timer/counter used to generate
;;;1989   		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
;;;1990   		is set to 0 and the following line fails to build then ensure you do not
;;;1991   		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
;;;1992   		FreeRTOSConfig.h file. */
;;;1993   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1994   
;;;1995   		/* Setting up the timer tick is hardware specific and thus in the
;;;1996   		portable interface. */
;;;1997   		if( xPortStartScheduler() != pdFALSE )
;;;1998   		{
;;;1999   			/* Should not reach here as if the scheduler is running the
;;;2000   			function will not return. */
;;;2001   		}
;;;2002   		else
;;;2003   		{
;;;2004   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;2005   		}
;;;2006   	}
;;;2007   	else
;;;2008   	{
;;;2009   		/* This line will only be reached if the kernel could not be started,
;;;2010   		because there was not enough FreeRTOS heap to create the idle task
;;;2011   		or the timer task. */
;;;2012   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
000024  d11a              BNE      |L36.92|
000026  2050              MOVS     r0,#0x50
000028  f3808811          MSR      BASEPRI,r0
00002c  f3bf8f4f          DSB      
000030  f3bf8f6f          ISB      
                  |L36.52|
000034  e7fe              B        |L36.52|
                  |L36.54|
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  4806              LDR      r0,|L36.96|
000046  f04f31ff          MOV      r1,#0xffffffff        ;1983
00004a  382c              SUBS     r0,r0,#0x2c           ;1983
00004c  6281              STR      r1,[r0,#0x28]         ;1983  ; xNextTaskUnblockTime
00004e  2101              MOVS     r1,#1                 ;1984
000050  6141              STR      r1,[r0,#0x14]         ;1984  ; xSchedulerRunning
000052  60c4              STR      r4,[r0,#0xc]          ;1985  ; xTickCount
000054  e8bd401c          POP      {r2-r4,lr}            ;1997
000058  f7ffbffe          B.W      xPortStartScheduler
                  |L36.92|
;;;2013   	}
;;;2014   
;;;2015   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;2016   	meaning xIdleTaskHandle is not used anywhere else. */
;;;2017   	( void ) xIdleTaskHandle;
;;;2018   }
00005c  bd1c              POP      {r2-r4,pc}
;;;2019   /*-----------------------------------------------------------*/
                          ENDP

00005e  0000              DCW      0x0000
                  |L36.96|
                          DCD      ||.data||+0x2c
                  |L36.100|
000064  49444c45          DCB      "IDLE",0
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L36.108|
                          DCD      prvIdleTask

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1629   
;;;1630   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1631   	{
000002  4604              MOV      r4,r0
;;;1632   	TCB_t *pxTCB;
;;;1633   
;;;1634   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1635   		{
;;;1636   			/* If null is passed in here then it is the running task that is
;;;1637   			being suspended. */
;;;1638   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  4d29              LDR      r5,|L37.176|
00000a  b904              CBNZ     r4,|L37.14|
00000c  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L37.14|
;;;1639   
;;;1640   			traceTASK_SUSPEND( pxTCB );
;;;1641   
;;;1642   			/* Remove task from the ready/delayed list and place in the
;;;1643   			suspended list. */
;;;1644   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
000014  b958              CBNZ     r0,|L37.46|
;;;1645   			{
;;;1646   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000016  6ae0              LDR      r0,[r4,#0x2c]
000018  4a26              LDR      r2,|L37.180|
00001a  eb000180          ADD      r1,r0,r0,LSL #2
00001e  f8521021          LDR      r1,[r2,r1,LSL #2]
000022  b921              CBNZ     r1,|L37.46|
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
00002a  4388              BICS     r0,r0,r1
00002c  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L37.46|
;;;1647   			}
;;;1648   			else
;;;1649   			{
;;;1650   				mtCOVERAGE_TEST_MARKER();
;;;1651   			}
;;;1652   
;;;1653   			/* Is the task waiting on an event also? */
;;;1654   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00002e  6aa0              LDR      r0,[r4,#0x28]
000030  b118              CBZ      r0,|L37.58|
;;;1655   			{
;;;1656   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000032  f1040018          ADD      r0,r4,#0x18
000036  f7fffffe          BL       uxListRemove
                  |L37.58|
;;;1657   			}
;;;1658   			else
;;;1659   			{
;;;1660   				mtCOVERAGE_TEST_MARKER();
;;;1661   			}
;;;1662   
;;;1663   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
00003a  481e              LDR      r0,|L37.180|
00003c  1d21              ADDS     r1,r4,#4
00003e  30b4              ADDS     r0,r0,#0xb4
000040  f7fffffe          BL       vListInsertEnd
;;;1664   
;;;1665   			#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1666   			{
;;;1667   				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000044  f8940058          LDRB     r0,[r4,#0x58]
000048  2600              MOVS     r6,#0
00004a  2801              CMP      r0,#1
00004c  d101              BNE      |L37.82|
;;;1668   				{
;;;1669   					/* The task was blocked to wait for a notification, but is
;;;1670   					now suspended, so no notification was received. */
;;;1671   					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00004e  f8846058          STRB     r6,[r4,#0x58]
                  |L37.82|
;;;1672   				}
;;;1673   			}
;;;1674   			#endif
;;;1675   		}
;;;1676   		taskEXIT_CRITICAL();
000052  f7fffffe          BL       vPortExitCritical
;;;1677   
;;;1678   		if( xSchedulerRunning != pdFALSE )
000056  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000058  b128              CBZ      r0,|L37.102|
;;;1679   		{
;;;1680   			/* Reset the next expected unblock time in case it referred to the
;;;1681   			task that is now in the Suspended state. */
;;;1682   			taskENTER_CRITICAL();
00005a  f7fffffe          BL       vPortEnterCritical
;;;1683   			{
;;;1684   				prvResetNextTaskUnblockTime();
00005e  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1685   			}
;;;1686   			taskEXIT_CRITICAL();
000062  f7fffffe          BL       vPortExitCritical
                  |L37.102|
;;;1687   		}
;;;1688   		else
;;;1689   		{
;;;1690   			mtCOVERAGE_TEST_MARKER();
;;;1691   		}
;;;1692   
;;;1693   		if( pxTCB == pxCurrentTCB )
000066  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000068  4284              CMP      r4,r0
00006a  d113              BNE      |L37.148|
;;;1694   		{
;;;1695   			if( xSchedulerRunning != pdFALSE )
00006c  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
00006e  b190              CBZ      r0,|L37.150|
;;;1696   			{
;;;1697   				/* The current task has just been suspended. */
;;;1698   				configASSERT( uxSchedulerSuspended == 0 );
000070  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000072  b138              CBZ      r0,|L37.132|
000074  2050              MOVS     r0,#0x50
000076  f3808811          MSR      BASEPRI,r0
00007a  f3bf8f4f          DSB      
00007e  f3bf8f6f          ISB      
                  |L37.130|
000082  e7fe              B        |L37.130|
                  |L37.132|
;;;1699   				portYIELD_WITHIN_API();
000084  490c              LDR      r1,|L37.184|
000086  f04f5080          MOV      r0,#0x10000000
00008a  6008              STR      r0,[r1,#0]
00008c  f3bf8f4f          DSB      
000090  f3bf8f6f          ISB      
                  |L37.148|
;;;1700   			}
;;;1701   			else
;;;1702   			{
;;;1703   				/* The scheduler is not running, but the task that was pointed
;;;1704   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1705   				must be adjusted to point to a different task. */
;;;1706   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
;;;1707   				{
;;;1708   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1709   					NULL so when the next task is created pxCurrentTCB will
;;;1710   					be set to point to it no matter what its relative priority
;;;1711   					is. */
;;;1712   					pxCurrentTCB = NULL;
;;;1713   				}
;;;1714   				else
;;;1715   				{
;;;1716   					vTaskSwitchContext();
;;;1717   				}
;;;1718   			}
;;;1719   		}
;;;1720   		else
;;;1721   		{
;;;1722   			mtCOVERAGE_TEST_MARKER();
;;;1723   		}
;;;1724   	}
000094  bd70              POP      {r4-r6,pc}
                  |L37.150|
000096  4807              LDR      r0,|L37.180|
000098  30b4              ADDS     r0,r0,#0xb4           ;1706
00009a  6800              LDR      r0,[r0,#0]            ;1706  ; xSuspendedTaskList
00009c  68a9              LDR      r1,[r5,#8]            ;1706  ; uxCurrentNumberOfTasks
00009e  4288              CMP      r0,r1                 ;1706
0000a0  d101              BNE      |L37.166|
0000a2  602e              STR      r6,[r5,#0]            ;1712  ; pxCurrentTCB
0000a4  bd70              POP      {r4-r6,pc}
                  |L37.166|
0000a6  e8bd4070          POP      {r4-r6,lr}            ;1716
0000aa  f7ffbffe          B.W      vTaskSwitchContext
;;;1725   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L37.176|
                          DCD      ||.data||
                  |L37.180|
                          DCD      ||.bss||
                  |L37.184|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;2031   
;;;2032   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L38.12|
;;;2033   {
;;;2034   	/* A critical section is not required as the variable is of type
;;;2035   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;2036   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;2037   	http://goo.gl/wu4acr */
;;;2038   	++uxSchedulerSuspended;
000002  6b01              LDR      r1,[r0,#0x30]  ; uxSchedulerSuspended
000004  1c49              ADDS     r1,r1,#1
000006  6301              STR      r1,[r0,#0x30]  ; uxSchedulerSuspended
;;;2039   }
000008  4770              BX       lr
;;;2040   /*----------------------------------------------------------*/
                          ENDP

00000a  0000              DCW      0x0000
                  |L38.12|
                          DCD      ||.data||

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2850   
;;;2851   void vTaskSwitchContext( void )
000000  b510              PUSH     {r4,lr}
;;;2852   {
;;;2853   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  4c1f              LDR      r4,|L39.128|
000004  6b20              LDR      r0,[r4,#0x30]  ; uxSchedulerSuspended
000006  b110              CBZ      r0,|L39.14|
;;;2854   	{
;;;2855   		/* The scheduler is currently suspended - do not allow a context
;;;2856   		switch. */
;;;2857   		xYieldPending = pdTRUE;
000008  2001              MOVS     r0,#1
00000a  61e0              STR      r0,[r4,#0x1c]  ; xYieldPending
;;;2858   	}
;;;2859   	else
;;;2860   	{
;;;2861   		xYieldPending = pdFALSE;
;;;2862   		traceTASK_SWITCHED_OUT();
;;;2863   
;;;2864   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2865   		{
;;;2866   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2867   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2868   				#else
;;;2869   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2870   				#endif
;;;2871   
;;;2872   				/* Add the amount of time the task has been running to the
;;;2873   				accumulated time so far.  The time the task started running was
;;;2874   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2875   				protection here so count values are only valid until the timer
;;;2876   				overflows.  The guard against negative values is to protect
;;;2877   				against suspect run time stat counter implementations - which
;;;2878   				are provided by the application, not the kernel. */
;;;2879   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2880   				{
;;;2881   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2882   				}
;;;2883   				else
;;;2884   				{
;;;2885   					mtCOVERAGE_TEST_MARKER();
;;;2886   				}
;;;2887   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2888   		}
;;;2889   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2890   
;;;2891   		/* Check for stack overflow, if configured. */
;;;2892   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2893   
;;;2894   		/* Select a new task to run using either the generic C or port
;;;2895   		optimised asm code. */
;;;2896   		taskSELECT_HIGHEST_PRIORITY_TASK();
;;;2897   		traceTASK_SWITCHED_IN();
;;;2898   
;;;2899   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2900   		{
;;;2901   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2902   			structure specific to this task. */
;;;2903   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2904   		}
;;;2905   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2906   	}
;;;2907   }
00000c  bd10              POP      {r4,pc}
                  |L39.14|
00000e  2000              MOVS     r0,#0                 ;2861
000010  61e0              STR      r0,[r4,#0x1c]         ;2861  ; xYieldPending
000012  6820              LDR      r0,[r4,#0]            ;2892  ; pxCurrentTCB
000014  f04f32a5          MOV      r2,#0xa5a5a5a5        ;2892
000018  6b00              LDR      r0,[r0,#0x30]         ;2892
00001a  6801              LDR      r1,[r0,#0]            ;2892
00001c  4291              CMP      r1,r2                 ;2892
00001e  d108              BNE      |L39.50|
000020  6841              LDR      r1,[r0,#4]            ;2892
000022  4291              CMP      r1,r2                 ;2892
000024  d105              BNE      |L39.50|
000026  6881              LDR      r1,[r0,#8]            ;2892
000028  4291              CMP      r1,r2                 ;2892
00002a  d102              BNE      |L39.50|
00002c  68c0              LDR      r0,[r0,#0xc]          ;2892
00002e  4290              CMP      r0,r2                 ;2892
000030  d004              BEQ      |L39.60|
                  |L39.50|
000032  6821              LDR      r1,[r4,#0]            ;2892  ; pxCurrentTCB
000034  6820              LDR      r0,[r4,#0]            ;2892  ; pxCurrentTCB
000036  3134              ADDS     r1,r1,#0x34           ;2892
000038  f7fffffe          BL       vApplicationStackOverflowHook
                  |L39.60|
00003c  6920              LDR      r0,[r4,#0x10]         ;2896  ; uxTopReadyPriority
00003e  4911              LDR      r1,|L39.132|
000040  fab0f080          CLZ      r0,r0                 ;2896
000044  f1c0001f          RSB      r0,r0,#0x1f           ;2896
000048  eb000080          ADD      r0,r0,r0,LSL #2       ;2896
00004c  f8512020          LDR      r2,[r1,r0,LSL #2]     ;2896
000050  b16a              CBZ      r2,|L39.110|
000052  eb010080          ADD      r0,r1,r0,LSL #2       ;2896
000056  f1000208          ADD      r2,r0,#8              ;2896
00005a  6841              LDR      r1,[r0,#4]            ;2896
00005c  6849              LDR      r1,[r1,#4]            ;2896
00005e  6041              STR      r1,[r0,#4]            ;2896
000060  4291              CMP      r1,r2                 ;2896
000062  d101              BNE      |L39.104|
000064  6849              LDR      r1,[r1,#4]            ;2896
000066  6041              STR      r1,[r0,#4]            ;2896
                  |L39.104|
000068  68c8              LDR      r0,[r1,#0xc]          ;2896
00006a  6020              STR      r0,[r4,#0]            ;2896  ; pxCurrentTCB
00006c  bd10              POP      {r4,pc}
                  |L39.110|
00006e  2050              MOVS     r0,#0x50
000070  f3808811          MSR      BASEPRI,r0
000074  f3bf8f4f          DSB      
000078  f3bf8f6f          ISB      
                  |L39.124|
00007c  e7fe              B        |L39.124|
;;;2908   /*-----------------------------------------------------------*/
                          ENDP

00007e  0000              DCW      0x0000
                  |L39.128|
                          DCD      ||.data||
                  |L39.132|
                          DCD      ||.bss||

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;3105   
;;;3106   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3107   {
000004  460c              MOV      r4,r1
000006  0005              MOVS     r5,r0
000008  d011              BEQ      |L40.46|
;;;3108   BaseType_t xReturn;
;;;3109   
;;;3110   	configASSERT( pxTimeOut );
;;;3111   	configASSERT( pxTicksToWait );
00000a  b1c4              CBZ      r4,|L40.62|
;;;3112   
;;;3113   	taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;3114   	{
;;;3115   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3116   		const TickType_t xConstTickCount = xTickCount;
000010  4e17              LDR      r6,|L40.112|
000012  68f1              LDR      r1,[r6,#0xc]  ; xTickCount
;;;3117   		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
000014  686b              LDR      r3,[r5,#4]
;;;3118   
;;;3119   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3120   			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
;;;3121   			{
;;;3122   				/* The delay was aborted, which is not the same as a time out,
;;;3123   				but has the same result. */
;;;3124   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3125   				xReturn = pdTRUE;
;;;3126   			}
;;;3127   			else
;;;3128   		#endif
;;;3129   
;;;3130   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3131   			if( *pxTicksToWait == portMAX_DELAY )
000016  6822              LDR      r2,[r4,#0]
000018  1ac8              SUBS     r0,r1,r3              ;3117
00001a  1c57              ADDS     r7,r2,#1
00001c  d017              BEQ      |L40.78|
;;;3132   			{
;;;3133   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3134   				specified is the maximum block time then the task should block
;;;3135   				indefinitely, and therefore never time out. */
;;;3136   				xReturn = pdFALSE;
;;;3137   			}
;;;3138   			else
;;;3139   		#endif
;;;3140   
;;;3141   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
00001e  682f              LDR      r7,[r5,#0]
000020  6a36              LDR      r6,[r6,#0x20]  ; xNumOfOverflows
000022  42b7              CMP      r7,r6
000024  d019              BEQ      |L40.90|
000026  428b              CMP      r3,r1
000028  d817              BHI      |L40.90|
                  |L40.42|
;;;3142   		{
;;;3143   			/* The tick count is greater than the time at which
;;;3144   			vTaskSetTimeout() was called, but has also overflowed since
;;;3145   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3146   			around and gone past again. This passed since vTaskSetTimeout()
;;;3147   			was called. */
;;;3148   			xReturn = pdTRUE;
00002a  2401              MOVS     r4,#1
00002c  e010              B        |L40.80|
                  |L40.46|
00002e  2050              MOVS     r0,#0x50
000030  f3808811          MSR      BASEPRI,r0
000034  f3bf8f4f          DSB      
000038  f3bf8f6f          ISB      
                  |L40.60|
00003c  e7fe              B        |L40.60|
                  |L40.62|
00003e  2050              MOVS     r0,#0x50              ;3110
000040  f3808811          MSR      BASEPRI,r0            ;3110
000044  f3bf8f4f          DSB                            ;3110
000048  f3bf8f6f          ISB                            ;3110
                  |L40.76|
00004c  e7fe              B        |L40.76|
                  |L40.78|
00004e  2400              MOVS     r4,#0                 ;3136
                  |L40.80|
;;;3149   		}
;;;3150   		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
;;;3151   		{
;;;3152   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3153   			*pxTicksToWait -= xElapsedTime;
;;;3154   			vTaskInternalSetTimeOutState( pxTimeOut );
;;;3155   			xReturn = pdFALSE;
;;;3156   		}
;;;3157   		else
;;;3158   		{
;;;3159   			*pxTicksToWait = 0;
;;;3160   			xReturn = pdTRUE;
;;;3161   		}
;;;3162   	}
;;;3163   	taskEXIT_CRITICAL();
000050  f7fffffe          BL       vPortExitCritical
;;;3164   
;;;3165   	return xReturn;
000054  4620              MOV      r0,r4
;;;3166   }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L40.90|
00005a  4282              CMP      r2,r0                 ;3150
00005c  d905              BLS      |L40.106|
00005e  1a10              SUBS     r0,r2,r0              ;3153
000060  6020              STR      r0,[r4,#0]            ;3154
000062  4628              MOV      r0,r5                 ;3154
000064  f7fffffe          BL       vTaskInternalSetTimeOutState
000068  e7f1              B        |L40.78|
                  |L40.106|
00006a  2000              MOVS     r0,#0                 ;3159
00006c  6020              STR      r0,[r4,#0]            ;3160
00006e  e7dc              B        |L40.42|
;;;3167   /*-----------------------------------------------------------*/
                          ENDP

                  |L40.112|
                          DCD      ||.data||

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=1

                  xTaskCreate PROC
;;;731    
;;;732    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;733    							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;734    							const configSTACK_DEPTH_TYPE usStackDepth,
;;;735    							void * const pvParameters,
;;;736    							UBaseType_t uxPriority,
;;;737    							TaskHandle_t * const pxCreatedTask )
;;;738    	{
000004  4683              MOV      r11,r0
000006  e9dd870e          LDRD     r8,r7,[sp,#0x38]
00000a  4699              MOV      r9,r3
00000c  4616              MOV      r6,r2
00000e  468a              MOV      r10,r1
;;;739    	TCB_t *pxNewTCB;
;;;740    	BaseType_t xReturn;
;;;741    
;;;742    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;743    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;744    		the TCB then the stack. */
;;;745    		#if( portSTACK_GROWTH > 0 )
;;;746    		{
;;;747    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;748    			the implementation of the port malloc function and whether or not static
;;;749    			allocation is being used. */
;;;750    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;751    
;;;752    			if( pxNewTCB != NULL )
;;;753    			{
;;;754    				/* Allocate space for the stack used by the task being created.
;;;755    				The base of the stack memory stored in the TCB so the task can
;;;756    				be deleted later if required. */
;;;757    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;758    
;;;759    				if( pxNewTCB->pxStack == NULL )
;;;760    				{
;;;761    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;762    					vPortFree( pxNewTCB );
;;;763    					pxNewTCB = NULL;
;;;764    				}
;;;765    			}
;;;766    		}
;;;767    		#else /* portSTACK_GROWTH */
;;;768    		{
;;;769    		StackType_t *pxStack;
;;;770    
;;;771    			/* Allocate space for the stack used by the task being created. */
;;;772    			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000010  0090              LSLS     r0,r2,#2
000012  f7fffffe          BL       pvPortMalloc
000016  0005              MOVS     r5,r0
;;;773    
;;;774    			if( pxStack != NULL )
000018  d01a              BEQ      |L41.80|
;;;775    			{
;;;776    				/* Allocate space for the TCB. */
;;;777    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
00001a  205c              MOVS     r0,#0x5c
00001c  f7fffffe          BL       pvPortMalloc
000020  0004              MOVS     r4,r0
;;;778    
;;;779    				if( pxNewTCB != NULL )
000022  d012              BEQ      |L41.74|
;;;780    				{
;;;781    					/* Store the stack location in the TCB. */
;;;782    					pxNewTCB->pxStack = pxStack;
;;;783    				}
;;;784    				else
;;;785    				{
;;;786    					/* The stack cannot be used as the TCB was not created.  Free
;;;787    					it again. */
;;;788    					vPortFree( pxStack );
;;;789    				}
;;;790    			}
;;;791    			else
;;;792    			{
;;;793    				pxNewTCB = NULL;
;;;794    			}
;;;795    		}
;;;796    		#endif /* portSTACK_GROWTH */
;;;797    
;;;798    		if( pxNewTCB != NULL )
;;;799    		{
;;;800    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
;;;801    			{
;;;802    				/* Tasks can be created statically or dynamically, so note this
;;;803    				task was created dynamically in case it is later deleted. */
;;;804    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;;;805    			}
;;;806    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;807    
;;;808    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
000024  6325              STR      r5,[r4,#0x30]
000026  2100              MOVS     r1,#0
000028  e9cd4102          STRD     r4,r1,[sp,#8]
00002c  e9cd8700          STRD     r8,r7,[sp,#0]
000030  464b              MOV      r3,r9
000032  4632              MOV      r2,r6
000034  4651              MOV      r1,r10
000036  4658              MOV      r0,r11
000038  f7fffffe          BL       prvInitialiseNewTask
;;;809    			prvAddNewTaskToReadyList( pxNewTCB );
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       prvAddNewTaskToReadyList
;;;810    			xReturn = pdPASS;
000042  2001              MOVS     r0,#1
                  |L41.68|
;;;811    		}
;;;812    		else
;;;813    		{
;;;814    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
;;;815    		}
;;;816    
;;;817    		return xReturn;
;;;818    	}
000044  b004              ADD      sp,sp,#0x10
000046  e8bd9ff0          POP      {r4-r12,pc}
                  |L41.74|
00004a  4628              MOV      r0,r5                 ;788
00004c  f7fffffe          BL       vPortFree
                  |L41.80|
000050  f04f30ff          MOV      r0,#0xffffffff        ;814
000054  e7f6              B        |L41.68|
;;;819    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4559   
;;;4560   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4561   	{
000004  461f              MOV      r7,r3
000006  4690              MOV      r8,r2
000008  460d              MOV      r5,r1
;;;4562   	TCB_t * pxTCB;
;;;4563   	BaseType_t xReturn = pdPASS;
00000a  2601              MOVS     r6,#1
00000c  b190              CBZ      r0,|L42.52|
;;;4564   	uint8_t ucOriginalNotifyState;
;;;4565   
;;;4566   		configASSERT( xTaskToNotify );
;;;4567   		pxTCB = ( TCB_t * ) xTaskToNotify;
00000e  4604              MOV      r4,r0
;;;4568   
;;;4569   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;4570   		{
;;;4571   			if( pulPreviousNotificationValue != NULL )
000014  b10f              CBZ      r7,|L42.26|
;;;4572   			{
;;;4573   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000016  6d60              LDR      r0,[r4,#0x54]
000018  6038              STR      r0,[r7,#0]
                  |L42.26|
;;;4574   			}
;;;4575   
;;;4576   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00001a  f8940058          LDRB     r0,[r4,#0x58]
;;;4577   
;;;4578   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
00001e  2102              MOVS     r1,#2
000020  f8841058          STRB     r1,[r4,#0x58]
;;;4579   
;;;4580   			switch( eAction )
000024  f1b80f05          CMP      r8,#5
000028  d216              BCS      |L42.88|
00002a  e8dff008          TBB      [pc,r8]
00002e  150b              DCB      0x15,0x0b
000030  0e141200          DCB      0x0e,0x14,0x12,0x00
                  |L42.52|
000034  2050              MOVS     r0,#0x50
000036  f3808811          MSR      BASEPRI,r0
00003a  f3bf8f4f          DSB      
00003e  f3bf8f6f          ISB      
                  |L42.66|
000042  e7fe              B        |L42.66|
;;;4581   			{
;;;4582   				case eSetBits	:
;;;4583   					pxTCB->ulNotifiedValue |= ulValue;
000044  6d61              LDR      r1,[r4,#0x54]
000046  4329              ORRS     r1,r1,r5
;;;4584   					break;
000048  e001              B        |L42.78|
;;;4585   
;;;4586   				case eIncrement	:
;;;4587   					( pxTCB->ulNotifiedValue )++;
00004a  6d61              LDR      r1,[r4,#0x54]
00004c  1c49              ADDS     r1,r1,#1
                  |L42.78|
00004e  6561              STR      r1,[r4,#0x54]         ;4583
000050  e002              B        |L42.88|
;;;4588   					break;
;;;4589   
;;;4590   				case eSetValueWithOverwrite	:
;;;4591   					pxTCB->ulNotifiedValue = ulValue;
;;;4592   					break;
;;;4593   
;;;4594   				case eSetValueWithoutOverwrite :
;;;4595   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000052  2802              CMP      r0,#2
000054  d003              BEQ      |L42.94|
;;;4596   					{
;;;4597   						pxTCB->ulNotifiedValue = ulValue;
000056  6565              STR      r5,[r4,#0x54]
                  |L42.88|
;;;4598   					}
;;;4599   					else
;;;4600   					{
;;;4601   						/* The value could not be written to the task. */
;;;4602   						xReturn = pdFAIL;
;;;4603   					}
;;;4604   					break;
;;;4605   
;;;4606   				case eNoAction:
;;;4607   					/* The task is being notified without its notify value being
;;;4608   					updated. */
;;;4609   					break;
;;;4610   			}
;;;4611   
;;;4612   			traceTASK_NOTIFY();
;;;4613   
;;;4614   			/* If the task is in the blocked state specifically to wait for a
;;;4615   			notification then unblock it now. */
;;;4616   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000058  2801              CMP      r0,#1
00005a  d002              BEQ      |L42.98|
00005c  e02a              B        |L42.180|
                  |L42.94|
00005e  2600              MOVS     r6,#0                 ;4602
000060  e028              B        |L42.180|
                  |L42.98|
;;;4617   			{
;;;4618   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000062  1d20              ADDS     r0,r4,#4
000064  f7fffffe          BL       uxListRemove
;;;4619   				prvAddTaskToReadyList( pxTCB );
000068  4d15              LDR      r5,|L42.192|
00006a  6ae0              LDR      r0,[r4,#0x2c]
00006c  2101              MOVS     r1,#1
00006e  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000070  4081              LSLS     r1,r1,r0
000072  4311              ORRS     r1,r1,r2
000074  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000076  4913              LDR      r1,|L42.196|
000078  eb000080          ADD      r0,r0,r0,LSL #2
00007c  eb010080          ADD      r0,r1,r0,LSL #2
000080  1d21              ADDS     r1,r4,#4
000082  f7fffffe          BL       vListInsertEnd
;;;4620   
;;;4621   				/* The task should not have been on an event list. */
;;;4622   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000086  6aa0              LDR      r0,[r4,#0x28]
000088  b138              CBZ      r0,|L42.154|
00008a  2050              MOVS     r0,#0x50
00008c  f3808811          MSR      BASEPRI,r0
000090  f3bf8f4f          DSB      
000094  f3bf8f6f          ISB      
                  |L42.152|
000098  e7fe              B        |L42.152|
                  |L42.154|
;;;4623   
;;;4624   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4625   				{
;;;4626   					/* If a task is blocked waiting for a notification then
;;;4627   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4628   					out time.  If the task is unblocked for a reason other than
;;;4629   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4630   					because it will automatically get reset to a new value when
;;;4631   					the tick count equals xNextTaskUnblockTime.  However if
;;;4632   					tickless idling is used it might be more important to enter
;;;4633   					sleep mode at the earliest possible time - so reset
;;;4634   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4635   					earliest possible time. */
;;;4636   					prvResetNextTaskUnblockTime();
;;;4637   				}
;;;4638   				#endif
;;;4639   
;;;4640   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00009a  6ae0              LDR      r0,[r4,#0x2c]
00009c  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00009e  6ac9              LDR      r1,[r1,#0x2c]
0000a0  4288              CMP      r0,r1
0000a2  d907              BLS      |L42.180|
;;;4641   				{
;;;4642   					/* The notified task has a priority above the currently
;;;4643   					executing task so a yield is required. */
;;;4644   					taskYIELD_IF_USING_PREEMPTION();
0000a4  4908              LDR      r1,|L42.200|
0000a6  f04f5080          MOV      r0,#0x10000000
0000aa  6008              STR      r0,[r1,#0]
0000ac  f3bf8f4f          DSB      
0000b0  f3bf8f6f          ISB      
                  |L42.180|
;;;4645   				}
;;;4646   				else
;;;4647   				{
;;;4648   					mtCOVERAGE_TEST_MARKER();
;;;4649   				}
;;;4650   			}
;;;4651   			else
;;;4652   			{
;;;4653   				mtCOVERAGE_TEST_MARKER();
;;;4654   			}
;;;4655   		}
;;;4656   		taskEXIT_CRITICAL();
0000b4  f7fffffe          BL       vPortExitCritical
;;;4657   
;;;4658   		return xReturn;
0000b8  4630              MOV      r0,r6
;;;4659   	}
0000ba  e8bd81f0          POP      {r4-r8,pc}
;;;4660   
                          ENDP

0000be  0000              DCW      0x0000
                  |L42.192|
                          DCD      ||.data||
                  |L42.196|
                          DCD      ||.bss||
                  |L42.200|
                          DCD      0xe000ed04

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4665   
;;;4666   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4667   	{
000004  461f              MOV      r7,r3
000006  f8dd9020          LDR      r9,[sp,#0x20]
00000a  4692              MOV      r10,r2
00000c  460d              MOV      r5,r1
00000e  0004              MOVS     r4,r0
;;;4668   	TCB_t * pxTCB;
;;;4669   	uint8_t ucOriginalNotifyState;
;;;4670   	BaseType_t xReturn = pdPASS;
000010  f04f0801          MOV      r8,#1
000014  d01a              BEQ      |L43.76|
;;;4671   	UBaseType_t uxSavedInterruptStatus;
;;;4672   
;;;4673   		configASSERT( xTaskToNotify );
;;;4674   
;;;4675   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4676   		maximum	system call (or maximum API call) interrupt priority.
;;;4677   		Interrupts that are	above the maximum system call priority are keep
;;;4678   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4679   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4680   		is defined in FreeRTOSConfig.h then
;;;4681   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4682   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4683   		been assigned a priority above the configured maximum system call
;;;4684   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4685   		from interrupts	that have been assigned a priority at or (logically)
;;;4686   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4687   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4688   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4689   		provided on the following link:
;;;4690   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4691   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000016  f7fffffe          BL       vPortValidateInterruptPriority
00001a  2050              MOVS     r0,#0x50
00001c  f3ef8611          MRS      r6,BASEPRI
000020  f3808811          MSR      BASEPRI,r0
000024  f3bf8f4f          DSB      
000028  f3bf8f6f          ISB      
;;;4692   
;;;4693   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4694   
;;;4695   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;4696   		{
;;;4697   			if( pulPreviousNotificationValue != NULL )
00002c  b10f              CBZ      r7,|L43.50|
;;;4698   			{
;;;4699   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
00002e  6d60              LDR      r0,[r4,#0x54]
000030  6038              STR      r0,[r7,#0]
                  |L43.50|
;;;4700   			}
;;;4701   
;;;4702   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000032  f8940058          LDRB     r0,[r4,#0x58]
;;;4703   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000036  2102              MOVS     r1,#2
000038  f8841058          STRB     r1,[r4,#0x58]
;;;4704   
;;;4705   			switch( eAction )
00003c  f1ba0f05          CMP      r10,#5
000040  d216              BCS      |L43.112|
000042  e8dff00a          TBB      [pc,r10]
000046  150b              DCB      0x15,0x0b
000048  0e141200          DCB      0x0e,0x14,0x12,0x00
                  |L43.76|
00004c  2050              MOVS     r0,#0x50
00004e  f3808811          MSR      BASEPRI,r0
000052  f3bf8f4f          DSB      
000056  f3bf8f6f          ISB      
                  |L43.90|
00005a  e7fe              B        |L43.90|
;;;4706   			{
;;;4707   				case eSetBits	:
;;;4708   					pxTCB->ulNotifiedValue |= ulValue;
00005c  6d61              LDR      r1,[r4,#0x54]
00005e  4329              ORRS     r1,r1,r5
;;;4709   					break;
000060  e001              B        |L43.102|
;;;4710   
;;;4711   				case eIncrement	:
;;;4712   					( pxTCB->ulNotifiedValue )++;
000062  6d61              LDR      r1,[r4,#0x54]
000064  1c49              ADDS     r1,r1,#1
                  |L43.102|
000066  6561              STR      r1,[r4,#0x54]         ;4708
000068  e002              B        |L43.112|
;;;4713   					break;
;;;4714   
;;;4715   				case eSetValueWithOverwrite	:
;;;4716   					pxTCB->ulNotifiedValue = ulValue;
;;;4717   					break;
;;;4718   
;;;4719   				case eSetValueWithoutOverwrite :
;;;4720   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
00006a  2802              CMP      r0,#2
00006c  d003              BEQ      |L43.118|
;;;4721   					{
;;;4722   						pxTCB->ulNotifiedValue = ulValue;
00006e  6565              STR      r5,[r4,#0x54]
                  |L43.112|
;;;4723   					}
;;;4724   					else
;;;4725   					{
;;;4726   						/* The value could not be written to the task. */
;;;4727   						xReturn = pdFAIL;
;;;4728   					}
;;;4729   					break;
;;;4730   
;;;4731   				case eNoAction :
;;;4732   					/* The task is being notified without its notify value being
;;;4733   					updated. */
;;;4734   					break;
;;;4735   			}
;;;4736   
;;;4737   			traceTASK_NOTIFY_FROM_ISR();
;;;4738   
;;;4739   			/* If the task is in the blocked state specifically to wait for a
;;;4740   			notification then unblock it now. */
;;;4741   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000070  2801              CMP      r0,#1
000072  d003              BEQ      |L43.124|
000074  e032              B        |L43.220|
                  |L43.118|
000076  f04f0800          MOV      r8,#0                 ;4727
00007a  e02f              B        |L43.220|
                  |L43.124|
;;;4742   			{
;;;4743   				/* The task should not have been on an event list. */
;;;4744   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
00007c  6aa0              LDR      r0,[r4,#0x28]
00007e  b138              CBZ      r0,|L43.144|
000080  2050              MOVS     r0,#0x50
000082  f3808811          MSR      BASEPRI,r0
000086  f3bf8f4f          DSB      
00008a  f3bf8f6f          ISB      
                  |L43.142|
00008e  e7fe              B        |L43.142|
                  |L43.144|
;;;4745   
;;;4746   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000090  4d15              LDR      r5,|L43.232|
000092  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000094  2701              MOVS     r7,#1                 ;4670
000096  b178              CBZ      r0,|L43.184|
;;;4747   				{
;;;4748   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;4749   					prvAddTaskToReadyList( pxTCB );
;;;4750   				}
;;;4751   				else
;;;4752   				{
;;;4753   					/* The delayed and ready lists cannot be accessed, so hold
;;;4754   					this task pending until the scheduler is resumed. */
;;;4755   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000098  f1040118          ADD      r1,r4,#0x18
00009c  4813              LDR      r0,|L43.236|
                  |L43.158|
00009e  f7fffffe          BL       vListInsertEnd
;;;4756   				}
;;;4757   
;;;4758   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000a2  6ae0              LDR      r0,[r4,#0x2c]
0000a4  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
0000a6  6ac9              LDR      r1,[r1,#0x2c]
0000a8  4288              CMP      r0,r1
0000aa  d917              BLS      |L43.220|
;;;4759   				{
;;;4760   					/* The notified task has a priority above the currently
;;;4761   					executing task so a yield is required. */
;;;4762   					if( pxHigherPriorityTaskWoken != NULL )
0000ac  f1b90f00          CMP      r9,#0
0000b0  d013              BEQ      |L43.218|
;;;4763   					{
;;;4764   						*pxHigherPriorityTaskWoken = pdTRUE;
0000b2  f8c97000          STR      r7,[r9,#0]
0000b6  e011              B        |L43.220|
                  |L43.184|
0000b8  1d20              ADDS     r0,r4,#4              ;4748
0000ba  f7fffffe          BL       uxListRemove
0000be  6ae0              LDR      r0,[r4,#0x2c]         ;4749
0000c0  692a              LDR      r2,[r5,#0x10]         ;4749  ; uxTopReadyPriority
0000c2  fa07f100          LSL      r1,r7,r0              ;4749
0000c6  4311              ORRS     r1,r1,r2              ;4749
0000c8  6129              STR      r1,[r5,#0x10]         ;4749  ; uxTopReadyPriority
0000ca  eb000180          ADD      r1,r0,r0,LSL #2       ;4749
0000ce  4807              LDR      r0,|L43.236|
0000d0  388c              SUBS     r0,r0,#0x8c           ;4749
0000d2  eb000081          ADD      r0,r0,r1,LSL #2       ;4749
0000d6  1d21              ADDS     r1,r4,#4              ;4749
0000d8  e7e1              B        |L43.158|
                  |L43.218|
;;;4765   					}
;;;4766   					else
;;;4767   					{
;;;4768   						/* Mark that a yield is pending in case the user is not
;;;4769   						using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4770   						safe FreeRTOS function. */
;;;4771   						xYieldPending = pdTRUE;
0000da  61ef              STR      r7,[r5,#0x1c]  ; xYieldPending
                  |L43.220|
0000dc  f3868811          MSR      BASEPRI,r6
;;;4772   					}
;;;4773   				}
;;;4774   				else
;;;4775   				{
;;;4776   					mtCOVERAGE_TEST_MARKER();
;;;4777   				}
;;;4778   			}
;;;4779   		}
;;;4780   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;4781   
;;;4782   		return xReturn;
0000e0  4640              MOV      r0,r8
;;;4783   	}
0000e2  e8bd87f0          POP      {r4-r10,pc}
;;;4784   
                          ENDP

0000e6  0000              DCW      0x0000
                  |L43.232|
                          DCD      ||.data||
                  |L43.236|
                          DCD      ||.bss||+0x8c

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3755   
;;;3756   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4801              LDR      r0,|L44.8|
;;;3757   	{
;;;3758   	TaskHandle_t xReturn;
;;;3759   
;;;3760   		/* A critical section is not required as this is not called from
;;;3761   		an interrupt and the current TCB will always be the same for any
;;;3762   		individual execution thread. */
;;;3763   		xReturn = pxCurrentTCB;
000002  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;3764   
;;;3765   		return xReturn;
;;;3766   	}
000004  4770              BX       lr
;;;3767   
                          ENDP

000006  0000              DCW      0x0000
                  |L44.8|
                          DCD      ||.data||

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3772   
;;;3773   	BaseType_t xTaskGetSchedulerState( void )
000000  4805              LDR      r0,|L45.24|
;;;3774   	{
;;;3775   	BaseType_t xReturn;
;;;3776   
;;;3777   		if( xSchedulerRunning == pdFALSE )
000002  6941              LDR      r1,[r0,#0x14]  ; xSchedulerRunning
000004  b119              CBZ      r1,|L45.14|
;;;3778   		{
;;;3779   			xReturn = taskSCHEDULER_NOT_STARTED;
;;;3780   		}
;;;3781   		else
;;;3782   		{
;;;3783   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000006  6b00              LDR      r0,[r0,#0x30]  ; uxSchedulerSuspended
000008  b118              CBZ      r0,|L45.18|
;;;3784   			{
;;;3785   				xReturn = taskSCHEDULER_RUNNING;
;;;3786   			}
;;;3787   			else
;;;3788   			{
;;;3789   				xReturn = taskSCHEDULER_SUSPENDED;
00000a  2000              MOVS     r0,#0
;;;3790   			}
;;;3791   		}
;;;3792   
;;;3793   		return xReturn;
;;;3794   	}
00000c  4770              BX       lr
                  |L45.14|
00000e  2001              MOVS     r0,#1                 ;3779
000010  4770              BX       lr
                  |L45.18|
000012  2002              MOVS     r0,#2                 ;3785
000014  4770              BX       lr
;;;3795   
                          ENDP

000016  0000              DCW      0x0000
                  |L45.24|
                          DCD      ||.data||

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2214   
;;;2215   TickType_t xTaskGetTickCount( void )
000000  4801              LDR      r0,|L46.8|
;;;2216   {
;;;2217   TickType_t xTicks;
;;;2218   
;;;2219   	/* Critical section required if running on a 16 bit processor. */
;;;2220   	portTICK_TYPE_ENTER_CRITICAL();
;;;2221   	{
;;;2222   		xTicks = xTickCount;
000002  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;2223   	}
;;;2224   	portTICK_TYPE_EXIT_CRITICAL();
;;;2225   
;;;2226   	return xTicks;
;;;2227   }
000004  4770              BX       lr
;;;2228   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L46.8|
                          DCD      ||.data||

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2229   
;;;2230   TickType_t xTaskGetTickCountFromISR( void )
000000  b510              PUSH     {r4,lr}
;;;2231   {
;;;2232   TickType_t xReturn;
;;;2233   UBaseType_t uxSavedInterruptStatus;
;;;2234   
;;;2235   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2236   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2237   	above the maximum system call priority are kept permanently enabled, even
;;;2238   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2239   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2240   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2241   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2242   	assigned a priority above the configured maximum system call priority.
;;;2243   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2244   	that have been assigned a priority at or (logically) below the maximum
;;;2245   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2246   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2247   	More information (albeit Cortex-M specific) is provided on the following
;;;2248   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2249   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000002  f7fffffe          BL       vPortValidateInterruptPriority
;;;2250   
;;;2251   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;2252   	{
;;;2253   		xReturn = xTickCount;
000006  4801              LDR      r0,|L47.12|
000008  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;2254   	}
;;;2255   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2256   
;;;2257   	return xReturn;
;;;2258   }
00000a  bd10              POP      {r4,pc}
;;;2259   /*-----------------------------------------------------------*/
                          ENDP

                  |L47.12|
                          DCD      ||.data||

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;2588   
;;;2589   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2590   {
;;;2591   TCB_t * pxTCB;
;;;2592   TickType_t xItemValue;
;;;2593   BaseType_t xSwitchRequired = pdFALSE;
;;;2594   
;;;2595   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2596   	Increments the tick then checks to see if the new tick value will cause any
;;;2597   	tasks to be unblocked. */
;;;2598   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2599   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000004  4f31              LDR      r7,|L48.204|
000006  2600              MOVS     r6,#0                 ;2593
000008  6b38              LDR      r0,[r7,#0x30]  ; uxSchedulerSuspended
00000a  b118              CBZ      r0,|L48.20|
;;;2600   	{
;;;2601   		/* Minor optimisation.  The tick count cannot change in this
;;;2602   		block. */
;;;2603   		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
;;;2604   
;;;2605   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2606   		delayed lists if it wraps to 0. */
;;;2607   		xTickCount = xConstTickCount;
;;;2608   
;;;2609   		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
;;;2610   		{
;;;2611   			taskSWITCH_DELAYED_LISTS();
;;;2612   		}
;;;2613   		else
;;;2614   		{
;;;2615   			mtCOVERAGE_TEST_MARKER();
;;;2616   		}
;;;2617   
;;;2618   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2619   		the	queue in the order of their wake time - meaning once one task
;;;2620   		has been found whose block time has not expired there is no need to
;;;2621   		look any further down the list. */
;;;2622   		if( xConstTickCount >= xNextTaskUnblockTime )
;;;2623   		{
;;;2624   			for( ;; )
;;;2625   			{
;;;2626   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
;;;2627   				{
;;;2628   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2629   					to the maximum possible value so it is extremely
;;;2630   					unlikely that the
;;;2631   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2632   					next time through. */
;;;2633   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;2634   					break;
;;;2635   				}
;;;2636   				else
;;;2637   				{
;;;2638   					/* The delayed list is not empty, get the value of the
;;;2639   					item at the head of the delayed list.  This is the time
;;;2640   					at which the task at the head of the delayed list must
;;;2641   					be removed from the Blocked state. */
;;;2642   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
;;;2643   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
;;;2644   
;;;2645   					if( xConstTickCount < xItemValue )
;;;2646   					{
;;;2647   						/* It is not time to unblock this item yet, but the
;;;2648   						item value is the time at which the task at the head
;;;2649   						of the blocked list must be removed from the Blocked
;;;2650   						state -	so record the item value in
;;;2651   						xNextTaskUnblockTime. */
;;;2652   						xNextTaskUnblockTime = xItemValue;
;;;2653   						break;
;;;2654   					}
;;;2655   					else
;;;2656   					{
;;;2657   						mtCOVERAGE_TEST_MARKER();
;;;2658   					}
;;;2659   
;;;2660   					/* It is time to remove the item from the Blocked state. */
;;;2661   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;2662   
;;;2663   					/* Is the task waiting on an event also?  If so remove
;;;2664   					it from the event list. */
;;;2665   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
;;;2666   					{
;;;2667   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2668   					}
;;;2669   					else
;;;2670   					{
;;;2671   						mtCOVERAGE_TEST_MARKER();
;;;2672   					}
;;;2673   
;;;2674   					/* Place the unblocked task into the appropriate ready
;;;2675   					list. */
;;;2676   					prvAddTaskToReadyList( pxTCB );
;;;2677   
;;;2678   					/* A task being unblocked cannot cause an immediate
;;;2679   					context switch if preemption is turned off. */
;;;2680   					#if (  configUSE_PREEMPTION == 1 )
;;;2681   					{
;;;2682   						/* Preemption is on, but a context switch should
;;;2683   						only be performed if the unblocked task has a
;;;2684   						priority that is equal to or higher than the
;;;2685   						currently executing task. */
;;;2686   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;2687   						{
;;;2688   							xSwitchRequired = pdTRUE;
;;;2689   						}
;;;2690   						else
;;;2691   						{
;;;2692   							mtCOVERAGE_TEST_MARKER();
;;;2693   						}
;;;2694   					}
;;;2695   					#endif /* configUSE_PREEMPTION */
;;;2696   				}
;;;2697   			}
;;;2698   		}
;;;2699   
;;;2700   		/* Tasks of equal priority to the currently running task will share
;;;2701   		processing time (time slice) if preemption is on, and the application
;;;2702   		writer has not explicitly turned time slicing off. */
;;;2703   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2704   		{
;;;2705   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
;;;2706   			{
;;;2707   				xSwitchRequired = pdTRUE;
;;;2708   			}
;;;2709   			else
;;;2710   			{
;;;2711   				mtCOVERAGE_TEST_MARKER();
;;;2712   			}
;;;2713   		}
;;;2714   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2715   
;;;2716   		#if ( configUSE_TICK_HOOK == 1 )
;;;2717   		{
;;;2718   			/* Guard against the tick hook being called when the pended tick
;;;2719   			count is being unwound (when the scheduler is being unlocked). */
;;;2720   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2721   			{
;;;2722   				vApplicationTickHook();
;;;2723   			}
;;;2724   			else
;;;2725   			{
;;;2726   				mtCOVERAGE_TEST_MARKER();
;;;2727   			}
;;;2728   		}
;;;2729   		#endif /* configUSE_TICK_HOOK */
;;;2730   	}
;;;2731   	else
;;;2732   	{
;;;2733   		++uxPendedTicks;
00000c  69b8              LDR      r0,[r7,#0x18]  ; uxPendedTicks
00000e  1c40              ADDS     r0,r0,#1
000010  61b8              STR      r0,[r7,#0x18]  ; uxPendedTicks
;;;2734   
;;;2735   		/* The tick hook gets called at regular intervals, even if the
;;;2736   		scheduler is locked. */
;;;2737   		#if ( configUSE_TICK_HOOK == 1 )
;;;2738   		{
;;;2739   			vApplicationTickHook();
000012  e052              B        |L48.186|
                  |L48.20|
000014  68fd              LDR      r5,[r7,#0xc]          ;2603  ; xTickCount
000016  1c6d              ADDS     r5,r5,#1              ;2603
000018  60fd              STR      r5,[r7,#0xc]          ;2607  ; xTickCount
00001a  d113              BNE      |L48.68|
00001c  6b78              LDR      r0,[r7,#0x34]         ;2611  ; pxDelayedTaskList
00001e  6800              LDR      r0,[r0,#0]            ;2611
000020  b138              CBZ      r0,|L48.50|
000022  2050              MOVS     r0,#0x50              ;2611
000024  f3808811          MSR      BASEPRI,r0            ;2611
000028  f3bf8f4f          DSB                            ;2611
00002c  f3bf8f6f          ISB                            ;2611
                  |L48.48|
000030  e7fe              B        |L48.48|
                  |L48.50|
000032  6b78              LDR      r0,[r7,#0x34]         ;2611  ; pxDelayedTaskList
000034  6bb9              LDR      r1,[r7,#0x38]         ;2611  ; pxOverflowDelayedTaskList
000036  6379              STR      r1,[r7,#0x34]         ;2611  ; pxDelayedTaskList
000038  63b8              STR      r0,[r7,#0x38]         ;2611  ; pxOverflowDelayedTaskList
00003a  6a38              LDR      r0,[r7,#0x20]         ;2611  ; xNumOfOverflows
00003c  1c40              ADDS     r0,r0,#1              ;2611
00003e  6238              STR      r0,[r7,#0x20]         ;2611  ; xNumOfOverflows
000040  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L48.68|
000044  6ab8              LDR      r0,[r7,#0x28]         ;2622  ; xNextTaskUnblockTime
000046  f8df8088          LDR      r8,|L48.208|
00004a  4285              CMP      r5,r0                 ;2622
00004c  d309              BCC      |L48.98|
                  |L48.78|
00004e  6b78              LDR      r0,[r7,#0x34]         ;2626  ; pxDelayedTaskList
000050  6800              LDR      r0,[r0,#0]            ;2626
000052  b190              CBZ      r0,|L48.122|
000054  6b78              LDR      r0,[r7,#0x34]         ;2642  ; pxDelayedTaskList
000056  68c0              LDR      r0,[r0,#0xc]          ;2642
000058  68c4              LDR      r4,[r0,#0xc]          ;2643
00005a  6860              LDR      r0,[r4,#4]            ;2645
00005c  4285              CMP      r5,r0                 ;2645
00005e  d20f              BCS      |L48.128|
                  |L48.96|
000060  62b8              STR      r0,[r7,#0x28]         ;2652  ; xNextTaskUnblockTime
                  |L48.98|
000062  6838              LDR      r0,[r7,#0]            ;2705  ; pxCurrentTCB
000064  6ac0              LDR      r0,[r0,#0x2c]         ;2705
000066  eb000180          ADD      r1,r0,r0,LSL #2       ;2705
00006a  f8580021          LDR      r0,[r8,r1,LSL #2]     ;2705
00006e  2801              CMP      r0,#1                 ;2705
000070  d900              BLS      |L48.116|
000072  2601              MOVS     r6,#1                 ;2707
                  |L48.116|
000074  69b8              LDR      r0,[r7,#0x18]         ;2720  ; uxPendedTicks
000076  b300              CBZ      r0,|L48.186|
000078  e021              B        |L48.190|
                  |L48.122|
00007a  f04f30ff          MOV      r0,#0xffffffff        ;2633
00007e  e7ef              B        |L48.96|
                  |L48.128|
000080  1d20              ADDS     r0,r4,#4              ;2661
000082  f7fffffe          BL       uxListRemove
000086  6aa0              LDR      r0,[r4,#0x28]         ;2665
000088  b118              CBZ      r0,|L48.146|
00008a  f1040018          ADD      r0,r4,#0x18           ;2667
00008e  f7fffffe          BL       uxListRemove
                  |L48.146|
000092  6ae0              LDR      r0,[r4,#0x2c]         ;2676
000094  2101              MOVS     r1,#1                 ;2676
000096  693a              LDR      r2,[r7,#0x10]         ;2676  ; uxTopReadyPriority
000098  4081              LSLS     r1,r1,r0              ;2676
00009a  4311              ORRS     r1,r1,r2              ;2676
00009c  6139              STR      r1,[r7,#0x10]         ;2676  ; uxTopReadyPriority
00009e  eb000180          ADD      r1,r0,r0,LSL #2       ;2676
0000a2  eb080081          ADD      r0,r8,r1,LSL #2       ;2676
0000a6  1d21              ADDS     r1,r4,#4              ;2676
0000a8  f7fffffe          BL       vListInsertEnd
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;2686
0000ae  6839              LDR      r1,[r7,#0]            ;2686  ; pxCurrentTCB
0000b0  6ac9              LDR      r1,[r1,#0x2c]         ;2686
0000b2  4288              CMP      r0,r1                 ;2686
0000b4  d3cb              BCC      |L48.78|
0000b6  2601              MOVS     r6,#1                 ;2688
0000b8  e7c9              B        |L48.78|
                  |L48.186|
0000ba  f7fffffe          BL       vApplicationTickHook
                  |L48.190|
;;;2740   		}
;;;2741   		#endif
;;;2742   	}
;;;2743   
;;;2744   	#if ( configUSE_PREEMPTION == 1 )
;;;2745   	{
;;;2746   		if( xYieldPending != pdFALSE )
0000be  69f8              LDR      r0,[r7,#0x1c]  ; xYieldPending
0000c0  b100              CBZ      r0,|L48.196|
;;;2747   		{
;;;2748   			xSwitchRequired = pdTRUE;
0000c2  2601              MOVS     r6,#1
                  |L48.196|
;;;2749   		}
;;;2750   		else
;;;2751   		{
;;;2752   			mtCOVERAGE_TEST_MARKER();
;;;2753   		}
;;;2754   	}
;;;2755   	#endif /* configUSE_PREEMPTION */
;;;2756   
;;;2757   	return xSwitchRequired;
0000c4  4630              MOV      r0,r6
;;;2758   }
0000c6  e8bd81f0          POP      {r4-r8,pc}
;;;2759   /*-----------------------------------------------------------*/
                          ENDP

0000ca  0000              DCW      0x0000
                  |L48.204|
                          DCD      ||.data||
                  |L48.208|
                          DCD      ||.bss||

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;4878   
;;;4879   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;4880   	{
000002  b158              CBZ      r0,|L49.28|
;;;4881   	TCB_t *pxTCB;
;;;4882   	BaseType_t xReturn;
;;;4883   
;;;4884   		/* If null is passed in here then it is the calling task that is having
;;;4885   		its notification state cleared. */
;;;4886   		pxTCB = prvGetTCBFromHandle( xTask );
000004  4604              MOV      r4,r0
                  |L49.6|
;;;4887   
;;;4888   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4889   		{
;;;4890   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
00000a  f8940058          LDRB     r0,[r4,#0x58]
00000e  2802              CMP      r0,#2
000010  d007              BEQ      |L49.34|
;;;4891   			{
;;;4892   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
;;;4893   				xReturn = pdPASS;
;;;4894   			}
;;;4895   			else
;;;4896   			{
;;;4897   				xReturn = pdFAIL;
000012  2400              MOVS     r4,#0
                  |L49.20|
;;;4898   			}
;;;4899   		}
;;;4900   		taskEXIT_CRITICAL();
000014  f7fffffe          BL       vPortExitCritical
;;;4901   
;;;4902   		return xReturn;
000018  4620              MOV      r0,r4
;;;4903   	}
00001a  bd10              POP      {r4,pc}
                  |L49.28|
00001c  4803              LDR      r0,|L49.44|
00001e  6804              LDR      r4,[r0,#0]            ;4886  ; pxCurrentTCB
000020  e7f1              B        |L49.6|
                  |L49.34|
000022  2000              MOVS     r0,#0                 ;4892
000024  f8840058          STRB     r0,[r4,#0x58]         ;4892
000028  2401              MOVS     r4,#1                 ;4893
00002a  e7f3              B        |L49.20|
;;;4904   
                          ENDP

                  |L49.44|
                          DCD      ||.data||

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4479   
;;;4480   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4481   	{
000004  461e              MOV      r6,r3
000006  4615              MOV      r5,r2
000008  4688              MOV      r8,r1
00000a  4607              MOV      r7,r0
;;;4482   	BaseType_t xReturn;
;;;4483   
;;;4484   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;4485   		{
;;;4486   			/* Only block if a notification is not already pending. */
;;;4487   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000010  4c1c              LDR      r4,|L50.132|
000012  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000014  f8900058          LDRB     r0,[r0,#0x58]
000018  2802              CMP      r0,#2
00001a  d014              BEQ      |L50.70|
;;;4488   			{
;;;4489   				/* Clear bits in the task's notification value as bits may get
;;;4490   				set	by the notifying task or interrupt.  This can be used to
;;;4491   				clear the value to zero. */
;;;4492   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001c  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00001e  6d41              LDR      r1,[r0,#0x54]
000020  43b9              BICS     r1,r1,r7
000022  6541              STR      r1,[r0,#0x54]
;;;4493   
;;;4494   				/* Mark this task as waiting for a notification. */
;;;4495   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000024  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000026  2001              MOVS     r0,#1
000028  f8810058          STRB     r0,[r1,#0x58]
;;;4496   
;;;4497   				if( xTicksToWait > ( TickType_t ) 0 )
00002c  b15e              CBZ      r6,|L50.70|
;;;4498   				{
;;;4499   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00002e  2101              MOVS     r1,#1
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4500   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4501   
;;;4502   					/* All ports are written to allow a yield in a critical
;;;4503   					section (some will yield immediately, others wait until the
;;;4504   					critical section exits) - but it is not something that
;;;4505   					application code should ever do. */
;;;4506   					portYIELD_WITHIN_API();
000036  4914              LDR      r1,|L50.136|
000038  f04f5080          MOV      r0,#0x10000000
00003c  6008              STR      r0,[r1,#0]
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
                  |L50.70|
;;;4507   				}
;;;4508   				else
;;;4509   				{
;;;4510   					mtCOVERAGE_TEST_MARKER();
;;;4511   				}
;;;4512   			}
;;;4513   			else
;;;4514   			{
;;;4515   				mtCOVERAGE_TEST_MARKER();
;;;4516   			}
;;;4517   		}
;;;4518   		taskEXIT_CRITICAL();
000046  f7fffffe          BL       vPortExitCritical
;;;4519   
;;;4520   		taskENTER_CRITICAL();
00004a  f7fffffe          BL       vPortEnterCritical
;;;4521   		{
;;;4522   			traceTASK_NOTIFY_WAIT();
;;;4523   
;;;4524   			if( pulNotificationValue != NULL )
00004e  b115              CBZ      r5,|L50.86|
;;;4525   			{
;;;4526   				/* Output the current notification value, which may or may not
;;;4527   				have changed. */
;;;4528   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000050  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000052  6d40              LDR      r0,[r0,#0x54]
000054  6028              STR      r0,[r5,#0]
                  |L50.86|
;;;4529   			}
;;;4530   
;;;4531   			/* If ucNotifyValue is set then either the task never entered the
;;;4532   			blocked state (because a notification was already pending) or the
;;;4533   			task unblocked because of a notification.  Otherwise the task
;;;4534   			unblocked because of a timeout. */
;;;4535   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000056  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000058  f8900058          LDRB     r0,[r0,#0x58]
00005c  2802              CMP      r0,#2
00005e  d001              BEQ      |L50.100|
;;;4536   			{
;;;4537   				/* A notification was not received. */
;;;4538   				xReturn = pdFALSE;
000060  2500              MOVS     r5,#0
000062  e005              B        |L50.112|
                  |L50.100|
;;;4539   			}
;;;4540   			else
;;;4541   			{
;;;4542   				/* A notification was already pending or a notification was
;;;4543   				received while the task was waiting. */
;;;4544   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000064  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000066  6d41              LDR      r1,[r0,#0x54]
000068  ea210108          BIC      r1,r1,r8
00006c  6541              STR      r1,[r0,#0x54]
;;;4545   				xReturn = pdTRUE;
00006e  2501              MOVS     r5,#1
                  |L50.112|
;;;4546   			}
;;;4547   
;;;4548   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000070  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000072  2000              MOVS     r0,#0
000074  f8810058          STRB     r0,[r1,#0x58]
;;;4549   		}
;;;4550   		taskEXIT_CRITICAL();
000078  f7fffffe          BL       vPortExitCritical
;;;4551   
;;;4552   		return xReturn;
00007c  4628              MOV      r0,r5
;;;4553   	}
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;4554   
                          ENDP

000082  0000              DCW      0x0000
                  |L50.132|
                          DCD      ||.data||
                  |L50.136|
                          DCD      0xe000ed04

                          AREA ||i.xTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityDisinherit PROC
;;;3887   
;;;3888   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3889   	{
000002  0004              MOVS     r4,r0
;;;3890   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
;;;3891   	BaseType_t xReturn = pdFALSE;
000004  f04f0000          MOV      r0,#0
000008  d041              BEQ      |L51.142|
;;;3892   
;;;3893   		if( pxMutexHolder != NULL )
;;;3894   		{
;;;3895   			/* A task can only have an inherited priority if it holds the mutex.
;;;3896   			If the mutex is held by a task then it cannot be given from an
;;;3897   			interrupt, and if a mutex is given by the holding task then it must
;;;3898   			be the running state task. */
;;;3899   			configASSERT( pxTCB == pxCurrentTCB );
00000a  4d21              LDR      r5,|L51.144|
00000c  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00000e  428c              CMP      r4,r1
000010  d007              BEQ      |L51.34|
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L51.32|
000020  e7fe              B        |L51.32|
                  |L51.34|
;;;3900   			configASSERT( pxTCB->uxMutexesHeld );
000022  6d21              LDR      r1,[r4,#0x50]
000024  b171              CBZ      r1,|L51.68|
000026  1e49              SUBS     r1,r1,#1
;;;3901   			( pxTCB->uxMutexesHeld )--;
;;;3902   
;;;3903   			/* Has the holder of the mutex inherited the priority of another
;;;3904   			task? */
;;;3905   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000028  6521              STR      r1,[r4,#0x50]
00002a  6ce3              LDR      r3,[r4,#0x4c]
00002c  6ae2              LDR      r2,[r4,#0x2c]
00002e  429a              CMP      r2,r3
000030  d02d              BEQ      |L51.142|
;;;3906   			{
;;;3907   				/* Only disinherit if no other mutexes are held. */
;;;3908   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
000032  2900              CMP      r1,#0
000034  d12b              BNE      |L51.142|
;;;3909   				{
;;;3910   					/* A task can only have an inherited priority if it holds
;;;3911   					the mutex.  If the mutex is held by a task then it cannot be
;;;3912   					given from an interrupt, and if a mutex is given by the
;;;3913   					holding task then it must be the running state task.  Remove
;;;3914   					the holding task from the ready list. */
;;;3915   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000036  1d20              ADDS     r0,r4,#4
000038  f7fffffe          BL       uxListRemove
;;;3916   					{
;;;3917   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00003c  4915              LDR      r1,|L51.148|
00003e  2201              MOVS     r2,#1
000040  b140              CBZ      r0,|L51.84|
000042  e012              B        |L51.106|
                  |L51.68|
000044  2050              MOVS     r0,#0x50              ;3915
000046  f3808811          MSR      BASEPRI,r0            ;3915
00004a  f3bf8f4f          DSB                            ;3915
00004e  f3bf8f6f          ISB                            ;3915
                  |L51.82|
000052  e7fe              B        |L51.82|
                  |L51.84|
000054  6ae0              LDR      r0,[r4,#0x2c]
000056  eb000380          ADD      r3,r0,r0,LSL #2
00005a  f8513023          LDR      r3,[r1,r3,LSL #2]
00005e  b923              CBNZ     r3,|L51.106|
000060  692b              LDR      r3,[r5,#0x10]  ; uxTopReadyPriority
000062  fa02f000          LSL      r0,r2,r0
000066  4383              BICS     r3,r3,r0
000068  612b              STR      r3,[r5,#0x10]  ; uxTopReadyPriority
                  |L51.106|
;;;3918   					}
;;;3919   					else
;;;3920   					{
;;;3921   						mtCOVERAGE_TEST_MARKER();
;;;3922   					}
;;;3923   
;;;3924   					/* Disinherit the priority before adding the task into the
;;;3925   					new	ready list. */
;;;3926   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3927   					pxTCB->uxPriority = pxTCB->uxBasePriority;
00006a  6ce0              LDR      r0,[r4,#0x4c]
;;;3928   
;;;3929   					/* Reset the event list item value.  It cannot be in use for
;;;3930   					any other purpose if this task is running, and it must be
;;;3931   					running to give back the mutex. */
;;;3932   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00006c  62e0              STR      r0,[r4,#0x2c]
00006e  f1c00005          RSB      r0,r0,#5
;;;3933   					prvAddTaskToReadyList( pxTCB );
000072  61a0              STR      r0,[r4,#0x18]
000074  6ae0              LDR      r0,[r4,#0x2c]
000076  692b              LDR      r3,[r5,#0x10]  ; uxTopReadyPriority
000078  4082              LSLS     r2,r2,r0
00007a  431a              ORRS     r2,r2,r3
00007c  612a              STR      r2,[r5,#0x10]  ; uxTopReadyPriority
00007e  eb000080          ADD      r0,r0,r0,LSL #2
000082  eb010080          ADD      r0,r1,r0,LSL #2
000086  1d21              ADDS     r1,r4,#4
000088  f7fffffe          BL       vListInsertEnd
;;;3934   
;;;3935   					/* Return true to indicate that a context switch is required.
;;;3936   					This is only actually required in the corner case whereby
;;;3937   					multiple mutexes were held and the mutexes were given back
;;;3938   					in an order different to that in which they were taken.
;;;3939   					If a context switch did not occur when the first mutex was
;;;3940   					returned, even if a task was waiting on it, then a context
;;;3941   					switch should occur when the last mutex is returned whether
;;;3942   					a task is waiting on it or not. */
;;;3943   					xReturn = pdTRUE;
00008c  2001              MOVS     r0,#1
                  |L51.142|
;;;3944   				}
;;;3945   				else
;;;3946   				{
;;;3947   					mtCOVERAGE_TEST_MARKER();
;;;3948   				}
;;;3949   			}
;;;3950   			else
;;;3951   			{
;;;3952   				mtCOVERAGE_TEST_MARKER();
;;;3953   			}
;;;3954   		}
;;;3955   		else
;;;3956   		{
;;;3957   			mtCOVERAGE_TEST_MARKER();
;;;3958   		}
;;;3959   
;;;3960   		return xReturn;
;;;3961   	}
00008e  bd70              POP      {r4-r6,pc}
;;;3962   
                          ENDP

                  |L51.144|
                          DCD      ||.data||
                  |L51.148|
                          DCD      ||.bss||

                          AREA ||i.xTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityInherit PROC
;;;3800   
;;;3801   	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3802   	{
000002  0004              MOVS     r4,r0
;;;3803   	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
;;;3804   	BaseType_t xReturn = pdFALSE;
000004  f04f0000          MOV      r0,#0
000008  d039              BEQ      |L52.126|
;;;3805   
;;;3806   		/* If the mutex was given back by an interrupt while the queue was
;;;3807   		locked then the mutex holder might now be NULL.  _RB_ Is this still
;;;3808   		needed as interrupts can no longer use mutexes? */
;;;3809   		if( pxMutexHolder != NULL )
;;;3810   		{
;;;3811   			/* If the holder of the mutex has a priority below the priority of
;;;3812   			the task attempting to obtain the mutex then it will temporarily
;;;3813   			inherit the priority of the task attempting to obtain the mutex. */
;;;3814   			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
00000a  4d20              LDR      r5,|L52.140|
00000c  6ae1              LDR      r1,[r4,#0x2c]
00000e  682a              LDR      r2,[r5,#0]  ; pxCurrentTCB
000010  6ad2              LDR      r2,[r2,#0x2c]
000012  4291              CMP      r1,r2
000014  d234              BCS      |L52.128|
;;;3815   			{
;;;3816   				/* Adjust the mutex holder state to account for its new
;;;3817   				priority.  Only reset the event list item value if the value is
;;;3818   				not being used for anything else. */
;;;3819   				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000016  69a0              LDR      r0,[r4,#0x18]
000018  2800              CMP      r0,#0
00001a  db04              BLT      |L52.38|
;;;3820   				{
;;;3821   					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00001c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00001e  6ac0              LDR      r0,[r0,#0x2c]
000020  f1c00005          RSB      r0,r0,#5
000024  61a0              STR      r0,[r4,#0x18]
                  |L52.38|
;;;3822   				}
;;;3823   				else
;;;3824   				{
;;;3825   					mtCOVERAGE_TEST_MARKER();
;;;3826   				}
;;;3827   
;;;3828   				/* If the task being modified is in the ready state it will need
;;;3829   				to be moved into a new list. */
;;;3830   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
000026  6ae0              LDR      r0,[r4,#0x2c]
000028  4e19              LDR      r6,|L52.144|
00002a  eb000080          ADD      r0,r0,r0,LSL #2
00002e  6961              LDR      r1,[r4,#0x14]
000030  eb060080          ADD      r0,r6,r0,LSL #2
000034  4281              CMP      r1,r0
000036  d11e              BNE      |L52.118|
;;;3831   				{
;;;3832   					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000038  1d20              ADDS     r0,r4,#4
00003a  f7fffffe          BL       uxListRemove
;;;3833   					{
;;;3834   						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
00003e  2101              MOVS     r1,#1
000040  b950              CBNZ     r0,|L52.88|
000042  6ae0              LDR      r0,[r4,#0x2c]
000044  eb000280          ADD      r2,r0,r0,LSL #2
000048  f8562022          LDR      r2,[r6,r2,LSL #2]
00004c  b922              CBNZ     r2,|L52.88|
00004e  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000050  fa01f000          LSL      r0,r1,r0
000054  4382              BICS     r2,r2,r0
000056  612a              STR      r2,[r5,#0x10]  ; uxTopReadyPriority
                  |L52.88|
;;;3835   					}
;;;3836   					else
;;;3837   					{
;;;3838   						mtCOVERAGE_TEST_MARKER();
;;;3839   					}
;;;3840   
;;;3841   					/* Inherit the priority before being moved into the new list. */
;;;3842   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
000058  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00005a  6ac0              LDR      r0,[r0,#0x2c]
;;;3843   					prvAddTaskToReadyList( pxMutexHolderTCB );
00005c  62e0              STR      r0,[r4,#0x2c]
00005e  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000060  4081              LSLS     r1,r1,r0
000062  4311              ORRS     r1,r1,r2
000064  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000066  eb000080          ADD      r0,r0,r0,LSL #2
00006a  eb060080          ADD      r0,r6,r0,LSL #2
00006e  1d21              ADDS     r1,r4,#4
000070  f7fffffe          BL       vListInsertEnd
000074  e002              B        |L52.124|
                  |L52.118|
;;;3844   				}
;;;3845   				else
;;;3846   				{
;;;3847   					/* Just inherit the priority. */
;;;3848   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
000076  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000078  6ac0              LDR      r0,[r0,#0x2c]
00007a  62e0              STR      r0,[r4,#0x2c]
                  |L52.124|
;;;3849   				}
;;;3850   
;;;3851   				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
;;;3852   
;;;3853   				/* Inheritance occurred. */
;;;3854   				xReturn = pdTRUE;
00007c  2001              MOVS     r0,#1
                  |L52.126|
;;;3855   			}
;;;3856   			else
;;;3857   			{
;;;3858   				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
;;;3859   				{
;;;3860   					/* The base priority of the mutex holder is lower than the
;;;3861   					priority of the task attempting to take the mutex, but the
;;;3862   					current priority of the mutex holder is not lower than the
;;;3863   					priority of the task attempting to take the mutex.
;;;3864   					Therefore the mutex holder must have already inherited a
;;;3865   					priority, but inheritance would have occurred if that had
;;;3866   					not been the case. */
;;;3867   					xReturn = pdTRUE;
;;;3868   				}
;;;3869   				else
;;;3870   				{
;;;3871   					mtCOVERAGE_TEST_MARKER();
;;;3872   				}
;;;3873   			}
;;;3874   		}
;;;3875   		else
;;;3876   		{
;;;3877   			mtCOVERAGE_TEST_MARKER();
;;;3878   		}
;;;3879   
;;;3880   		return xReturn;
;;;3881   	}
00007e  bd70              POP      {r4-r6,pc}
                  |L52.128|
000080  6ce1              LDR      r1,[r4,#0x4c]         ;3858
000082  682a              LDR      r2,[r5,#0]            ;3858  ; pxCurrentTCB
000084  6ad2              LDR      r2,[r2,#0x2c]         ;3858
000086  4291              CMP      r1,r2                 ;3858
000088  d3f8              BCC      |L52.124|
00008a  bd70              POP      {r4-r6,pc}
;;;3882   
                          ENDP

                  |L52.140|
                          DCD      ||.data||
                  |L52.144|
                          DCD      ||.bss||

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;2983   
;;;2984   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2985   {
;;;2986   TCB_t *pxUnblockedTCB;
;;;2987   BaseType_t xReturn;
;;;2988   
;;;2989   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2990   	called from a critical section within an ISR. */
;;;2991   
;;;2992   	/* The event list is sorted in priority order, so the first in the list can
;;;2993   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2994   	the delayed list, and add it to the ready list.
;;;2995   
;;;2996   	If an event is for a queue that is locked then this function will never
;;;2997   	get called - the lock count on the queue will get modified instead.  This
;;;2998   	means exclusive access to the event list is guaranteed here.
;;;2999   
;;;3000   	This function assumes that a check has already been made to ensure that
;;;3001   	pxEventList is not empty. */
;;;3002   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000004  68c0              LDR      r0,[r0,#0xc]
000006  68c4              LDR      r4,[r0,#0xc]          ;2985
000008  b1ac              CBZ      r4,|L53.54|
;;;3003   	configASSERT( pxUnblockedTCB );
;;;3004   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
00000a  f1040018          ADD      r0,r4,#0x18
00000e  4607              MOV      r7,r0
000010  f7fffffe          BL       uxListRemove
;;;3005   
;;;3006   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000014  4d15              LDR      r5,|L53.108|
000016  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
;;;3007   	{
;;;3008   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
;;;3009   		prvAddTaskToReadyList( pxUnblockedTCB );
000018  2601              MOVS     r6,#1
00001a  b1a0              CBZ      r0,|L53.70|
00001c  4639              MOV      r1,r7                 ;3006
;;;3010   	}
;;;3011   	else
;;;3012   	{
;;;3013   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;3014   		pending until the scheduler is resumed. */
;;;3015   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00001e  4814              LDR      r0,|L53.112|
                  |L53.32|
000020  f7fffffe          BL       vListInsertEnd
;;;3016   	}
;;;3017   
;;;3018   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000028  6ac9              LDR      r1,[r1,#0x2c]
00002a  4288              CMP      r0,r1
00002c  d91c              BLS      |L53.104|
;;;3019   	{
;;;3020   		/* Return true if the task removed from the event list has a higher
;;;3021   		priority than the calling task.  This allows the calling task to know if
;;;3022   		it should force a context switch now. */
;;;3023   		xReturn = pdTRUE;
00002e  2001              MOVS     r0,#1
;;;3024   
;;;3025   		/* Mark that a yield is pending in case the user is not using the
;;;3026   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;3027   		xYieldPending = pdTRUE;
000030  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L53.50|
;;;3028   	}
;;;3029   	else
;;;3030   	{
;;;3031   		xReturn = pdFALSE;
;;;3032   	}
;;;3033   
;;;3034   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;3035   	{
;;;3036   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;3037   		might be set to the blocked task's time out time.  If the task is
;;;3038   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;3039   		normally left unchanged, because it is automatically reset to a new
;;;3040   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;3041   		tickless idling is used it might be more important to enter sleep mode
;;;3042   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;3043   		ensure it is updated at the earliest possible time. */
;;;3044   		prvResetNextTaskUnblockTime();
;;;3045   	}
;;;3046   	#endif
;;;3047   
;;;3048   	return xReturn;
;;;3049   }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L53.54|
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
                  |L53.68|
000044  e7fe              B        |L53.68|
                  |L53.70|
000046  1d20              ADDS     r0,r4,#4              ;3008
000048  f7fffffe          BL       uxListRemove
00004c  6ae0              LDR      r0,[r4,#0x2c]         ;3009
00004e  692a              LDR      r2,[r5,#0x10]         ;3009  ; uxTopReadyPriority
000050  fa06f100          LSL      r1,r6,r0              ;3009
000054  4311              ORRS     r1,r1,r2              ;3009
000056  6129              STR      r1,[r5,#0x10]         ;3009  ; uxTopReadyPriority
000058  4905              LDR      r1,|L53.112|
00005a  eb000080          ADD      r0,r0,r0,LSL #2       ;3009
00005e  398c              SUBS     r1,r1,#0x8c           ;3009
000060  eb010080          ADD      r0,r1,r0,LSL #2       ;3009
000064  1d21              ADDS     r1,r4,#4              ;3009
000066  e7db              B        |L53.32|
                  |L53.104|
000068  2000              MOVS     r0,#0                 ;3031
00006a  e7e2              B        |L53.50|
;;;3050   /*-----------------------------------------------------------*/
                          ENDP

                  |L53.108|
                          DCD      ||.data||
                  |L53.112|
                          DCD      ||.bss||+0x8c

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;2104   
;;;2105   BaseType_t xTaskResumeAll( void )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2106   {
;;;2107   TCB_t *pxTCB = NULL;
;;;2108   BaseType_t xAlreadyYielded = pdFALSE;
;;;2109   
;;;2110   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2111   	previous call to vTaskSuspendAll(). */
;;;2112   	configASSERT( uxSchedulerSuspended );
000004  4d2c              LDR      r5,|L54.184|
000006  2400              MOVS     r4,#0                 ;2107
000008  4627              MOV      r7,r4                 ;2108
00000a  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00000c  b138              CBZ      r0,|L54.30|
;;;2113   
;;;2114   	/* It is possible that an ISR caused a task to be removed from an event
;;;2115   	list while the scheduler was suspended.  If this was the case then the
;;;2116   	removed task will have been added to the xPendingReadyList.  Once the
;;;2117   	scheduler has been resumed it is safe to move all the pending ready
;;;2118   	tasks from this list into their appropriate ready list. */
;;;2119   	taskENTER_CRITICAL();
00000e  f7fffffe          BL       vPortEnterCritical
;;;2120   	{
;;;2121   		--uxSchedulerSuspended;
000012  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000014  1e40              SUBS     r0,r0,#1
000016  6328              STR      r0,[r5,#0x30]  ; uxSchedulerSuspended
;;;2122   
;;;2123   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000018  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00001a  b140              CBZ      r0,|L54.46|
00001c  e046              B        |L54.172|
                  |L54.30|
00001e  2050              MOVS     r0,#0x50
000020  f3808811          MSR      BASEPRI,r0
000024  f3bf8f4f          DSB      
000028  f3bf8f6f          ISB      
                  |L54.44|
00002c  e7fe              B        |L54.44|
                  |L54.46|
;;;2124   		{
;;;2125   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
00002e  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;2126   			{
;;;2127   				/* Move any readied tasks from the pending list into the
;;;2128   				appropriate ready list. */
;;;2129   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
;;;2130   				{
;;;2131   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000030  4922              LDR      r1,|L54.188|
;;;2132   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2133   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;2134   					prvAddTaskToReadyList( pxTCB );
000032  2601              MOVS     r6,#1
000034  b3d0              CBZ      r0,|L54.172|
000036  f1a1098c          SUB      r9,r1,#0x8c
00003a  4688              MOV      r8,r1                 ;2131
                  |L54.60|
00003c  f8d81000          LDR      r1,[r8,#0]            ;2129  ; xPendingReadyList
000040  b1e9              CBZ      r1,|L54.126|
000042  f8d8000c          LDR      r0,[r8,#0xc]          ;2131  ; xPendingReadyList
000046  68c4              LDR      r4,[r0,#0xc]          ;2132
000048  f1040018          ADD      r0,r4,#0x18           ;2132
00004c  f7fffffe          BL       uxListRemove
000050  1d20              ADDS     r0,r4,#4              ;2133
000052  f7fffffe          BL       uxListRemove
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
00005a  fa06f100          LSL      r1,r6,r0
00005e  4311              ORRS     r1,r1,r2
000060  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000062  eb000180          ADD      r1,r0,r0,LSL #2
000066  eb090081          ADD      r0,r9,r1,LSL #2
00006a  1d21              ADDS     r1,r4,#4
00006c  f7fffffe          BL       vListInsertEnd
;;;2135   
;;;2136   					/* If the moved task has a priority higher than the current
;;;2137   					task then a yield must be performed. */
;;;2138   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000070  6ae0              LDR      r0,[r4,#0x2c]
000072  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000074  6ac9              LDR      r1,[r1,#0x2c]
000076  4288              CMP      r0,r1
000078  d3e0              BCC      |L54.60|
;;;2139   					{
;;;2140   						xYieldPending = pdTRUE;
00007a  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
00007c  e7de              B        |L54.60|
                  |L54.126|
;;;2141   					}
;;;2142   					else
;;;2143   					{
;;;2144   						mtCOVERAGE_TEST_MARKER();
;;;2145   					}
;;;2146   				}
;;;2147   
;;;2148   				if( pxTCB != NULL )
00007e  b10c              CBZ      r4,|L54.132|
;;;2149   				{
;;;2150   					/* A task was unblocked while the scheduler was suspended,
;;;2151   					which may have prevented the next unblock time from being
;;;2152   					re-calculated, in which case re-calculate it now.  Mainly
;;;2153   					important for low power tickless implementations, where
;;;2154   					this can prevent an unnecessary exit from low power
;;;2155   					state. */
;;;2156   					prvResetNextTaskUnblockTime();
000080  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L54.132|
;;;2157   				}
;;;2158   
;;;2159   				/* If any ticks occurred while the scheduler was suspended then
;;;2160   				they should be processed now.  This ensures the tick count does
;;;2161   				not	slip, and that any delayed tasks are resumed at the correct
;;;2162   				time. */
;;;2163   				{
;;;2164   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
000084  69ac              LDR      r4,[r5,#0x18]  ; uxPendedTicks
;;;2165   
;;;2166   					if( uxPendedCounts > ( UBaseType_t ) 0U )
000086  b13c              CBZ      r4,|L54.152|
                  |L54.136|
;;;2167   					{
;;;2168   						do
;;;2169   						{
;;;2170   							if( xTaskIncrementTick() != pdFALSE )
000088  f7fffffe          BL       xTaskIncrementTick
00008c  b100              CBZ      r0,|L54.144|
;;;2171   							{
;;;2172   								xYieldPending = pdTRUE;
00008e  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L54.144|
000090  1e64              SUBS     r4,r4,#1
;;;2173   							}
;;;2174   							else
;;;2175   							{
;;;2176   								mtCOVERAGE_TEST_MARKER();
;;;2177   							}
;;;2178   							--uxPendedCounts;
;;;2179   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
000092  d1f9              BNE      |L54.136|
;;;2180   
;;;2181   						uxPendedTicks = 0;
000094  2000              MOVS     r0,#0
000096  61a8              STR      r0,[r5,#0x18]  ; uxPendedTicks
                  |L54.152|
;;;2182   					}
;;;2183   					else
;;;2184   					{
;;;2185   						mtCOVERAGE_TEST_MARKER();
;;;2186   					}
;;;2187   				}
;;;2188   
;;;2189   				if( xYieldPending != pdFALSE )
000098  69e8              LDR      r0,[r5,#0x1c]  ; xYieldPending
00009a  b138              CBZ      r0,|L54.172|
;;;2190   				{
;;;2191   					#if( configUSE_PREEMPTION != 0 )
;;;2192   					{
;;;2193   						xAlreadyYielded = pdTRUE;
;;;2194   					}
;;;2195   					#endif
;;;2196   					taskYIELD_IF_USING_PREEMPTION();
00009c  4908              LDR      r1,|L54.192|
00009e  2701              MOVS     r7,#1                 ;2193
0000a0  0738              LSLS     r0,r7,#28
0000a2  6008              STR      r0,[r1,#0]
0000a4  f3bf8f4f          DSB      
0000a8  f3bf8f6f          ISB      
                  |L54.172|
;;;2197   				}
;;;2198   				else
;;;2199   				{
;;;2200   					mtCOVERAGE_TEST_MARKER();
;;;2201   				}
;;;2202   			}
;;;2203   		}
;;;2204   		else
;;;2205   		{
;;;2206   			mtCOVERAGE_TEST_MARKER();
;;;2207   		}
;;;2208   	}
;;;2209   	taskEXIT_CRITICAL();
0000ac  f7fffffe          BL       vPortExitCritical
;;;2210   
;;;2211   	return xAlreadyYielded;
0000b0  4638              MOV      r0,r7
;;;2212   }
0000b2  e8bd87f0          POP      {r4-r10,pc}
;;;2213   /*-----------------------------------------------------------*/
                          ENDP

0000b6  0000              DCW      0x0000
                  |L54.184|
                          DCD      ||.data||
                  |L54.188|
                          DCD      ||.bss||+0x8c
                  |L54.192|
                          DCD      0xe000ed04

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1830   
;;;1831   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1832   	{
;;;1833   	BaseType_t xYieldRequired = pdFALSE;
000004  2600              MOVS     r6,#0
;;;1834   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000006  0004              MOVS     r4,r0
000008  d015              BEQ      |L55.54|
;;;1835   	UBaseType_t uxSavedInterruptStatus;
;;;1836   
;;;1837   		configASSERT( xTaskToResume );
;;;1838   
;;;1839   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1840   		maximum	system call (or maximum API call) interrupt priority.
;;;1841   		Interrupts that are	above the maximum system call priority are keep
;;;1842   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1843   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1844   		is defined in FreeRTOSConfig.h then
;;;1845   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1846   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1847   		been assigned a priority above the configured maximum system call
;;;1848   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1849   		from interrupts	that have been assigned a priority at or (logically)
;;;1850   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1851   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1852   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1853   		provided on the following link:
;;;1854   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1855   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00000a  f7fffffe          BL       vPortValidateInterruptPriority
00000e  2050              MOVS     r0,#0x50
000010  f3ef8511          MRS      r5,BASEPRI
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
;;;1856   
;;;1857   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1858   		{
;;;1859   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       prvTaskIsTaskSuspended
000026  b330              CBZ      r0,|L55.118|
;;;1860   			{
;;;1861   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1862   
;;;1863   				/* Check the ready lists can be accessed. */
;;;1864   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000028  4f15              LDR      r7,|L55.128|
00002a  6b38              LDR      r0,[r7,#0x30]  ; uxSchedulerSuspended
00002c  b158              CBZ      r0,|L55.70|
;;;1865   				{
;;;1866   					/* Ready lists can be accessed so move the task from the
;;;1867   					suspended list to the ready list directly. */
;;;1868   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1869   					{
;;;1870   						xYieldRequired = pdTRUE;
;;;1871   					}
;;;1872   					else
;;;1873   					{
;;;1874   						mtCOVERAGE_TEST_MARKER();
;;;1875   					}
;;;1876   
;;;1877   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;1878   					prvAddTaskToReadyList( pxTCB );
;;;1879   				}
;;;1880   				else
;;;1881   				{
;;;1882   					/* The delayed or ready lists cannot be accessed so the task
;;;1883   					is held in the pending ready list until the scheduler is
;;;1884   					unsuspended. */
;;;1885   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00002e  f1040118          ADD      r1,r4,#0x18
000032  4814              LDR      r0,|L55.132|
000034  e01d              B        |L55.114|
                  |L55.54|
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
                  |L55.68|
000044  e7fe              B        |L55.68|
                  |L55.70|
000046  6ae0              LDR      r0,[r4,#0x2c]         ;1868
000048  6839              LDR      r1,[r7,#0]            ;1868  ; pxCurrentTCB
00004a  6ac9              LDR      r1,[r1,#0x2c]         ;1868
00004c  4288              CMP      r0,r1                 ;1868
00004e  d300              BCC      |L55.82|
000050  2601              MOVS     r6,#1                 ;1870
                  |L55.82|
000052  1d20              ADDS     r0,r4,#4              ;1877
000054  f7fffffe          BL       uxListRemove
000058  6ae0              LDR      r0,[r4,#0x2c]         ;1878
00005a  2101              MOVS     r1,#1                 ;1878
00005c  693a              LDR      r2,[r7,#0x10]         ;1878  ; uxTopReadyPriority
00005e  4081              LSLS     r1,r1,r0              ;1878
000060  4311              ORRS     r1,r1,r2              ;1878
000062  6139              STR      r1,[r7,#0x10]         ;1878  ; uxTopReadyPriority
000064  4907              LDR      r1,|L55.132|
000066  eb000080          ADD      r0,r0,r0,LSL #2       ;1878
00006a  398c              SUBS     r1,r1,#0x8c           ;1878
00006c  eb010080          ADD      r0,r1,r0,LSL #2       ;1878
000070  1d21              ADDS     r1,r4,#4              ;1878
                  |L55.114|
000072  f7fffffe          BL       vListInsertEnd
                  |L55.118|
000076  f3858811          MSR      BASEPRI,r5            ;1878
;;;1886   				}
;;;1887   			}
;;;1888   			else
;;;1889   			{
;;;1890   				mtCOVERAGE_TEST_MARKER();
;;;1891   			}
;;;1892   		}
;;;1893   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1894   
;;;1895   		return xYieldRequired;
00007a  4630              MOV      r0,r6
;;;1896   	}
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;1897   
                          ENDP

                  |L55.128|
                          DCD      ||.data||
                  |L55.132|
                          DCD      ||.bss||+0x8c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\tasks.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_tasks_c_f31043e3____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_tasks_c_f31043e3____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_tasks_c_f31043e3____REVSH|
#line 402
|__asm___7_tasks_c_f31043e3____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_tasks_c_f31043e3____RRX|
#line 587
|__asm___7_tasks_c_f31043e3____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
