; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\timers.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timers.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -I..\CPU -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\timers.crf ..\..\..\ThirdParty\FreeRTOS\Source\timers.c]
                          THUMB

                          AREA ||i.pcTimerGetName||, CODE, READONLY, ALIGN=1

                  pcTimerGetName PROC
;;;453    
;;;454    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  b108              CBZ      r0,|L1.6|
;;;455    {
;;;456    Timer_t *pxTimer = ( Timer_t * ) xTimer;
;;;457    
;;;458    	configASSERT( xTimer );
;;;459    	return pxTimer->pcTimerName;
000002  6800              LDR      r0,[r0,#0]
;;;460    }
000004  4770              BX       lr
                  |L1.6|
000006  2050              MOVS     r0,#0x50
000008  f3808811          MSR      BASEPRI,r0
00000c  f3bf8f4f          DSB      
000010  f3bf8f6f          ISB      
                  |L1.20|
000014  e7fe              B        |L1.20|
;;;461    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCheckForValidListAndQueue||, CODE, READONLY, ALIGN=2

                  prvCheckForValidListAndQueue PROC
;;;894    
;;;895    static void prvCheckForValidListAndQueue( void )
000000  b510              PUSH     {r4,lr}
;;;896    {
;;;897    	/* Check that the list from which active timers are referenced, and the
;;;898    	queue used to communicate with the timer service, have been
;;;899    	initialised. */
;;;900    	taskENTER_CRITICAL();
000002  f7fffffe          BL       vPortEnterCritical
;;;901    	{
;;;902    		if( xTimerQueue == NULL )
000006  4c0e              LDR      r4,|L2.64|
000008  6820              LDR      r0,[r4,#0]  ; xTimerQueue
00000a  b9a0              CBNZ     r0,|L2.54|
;;;903    		{
;;;904    			vListInitialise( &xActiveTimerList1 );
00000c  480d              LDR      r0,|L2.68|
00000e  f7fffffe          BL       vListInitialise
;;;905    			vListInitialise( &xActiveTimerList2 );
000012  480c              LDR      r0,|L2.68|
000014  3014              ADDS     r0,r0,#0x14
000016  f7fffffe          BL       vListInitialise
;;;906    			pxCurrentTimerList = &xActiveTimerList1;
00001a  480a              LDR      r0,|L2.68|
;;;907    			pxOverflowTimerList = &xActiveTimerList2;
00001c  60e0              STR      r0,[r4,#0xc]  ; pxCurrentTimerList
00001e  3014              ADDS     r0,r0,#0x14
;;;908    
;;;909    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;910    			{
;;;911    				/* The timer queue is allocated statically in case
;;;912    				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
;;;913    				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
;;;914    				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
;;;915    
;;;916    				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
;;;917    			}
;;;918    			#else
;;;919    			{
;;;920    				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
000020  6120              STR      r0,[r4,#0x10]  ; pxOverflowTimerList
000022  2200              MOVS     r2,#0
000024  210c              MOVS     r1,#0xc
000026  2014              MOVS     r0,#0x14
000028  f7fffffe          BL       xQueueGenericCreate
;;;921    			}
;;;922    			#endif
;;;923    
;;;924    			#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;925    			{
;;;926    				if( xTimerQueue != NULL )
00002c  6020              STR      r0,[r4,#0]  ; xTimerQueue
00002e  b110              CBZ      r0,|L2.54|
;;;927    				{
;;;928    					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
000030  a105              ADR      r1,|L2.72|
000032  f7fffffe          BL       vQueueAddToRegistry
                  |L2.54|
;;;929    				}
;;;930    				else
;;;931    				{
;;;932    					mtCOVERAGE_TEST_MARKER();
;;;933    				}
;;;934    			}
;;;935    			#endif /* configQUEUE_REGISTRY_SIZE */
;;;936    		}
;;;937    		else
;;;938    		{
;;;939    			mtCOVERAGE_TEST_MARKER();
;;;940    		}
;;;941    	}
;;;942    	taskEXIT_CRITICAL();
000036  e8bd4010          POP      {r4,lr}
00003a  f7ffbffe          B.W      vPortExitCritical
;;;943    }
;;;944    /*-----------------------------------------------------------*/
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      ||.data||
                  |L2.68|
                          DCD      ||.bss||
                  |L2.72|
000048  546d7251          DCB      "TmrQ",0
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.prvInsertTimerInActiveList||, CODE, READONLY, ALIGN=2

                  prvInsertTimerInActiveList PROC
;;;647    
;;;648    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
000000  b570              PUSH     {r4-r6,lr}
;;;649    {
;;;650    BaseType_t xProcessTimerNow = pdFALSE;
000002  2400              MOVS     r4,#0
;;;651    
;;;652    	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
;;;653    	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000004  6041              STR      r1,[r0,#4]
;;;654    
;;;655    	if( xNextExpiryTime <= xTimeNow )
;;;656    	{
;;;657    		/* Has the expiry time elapsed between the command to start/reset a
;;;658    		timer was issued, and the time the command was processed? */
;;;659    		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;660    		{
;;;661    			/* The time between a command being issued and the command being
;;;662    			processed actually exceeds the timers period.  */
;;;663    			xProcessTimerNow = pdTRUE;
;;;664    		}
;;;665    		else
;;;666    		{
;;;667    			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
000006  4d0b              LDR      r5,|L3.52|
000008  6100              STR      r0,[r0,#0x10]         ;653
00000a  4291              CMP      r1,r2                 ;655
00000c  d806              BHI      |L3.28|
00000e  1ad1              SUBS     r1,r2,r3              ;659
000010  6982              LDR      r2,[r0,#0x18]         ;659
000012  4291              CMP      r1,r2                 ;659
000014  d206              BCS      |L3.36|
000016  1d01              ADDS     r1,r0,#4
000018  6928              LDR      r0,[r5,#0x10]  ; pxOverflowTimerList
00001a  e007              B        |L3.44|
                  |L3.28|
;;;668    		}
;;;669    	}
;;;670    	else
;;;671    	{
;;;672    		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
00001c  429a              CMP      r2,r3
00001e  d203              BCS      |L3.40|
000020  4299              CMP      r1,r3
000022  d301              BCC      |L3.40|
                  |L3.36|
;;;673    		{
;;;674    			/* If, since the command was issued, the tick count has overflowed
;;;675    			but the expiry time has not, then the timer must have already passed
;;;676    			its expiry time and should be processed immediately. */
;;;677    			xProcessTimerNow = pdTRUE;
000024  2401              MOVS     r4,#1
000026  e003              B        |L3.48|
                  |L3.40|
;;;678    		}
;;;679    		else
;;;680    		{
;;;681    			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000028  1d01              ADDS     r1,r0,#4
00002a  68e8              LDR      r0,[r5,#0xc]  ; pxCurrentTimerList
                  |L3.44|
00002c  f7fffffe          BL       vListInsert
                  |L3.48|
;;;682    		}
;;;683    	}
;;;684    
;;;685    	return xProcessTimerNow;
000030  4620              MOV      r0,r4
;;;686    }
000032  bd70              POP      {r4-r6,pc}
;;;687    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.52|
                          DCD      ||.data||

                          AREA ||i.prvProcessReceivedCommands||, CODE, READONLY, ALIGN=2

                  prvProcessReceivedCommands PROC
;;;688    
;;;689    static void	prvProcessReceivedCommands( void )
000000  b530              PUSH     {r4,r5,lr}
;;;690    {
000002  b085              SUB      sp,sp,#0x14
;;;691    DaemonTaskMessage_t xMessage;
;;;692    Timer_t *pxTimer;
;;;693    BaseType_t xTimerListsWereSwitched, xResult;
;;;694    TickType_t xTimeNow;
;;;695    
;;;696    	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
000004  4d2b              LDR      r5,|L4.180|
000006  e04b              B        |L4.160|
                  |L4.8|
;;;697    	{
;;;698    		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
;;;699    		{
;;;700    			/* Negative commands are pended function calls rather than timer
;;;701    			commands. */
;;;702    			if( xMessage.xMessageID < ( BaseType_t ) 0 )
;;;703    			{
;;;704    				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
;;;705    
;;;706    				/* The timer uses the xCallbackParameters member to request a
;;;707    				callback be executed.  Check the callback is not NULL. */
;;;708    				configASSERT( pxCallback );
;;;709    
;;;710    				/* Call the function. */
;;;711    				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
;;;712    			}
;;;713    			else
;;;714    			{
;;;715    				mtCOVERAGE_TEST_MARKER();
;;;716    			}
;;;717    		}
;;;718    		#endif /* INCLUDE_xTimerPendFunctionCall */
;;;719    
;;;720    		/* Commands that are positive are timer commands rather than pended
;;;721    		function calls. */
;;;722    		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
000008  9801              LDR      r0,[sp,#4]
00000a  2800              CMP      r0,#0
00000c  db48              BLT      |L4.160|
;;;723    		{
;;;724    			/* The messages uses the xTimerParameters member to work on a
;;;725    			software timer. */
;;;726    			pxTimer = xMessage.u.xTimerParameters.pxTimer;
;;;727    
;;;728    			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
00000e  9c03              LDR      r4,[sp,#0xc]
000010  6960              LDR      r0,[r4,#0x14]
000012  b110              CBZ      r0,|L4.26|
000014  1d20              ADDS     r0,r4,#4
;;;729    			{
;;;730    				/* The timer is in a list, remove it. */
;;;731    				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
000016  f7fffffe          BL       uxListRemove
                  |L4.26|
;;;732    			}
;;;733    			else
;;;734    			{
;;;735    				mtCOVERAGE_TEST_MARKER();
;;;736    			}
;;;737    
;;;738    			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
;;;739    
;;;740    			/* In this case the xTimerListsWereSwitched parameter is not used, but
;;;741    			it must be present in the function call.  prvSampleTimeNow() must be
;;;742    			called after the message is received from xTimerQueue so there is no
;;;743    			possibility of a higher priority task adding a message to the message
;;;744    			queue with a time that is ahead of the timer daemon task (because it
;;;745    			pre-empted the timer daemon task after the xTimeNow value was set). */
;;;746    			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
00001a  a804              ADD      r0,sp,#0x10
00001c  f7fffffe          BL       prvSampleTimeNow
000020  4602              MOV      r2,r0
;;;747    
;;;748    			switch( xMessage.xMessageID )
000022  9801              LDR      r0,[sp,#4]
000024  280a              CMP      r0,#0xa
000026  d23b              BCS      |L4.160|
000028  e8dff000          TBB      [pc,r0]
00002c  0505053a          DCB      0x05,0x05,0x05,0x3a
000030  26370505          DCB      0x26,0x37,0x05,0x05
000034  3a26              DCB      0x3a,0x26
;;;749    			{
;;;750    				case tmrCOMMAND_START :
;;;751    			    case tmrCOMMAND_START_FROM_ISR :
;;;752    			    case tmrCOMMAND_RESET :
;;;753    			    case tmrCOMMAND_RESET_FROM_ISR :
;;;754    				case tmrCOMMAND_START_DONT_TRACE :
;;;755    					/* Start or restart a timer. */
;;;756    					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
000036  9802              LDR      r0,[sp,#8]
000038  69a1              LDR      r1,[r4,#0x18]
00003a  4603              MOV      r3,r0
00003c  4401              ADD      r1,r1,r0
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       prvInsertTimerInActiveList
000044  b300              CBZ      r0,|L4.136|
;;;757    					{
;;;758    						/* The timer expired before it was added to the active
;;;759    						timer list.  Process it now. */
;;;760    						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
000046  6a61              LDR      r1,[r4,#0x24]
000048  4620              MOV      r0,r4
00004a  4788              BLX      r1
;;;761    						traceTIMER_EXPIRED( pxTimer );
;;;762    
;;;763    						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
00004c  69e0              LDR      r0,[r4,#0x1c]
00004e  2801              CMP      r0,#1
000050  d126              BNE      |L4.160|
;;;764    						{
;;;765    							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
000052  2000              MOVS     r0,#0
000054  9000              STR      r0,[sp,#0]
000056  9802              LDR      r0,[sp,#8]
000058  69a1              LDR      r1,[r4,#0x18]
00005a  2300              MOVS     r3,#0
00005c  1842              ADDS     r2,r0,r1
00005e  4619              MOV      r1,r3
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       xTimerGenericCommand
;;;766    							configASSERT( xResult );
000066  b978              CBNZ     r0,|L4.136|
000068  2050              MOVS     r0,#0x50
00006a  f3808811          MSR      BASEPRI,r0
00006e  f3bf8f4f          DSB      
000072  f3bf8f6f          ISB      
                  |L4.118|
000076  e7fe              B        |L4.118|
;;;767    							( void ) xResult;
;;;768    						}
;;;769    						else
;;;770    						{
;;;771    							mtCOVERAGE_TEST_MARKER();
;;;772    						}
;;;773    					}
;;;774    					else
;;;775    					{
;;;776    						mtCOVERAGE_TEST_MARKER();
;;;777    					}
;;;778    					break;
;;;779    
;;;780    				case tmrCOMMAND_STOP :
;;;781    				case tmrCOMMAND_STOP_FROM_ISR :
;;;782    					/* The timer has already been removed from the active list.
;;;783    					There is nothing to do here. */
;;;784    					break;
;;;785    
;;;786    				case tmrCOMMAND_CHANGE_PERIOD :
;;;787    				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
;;;788    					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
000078  9802              LDR      r0,[sp,#8]
;;;789    					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
00007a  61a0              STR      r0,[r4,#0x18]
00007c  b128              CBZ      r0,|L4.138|
;;;790    
;;;791    					/* The new period does not really have a reference, and can
;;;792    					be longer or shorter than the old one.  The command time is
;;;793    					therefore set to the current time, and as the period cannot
;;;794    					be zero the next expiry time can only be in the future,
;;;795    					meaning (unlike for the xTimerStart() case above) there is
;;;796    					no fail case that needs to be handled here. */
;;;797    					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
00007e  1881              ADDS     r1,r0,r2
000080  4613              MOV      r3,r2
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       prvInsertTimerInActiveList
                  |L4.136|
;;;798    					break;
000088  e00a              B        |L4.160|
                  |L4.138|
00008a  2050              MOVS     r0,#0x50
00008c  f3808811          MSR      BASEPRI,r0
000090  f3bf8f4f          DSB      
000094  f3bf8f6f          ISB      
                  |L4.152|
000098  e7fe              B        |L4.152|
;;;799    
;;;800    				case tmrCOMMAND_DELETE :
;;;801    					/* The timer has already been removed from the active list,
;;;802    					just free up the memory if the memory was dynamically
;;;803    					allocated. */
;;;804    					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;805    					{
;;;806    						/* The timer can only have been allocated dynamically -
;;;807    						free it again. */
;;;808    						vPortFree( pxTimer );
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       vPortFree
                  |L4.160|
0000a0  2200              MOVS     r2,#0                 ;696
0000a2  a901              ADD      r1,sp,#4              ;696
0000a4  6828              LDR      r0,[r5,#0]            ;696  ; xTimerQueue
0000a6  f7fffffe          BL       xQueueReceive
0000aa  2800              CMP      r0,#0                 ;696
0000ac  d1ac              BNE      |L4.8|
;;;809    					}
;;;810    					#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;811    					{
;;;812    						/* The timer could have been allocated statically or
;;;813    						dynamically, so check before attempting to free the
;;;814    						memory. */
;;;815    						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;816    						{
;;;817    							vPortFree( pxTimer );
;;;818    						}
;;;819    						else
;;;820    						{
;;;821    							mtCOVERAGE_TEST_MARKER();
;;;822    						}
;;;823    					}
;;;824    					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;825    					break;
;;;826    
;;;827    				default	:
;;;828    					/* Don't expect to get here. */
;;;829    					break;
;;;830    			}
;;;831    		}
;;;832    	}
;;;833    }
0000ae  b005              ADD      sp,sp,#0x14
0000b0  bd30              POP      {r4,r5,pc}
;;;834    /*-----------------------------------------------------------*/
                          ENDP

0000b2  0000              DCW      0x0000
                  |L4.180|
                          DCD      ||.data||

                          AREA ||i.prvProcessTimerOrBlockTask||, CODE, READONLY, ALIGN=2

                  prvProcessTimerOrBlockTask PROC
;;;538    
;;;539    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;540    {
000004  460e              MOV      r6,r1
000006  4605              MOV      r5,r0
;;;541    TickType_t xTimeNow;
;;;542    BaseType_t xTimerListsWereSwitched;
;;;543    
;;;544    	vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;545    	{
;;;546    		/* Obtain the time now to make an assessment as to whether the timer
;;;547    		has expired or not.  If obtaining the time causes the lists to switch
;;;548    		then don't process this timer as any timers that remained in the list
;;;549    		when the lists were switched will have been processed within the
;;;550    		prvSampleTimeNow() function. */
;;;551    		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       prvSampleTimeNow
000012  4604              MOV      r4,r0
;;;552    		if( xTimerListsWereSwitched == pdFALSE )
000014  9801              LDR      r0,[sp,#4]
000016  b118              CBZ      r0,|L5.32|
;;;553    		{
;;;554    			/* The tick count has not overflowed, has the timer expired? */
;;;555    			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
;;;556    			{
;;;557    				( void ) xTaskResumeAll();
;;;558    				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
;;;559    			}
;;;560    			else
;;;561    			{
;;;562    				/* The tick count has not overflowed, and the next expire
;;;563    				time has not been reached yet.  This task should therefore
;;;564    				block to wait for the next expire time or a command to be
;;;565    				received - whichever comes first.  The following line cannot
;;;566    				be reached unless xNextExpireTime > xTimeNow, except in the
;;;567    				case when the current timer list is empty. */
;;;568    				if( xListWasEmpty != pdFALSE )
;;;569    				{
;;;570    					/* The current timer list is empty - is the overflow list
;;;571    					also empty? */
;;;572    					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
;;;573    				}
;;;574    
;;;575    				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
;;;576    
;;;577    				if( xTaskResumeAll() == pdFALSE )
;;;578    				{
;;;579    					/* Yield to wait for either a command to arrive, or the
;;;580    					block time to expire.  If a command arrived between the
;;;581    					critical section being exited and this yield then the yield
;;;582    					will not cause the task to block. */
;;;583    					portYIELD_WITHIN_API();
;;;584    				}
;;;585    				else
;;;586    				{
;;;587    					mtCOVERAGE_TEST_MARKER();
;;;588    				}
;;;589    			}
;;;590    		}
;;;591    		else
;;;592    		{
;;;593    			( void ) xTaskResumeAll();
000018  f7fffffe          BL       xTaskResumeAll
                  |L5.28|
;;;594    		}
;;;595    	}
;;;596    }
00001c  e8bd81fc          POP      {r2-r8,pc}
                  |L5.32|
000020  4f22              LDR      r7,|L5.172|
000022  b1ae              CBZ      r6,|L5.80|
000024  6938              LDR      r0,[r7,#0x10]         ;572  ; pxOverflowTimerList
000026  6800              LDR      r0,[r0,#0]            ;572
000028  b3a8              CBZ      r0,|L5.150|
00002a  2600              MOVS     r6,#0                 ;572
                  |L5.44|
00002c  1b29              SUBS     r1,r5,r4              ;575
00002e  4632              MOV      r2,r6                 ;575
000030  6838              LDR      r0,[r7,#0]            ;575  ; xTimerQueue
000032  f7fffffe          BL       vQueueWaitForMessageRestricted
000036  f7fffffe          BL       xTaskResumeAll
00003a  2800              CMP      r0,#0                 ;577
00003c  d1ee              BNE      |L5.28|
00003e  491c              LDR      r1,|L5.176|
000040  f04f5080          MOV      r0,#0x10000000        ;583
000044  6008              STR      r0,[r1,#0]            ;583
000046  f3bf8f4f          DSB                            ;583
00004a  f3bf8f6f          ISB                            ;583
00004e  e7e5              B        |L5.28|
                  |L5.80|
000050  42a5              CMP      r5,r4                 ;555
000052  d8eb              BHI      |L5.44|
000054  f7fffffe          BL       xTaskResumeAll
000058  68f8              LDR      r0,[r7,#0xc]          ;557  ; pxCurrentTimerList
00005a  4626              MOV      r6,r4                 ;558
00005c  68c0              LDR      r0,[r0,#0xc]          ;558
00005e  68c4              LDR      r4,[r0,#0xc]          ;558
000060  1d20              ADDS     r0,r4,#4              ;558
000062  f7fffffe          BL       uxListRemove
000066  69e0              LDR      r0,[r4,#0x1c]         ;558
000068  2801              CMP      r0,#1                 ;558
00006a  d110              BNE      |L5.142|
00006c  69a0              LDR      r0,[r4,#0x18]         ;558
00006e  462b              MOV      r3,r5                 ;558
000070  1941              ADDS     r1,r0,r5              ;558
000072  4632              MOV      r2,r6                 ;558
000074  4620              MOV      r0,r4                 ;558
000076  f7fffffe          BL       prvInsertTimerInActiveList
00007a  b140              CBZ      r0,|L5.142|
00007c  2000              MOVS     r0,#0                 ;558
00007e  4603              MOV      r3,r0                 ;558
000080  4601              MOV      r1,r0                 ;558
000082  9000              STR      r0,[sp,#0]            ;558
000084  462a              MOV      r2,r5                 ;558
000086  4620              MOV      r0,r4                 ;558
000088  f7fffffe          BL       xTimerGenericCommand
00008c  b120              CBZ      r0,|L5.152|
                  |L5.142|
00008e  6a61              LDR      r1,[r4,#0x24]         ;558
000090  4620              MOV      r0,r4                 ;558
000092  4788              BLX      r1                    ;558
000094  e7c2              B        |L5.28|
                  |L5.150|
000096  e007              B        |L5.168|
                  |L5.152|
000098  2050              MOVS     r0,#0x50
00009a  f3808811          MSR      BASEPRI,r0
00009e  f3bf8f4f          DSB      
0000a2  f3bf8f6f          ISB      
                  |L5.166|
0000a6  e7fe              B        |L5.166|
                  |L5.168|
0000a8  2601              MOVS     r6,#1                 ;572
0000aa  e7bf              B        |L5.44|
;;;597    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.172|
                          DCD      ||.data||
                  |L5.176|
                          DCD      0xe000ed04

                          AREA ||i.prvSampleTimeNow||, CODE, READONLY, ALIGN=2

                  prvSampleTimeNow PROC
;;;624    
;;;625    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
000000  b570              PUSH     {r4-r6,lr}
;;;626    {
000002  4605              MOV      r5,r0
;;;627    TickType_t xTimeNow;
;;;628    PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
;;;629    
;;;630    	xTimeNow = xTaskGetTickCount();
000004  f7fffffe          BL       xTaskGetTickCount
;;;631    
;;;632    	if( xTimeNow < xLastTime )
000008  4e06              LDR      r6,|L6.36|
00000a  4604              MOV      r4,r0                 ;630
00000c  68b0              LDR      r0,[r6,#8]  ; xLastTime
00000e  4284              CMP      r4,r0
000010  d203              BCS      |L6.26|
;;;633    	{
;;;634    		prvSwitchTimerLists();
000012  f7fffffe          BL       prvSwitchTimerLists
;;;635    		*pxTimerListsWereSwitched = pdTRUE;
000016  2001              MOVS     r0,#1
000018  e000              B        |L6.28|
                  |L6.26|
;;;636    	}
;;;637    	else
;;;638    	{
;;;639    		*pxTimerListsWereSwitched = pdFALSE;
00001a  2000              MOVS     r0,#0
                  |L6.28|
;;;640    	}
;;;641    
;;;642    	xLastTime = xTimeNow;
00001c  6028              STR      r0,[r5,#0]
;;;643    
;;;644    	return xTimeNow;
00001e  4620              MOV      r0,r4
000020  60b4              STR      r4,[r6,#8]  ; xLastTime
;;;645    }
000022  bd70              POP      {r4-r6,pc}
;;;646    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.36|
                          DCD      ||.data||

                          AREA ||i.prvSwitchTimerLists||, CODE, READONLY, ALIGN=2

                  prvSwitchTimerLists PROC
;;;835    
;;;836    static void prvSwitchTimerLists( void )
000000  b5f8              PUSH     {r3-r7,lr}
;;;837    {
;;;838    TickType_t xNextExpireTime, xReloadTime;
;;;839    List_t *pxTemp;
;;;840    Timer_t *pxTimer;
;;;841    BaseType_t xResult;
;;;842    
;;;843    	/* The tick count has overflowed.  The timer lists must be switched.
;;;844    	If there are any timers still referenced from the current timer list
;;;845    	then they must have expired and should be processed before the lists
;;;846    	are switched. */
;;;847    	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
;;;848    	{
;;;849    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000002  4e19              LDR      r6,|L7.104|
000004  e01f              B        |L7.70|
                  |L7.6|
000006  68c0              LDR      r0,[r0,#0xc]
;;;850    
;;;851    		/* Remove the timer from the list. */
;;;852    		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
;;;853    		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
000008  68c4              LDR      r4,[r0,#0xc]
00000a  6805              LDR      r5,[r0,#0]
00000c  1d20              ADDS     r0,r4,#4
00000e  f7fffffe          BL       uxListRemove
;;;854    		traceTIMER_EXPIRED( pxTimer );
;;;855    
;;;856    		/* Execute its callback, then send a command to restart the timer if
;;;857    		it is an auto-reload timer.  It cannot be restarted here as the lists
;;;858    		have not yet been switched. */
;;;859    		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
000012  6a61              LDR      r1,[r4,#0x24]
000014  4620              MOV      r0,r4
000016  4788              BLX      r1
;;;860    
;;;861    		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
000018  69e0              LDR      r0,[r4,#0x1c]
00001a  2801              CMP      r0,#1
00001c  d113              BNE      |L7.70|
;;;862    		{
;;;863    			/* Calculate the reload value, and if the reload value results in
;;;864    			the timer going into the same timer list then it has already expired
;;;865    			and the timer should be re-inserted into the current list so it is
;;;866    			processed again within this loop.  Otherwise a command should be sent
;;;867    			to restart the timer to ensure it is only inserted into a list after
;;;868    			the lists have been swapped. */
;;;869    			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
00001e  69a0              LDR      r0,[r4,#0x18]
000020  4428              ADD      r0,r0,r5
;;;870    			if( xReloadTime > xNextExpireTime )
000022  42a8              CMP      r0,r5
000024  d906              BLS      |L7.52|
;;;871    			{
;;;872    				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
;;;873    				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000026  6124              STR      r4,[r4,#0x10]
000028  6060              STR      r0,[r4,#4]
;;;874    				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
00002a  1d21              ADDS     r1,r4,#4
00002c  68f0              LDR      r0,[r6,#0xc]  ; pxCurrentTimerList
00002e  f7fffffe          BL       vListInsert
000032  e008              B        |L7.70|
                  |L7.52|
;;;875    			}
;;;876    			else
;;;877    			{
;;;878    				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
000034  2000              MOVS     r0,#0
000036  4603              MOV      r3,r0
000038  4601              MOV      r1,r0
00003a  9000              STR      r0,[sp,#0]
00003c  462a              MOV      r2,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       xTimerGenericCommand
;;;879    				configASSERT( xResult );
000044  b138              CBZ      r0,|L7.86|
                  |L7.70|
000046  68f0              LDR      r0,[r6,#0xc]          ;847  ; pxCurrentTimerList
000048  6801              LDR      r1,[r0,#0]            ;847
00004a  2900              CMP      r1,#0                 ;847
00004c  d1db              BNE      |L7.6|
;;;880    				( void ) xResult;
;;;881    			}
;;;882    		}
;;;883    		else
;;;884    		{
;;;885    			mtCOVERAGE_TEST_MARKER();
;;;886    		}
;;;887    	}
;;;888    
;;;889    	pxTemp = pxCurrentTimerList;
;;;890    	pxCurrentTimerList = pxOverflowTimerList;
00004e  6931              LDR      r1,[r6,#0x10]  ; pxOverflowTimerList
000050  e9c61003          STRD     r1,r0,[r6,#0xc]
;;;891    	pxOverflowTimerList = pxTemp;
;;;892    }
000054  bdf8              POP      {r3-r7,pc}
                  |L7.86|
000056  2050              MOVS     r0,#0x50
000058  f3808811          MSR      BASEPRI,r0
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
                  |L7.100|
000064  e7fe              B        |L7.100|
;;;893    /*-----------------------------------------------------------*/
                          ENDP

000066  0000              DCW      0x0000
                  |L7.104|
                          DCD      ||.data||

                          AREA ||i.prvTimerTask||, CODE, READONLY, ALIGN=2

                  prvTimerTask PROC
;;;502    
;;;503    static void prvTimerTask( void *pvParameters )
000000  4c08              LDR      r4,|L8.36|
                  |L8.2|
000002  68e0              LDR      r0,[r4,#0xc]  ; pxCurrentTimerList
000004  6801              LDR      r1,[r0,#0]
000006  b139              CBZ      r1,|L8.24|
000008  2100              MOVS     r1,#0
                  |L8.10|
00000a  b139              CBZ      r1,|L8.28|
00000c  2000              MOVS     r0,#0
                  |L8.14|
;;;504    {
;;;505    TickType_t xNextExpireTime;
;;;506    BaseType_t xListWasEmpty;
;;;507    
;;;508    	/* Just to avoid compiler warnings. */
;;;509    	( void ) pvParameters;
;;;510    
;;;511    	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
;;;512    	{
;;;513    		extern void vApplicationDaemonTaskStartupHook( void );
;;;514    
;;;515    		/* Allow the application writer to execute some code in the context of
;;;516    		this task at the point the task starts executing.  This is useful if the
;;;517    		application includes initialisation code that would benefit from
;;;518    		executing after the scheduler has been started. */
;;;519    		vApplicationDaemonTaskStartupHook();
;;;520    	}
;;;521    	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
;;;522    
;;;523    	for( ;; )
;;;524    	{
;;;525    		/* Query the timers list to see if it contains any timers, and if so,
;;;526    		obtain the time at which the next timer will expire. */
;;;527    		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
;;;528    
;;;529    		/* If a timer has expired, process it.  Otherwise, block this task
;;;530    		until either a timer does expire, or a command is received. */
;;;531    		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
00000e  f7fffffe          BL       prvProcessTimerOrBlockTask
;;;532    
;;;533    		/* Empty the command queue. */
;;;534    		prvProcessReceivedCommands();
000012  f7fffffe          BL       prvProcessReceivedCommands
000016  e7f4              B        |L8.2|
                  |L8.24|
000018  2101              MOVS     r1,#1
00001a  e7f6              B        |L8.10|
                  |L8.28|
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  6800              LDR      r0,[r0,#0]
000020  e7f5              B        |L8.14|
;;;535    	}
;;;536    }
;;;537    /*-----------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      ||.data||

                          AREA ||i.pvTimerGetTimerID||, CODE, READONLY, ALIGN=1

                  pvTimerGetTimerID PROC
;;;966    
;;;967    void *pvTimerGetTimerID( const TimerHandle_t xTimer )
000000  b510              PUSH     {r4,lr}
;;;968    {
;;;969    Timer_t * const pxTimer = ( Timer_t * ) xTimer;
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L9.20|
;;;970    void *pvReturn;
;;;971    
;;;972    	configASSERT( xTimer );
;;;973    
;;;974    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;975    	{
;;;976    		pvReturn = pxTimer->pvTimerID;
00000a  6a24              LDR      r4,[r4,#0x20]
;;;977    	}
;;;978    	taskEXIT_CRITICAL();
00000c  f7fffffe          BL       vPortExitCritical
;;;979    
;;;980    	return pvReturn;
000010  4620              MOV      r0,r4
;;;981    }
000012  bd10              POP      {r4,pc}
                  |L9.20|
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
                  |L9.34|
000022  e7fe              B        |L9.34|
;;;982    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxTimerGetTimerNumber||, CODE, READONLY, ALIGN=1

                  uxTimerGetTimerNumber PROC
;;;1052   
;;;1053   	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
000000  6a80              LDR      r0,[r0,#0x28]
;;;1054   	{
;;;1055   		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
;;;1056   	}
000002  4770              BX       lr
;;;1057   
                          ENDP


                          AREA ||i.vTimerSetTimerID||, CODE, READONLY, ALIGN=1

                  vTimerSetTimerID PROC
;;;983    
;;;984    void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
000000  b570              PUSH     {r4-r6,lr}
;;;985    {
000002  460d              MOV      r5,r1
;;;986    Timer_t * const pxTimer = ( Timer_t * ) xTimer;
000004  0004              MOVS     r4,r0
000006  d006              BEQ      |L11.22|
;;;987    
;;;988    	configASSERT( xTimer );
;;;989    
;;;990    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;991    	{
;;;992    		pxTimer->pvTimerID = pvNewID;
;;;993    	}
;;;994    	taskEXIT_CRITICAL();
00000c  6225              STR      r5,[r4,#0x20]
00000e  e8bd4070          POP      {r4-r6,lr}
000012  f7ffbffe          B.W      vPortExitCritical
                  |L11.22|
000016  2050              MOVS     r0,#0x50
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
                  |L11.36|
000024  e7fe              B        |L11.36|
;;;995    }
;;;996    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vTimerSetTimerNumber||, CODE, READONLY, ALIGN=1

                  vTimerSetTimerNumber PROC
;;;1062   
;;;1063   	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
000000  6281              STR      r1,[r0,#0x28]
;;;1064   	{
;;;1065   		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
;;;1066   	}
000002  4770              BX       lr
;;;1067   
                          ENDP


                          AREA ||i.xTimerCreate||, CODE, READONLY, ALIGN=1

                  xTimerCreate PROC
;;;278    
;;;279    	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;280    								const TickType_t xTimerPeriodInTicks,
;;;281    								const UBaseType_t uxAutoReload,
;;;282    								void * const pvTimerID,
;;;283    								TimerCallbackFunction_t pxCallbackFunction )
;;;284    	{
000004  4607              MOV      r7,r0
000006  4699              MOV      r9,r3
000008  4616              MOV      r6,r2
00000a  460d              MOV      r5,r1
;;;285    	Timer_t *pxNewTimer;
;;;286    
;;;287    		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
00000c  202c              MOVS     r0,#0x2c
00000e  f8dda020          LDR      r10,[sp,#0x20]
000012  f7fffffe          BL       pvPortMalloc
000016  0004              MOVS     r4,r0
;;;288    
;;;289    		if( pxNewTimer != NULL )
000018  d00e              BEQ      |L13.56|
;;;290    		{
;;;291    			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
00001a  46b8              MOV      r8,r7
00001c  464f              MOV      r7,r9
00001e  46d1              MOV      r9,r10
000020  b16d              CBZ      r5,|L13.62|
000022  f7fffffe          BL       prvCheckForValidListAndQueue
000026  f1040118          ADD      r1,r4,#0x18
00002a  f8c48000          STR      r8,[r4,#0]
00002e  e88102e0          STM      r1,{r5-r7,r9}
000032  1d20              ADDS     r0,r4,#4
000034  f7fffffe          BL       vListInitialiseItem
                  |L13.56|
;;;292    
;;;293    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;294    			{
;;;295    				/* Timers can be created statically or dynamically, so note this
;;;296    				timer was created dynamically in case the timer is later
;;;297    				deleted. */
;;;298    				pxNewTimer->ucStaticallyAllocated = pdFALSE;
;;;299    			}
;;;300    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;301    		}
;;;302    
;;;303    		return pxNewTimer;
000038  4620              MOV      r0,r4
;;;304    	}
00003a  e8bd87f0          POP      {r4-r10,pc}
                  |L13.62|
00003e  2050              MOVS     r0,#0x50
000040  f3808811          MSR      BASEPRI,r0
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
                  |L13.76|
00004c  e7fe              B        |L13.76|
;;;305    
                          ENDP


                          AREA ||i.xTimerCreateTimerTask||, CODE, READONLY, ALIGN=2

                  xTimerCreateTimerTask PROC
;;;223    
;;;224    BaseType_t xTimerCreateTimerTask( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;225    {
;;;226    BaseType_t xReturn = pdFAIL;
;;;227    
;;;228    	/* This function is called when the scheduler is started if
;;;229    	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
;;;230    	timer service task has been created/initialised.  If timers have already
;;;231    	been created then the initialisation will already have been performed. */
;;;232    	prvCheckForValidListAndQueue();
000002  f7fffffe          BL       prvCheckForValidListAndQueue
;;;233    
;;;234    	if( xTimerQueue != NULL )
000006  480c              LDR      r0,|L14.56|
000008  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000a  b160              CBZ      r0,|L14.38|
;;;235    	{
;;;236    		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;237    		{
;;;238    			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
;;;239    			StackType_t *pxTimerTaskStackBuffer = NULL;
;;;240    			uint32_t ulTimerTaskStackSize;
;;;241    
;;;242    			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
;;;243    			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
;;;244    													configTIMER_SERVICE_TASK_NAME,
;;;245    													ulTimerTaskStackSize,
;;;246    													NULL,
;;;247    													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;248    													pxTimerTaskStackBuffer,
;;;249    													pxTimerTaskTCBBuffer );
;;;250    
;;;251    			if( xTimerTaskHandle != NULL )
;;;252    			{
;;;253    				xReturn = pdPASS;
;;;254    			}
;;;255    		}
;;;256    		#else
;;;257    		{
;;;258    			xReturn = xTaskCreate(	prvTimerTask,
00000c  490a              LDR      r1,|L14.56|
00000e  2002              MOVS     r0,#2
000010  1d09              ADDS     r1,r1,#4
000012  e9cd0100          STRD     r0,r1,[sp,#0]
000016  01c2              LSLS     r2,r0,#7
000018  2300              MOVS     r3,#0
00001a  a108              ADR      r1,|L14.60|
00001c  4809              LDR      r0,|L14.68|
00001e  f7fffffe          BL       xTaskCreate
000022  2800              CMP      r0,#0
000024  d107              BNE      |L14.54|
                  |L14.38|
000026  2050              MOVS     r0,#0x50
000028  f3808811          MSR      BASEPRI,r0
00002c  f3bf8f4f          DSB      
000030  f3bf8f6f          ISB      
                  |L14.52|
;;;259    									configTIMER_SERVICE_TASK_NAME,
;;;260    									configTIMER_TASK_STACK_DEPTH,
;;;261    									NULL,
;;;262    									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;263    									&xTimerTaskHandle );
;;;264    		}
;;;265    		#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;266    	}
;;;267    	else
;;;268    	{
;;;269    		mtCOVERAGE_TEST_MARKER();
;;;270    	}
;;;271    
;;;272    	configASSERT( xReturn );
000034  e7fe              B        |L14.52|
                  |L14.54|
;;;273    	return xReturn;
;;;274    }
000036  bd1c              POP      {r2-r4,pc}
;;;275    /*-----------------------------------------------------------*/
                          ENDP

                  |L14.56|
                          DCD      ||.data||
                  |L14.60|
00003c  546d7220          DCB      "Tmr Svc",0
000040  53766300
                  |L14.68|
                          DCD      prvTimerTask

                          AREA ||i.xTimerGenericCommand||, CODE, READONLY, ALIGN=2

                  xTimerGenericCommand PROC
;;;381    
;;;382    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
000000  b5fe              PUSH     {r1-r7,lr}
;;;383    {
000002  461f              MOV      r7,r3
000004  0003              MOVS     r3,r0
000006  9e08              LDR      r6,[sp,#0x20]
;;;384    BaseType_t xReturn = pdFAIL;
000008  f04f0000          MOV      r0,#0
00000c  d013              BEQ      |L15.54|
;;;385    DaemonTaskMessage_t xMessage;
;;;386    
;;;387    	configASSERT( xTimer );
;;;388    
;;;389    	/* Send a message to the timer service task to perform a particular action
;;;390    	on a particular timer definition. */
;;;391    	if( xTimerQueue != NULL )
00000e  4d12              LDR      r5,|L15.88|
000010  682c              LDR      r4,[r5,#0]  ; xTimerQueue
000012  2c00              CMP      r4,#0
000014  d00e              BEQ      |L15.52|
000016  e88d000e          STM      sp,{r1-r3}
;;;392    	{
;;;393    		/* Send a command to the timer service task to start the xTimer timer. */
;;;394    		xMessage.xMessageID = xCommandID;
;;;395    		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
;;;396    		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
;;;397    
;;;398    		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
00001a  2906              CMP      r1,#6
00001c  da15              BGE      |L15.74|
;;;399    		{
;;;400    			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
00001e  f7fffffe          BL       xTaskGetSchedulerState
000022  2802              CMP      r0,#2
;;;401    			{
;;;402    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
;;;403    			}
;;;404    			else
;;;405    			{
;;;406    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
000024  f04f0300          MOV      r3,#0
000028  d00d              BEQ      |L15.70|
00002a  2200              MOVS     r2,#0
                  |L15.44|
00002c  4669              MOV      r1,sp                 ;402
00002e  6828              LDR      r0,[r5,#0]            ;402  ; xTimerQueue
000030  f7fffffe          BL       xQueueGenericSend
                  |L15.52|
;;;407    			}
;;;408    		}
;;;409    		else
;;;410    		{
;;;411    			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
;;;412    		}
;;;413    
;;;414    		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
;;;415    	}
;;;416    	else
;;;417    	{
;;;418    		mtCOVERAGE_TEST_MARKER();
;;;419    	}
;;;420    
;;;421    	return xReturn;
;;;422    }
000034  bdfe              POP      {r1-r7,pc}
                  |L15.54|
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
                  |L15.68|
000044  e7fe              B        |L15.68|
                  |L15.70|
000046  4632              MOV      r2,r6                 ;402
000048  e7f0              B        |L15.44|
                  |L15.74|
00004a  2300              MOVS     r3,#0                 ;411
00004c  463a              MOV      r2,r7                 ;411
00004e  4669              MOV      r1,sp                 ;411
000050  4620              MOV      r0,r4                 ;411
000052  f7fffffe          BL       xQueueGenericSendFromISR
000056  bdfe              POP      {r1-r7,pc}
;;;423    /*-----------------------------------------------------------*/
                          ENDP

                  |L15.88|
                          DCD      ||.data||

                          AREA ||i.xTimerGetExpiryTime||, CODE, READONLY, ALIGN=1

                  xTimerGetExpiryTime PROC
;;;442    
;;;443    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
000000  b108              CBZ      r0,|L16.6|
;;;444    {
;;;445    Timer_t * pxTimer = ( Timer_t * ) xTimer;
;;;446    TickType_t xReturn;
;;;447    
;;;448    	configASSERT( xTimer );
;;;449    	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
000002  6840              LDR      r0,[r0,#4]
;;;450    	return xReturn;
;;;451    }
000004  4770              BX       lr
                  |L16.6|
000006  2050              MOVS     r0,#0x50
000008  f3808811          MSR      BASEPRI,r0
00000c  f3bf8f4f          DSB      
000010  f3bf8f6f          ISB      
                  |L16.20|
000014  e7fe              B        |L16.20|
;;;452    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerGetPeriod||, CODE, READONLY, ALIGN=1

                  xTimerGetPeriod PROC
;;;433    
;;;434    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
000000  b108              CBZ      r0,|L17.6|
;;;435    {
;;;436    Timer_t *pxTimer = ( Timer_t * ) xTimer;
;;;437    
;;;438    	configASSERT( xTimer );
;;;439    	return pxTimer->xTimerPeriodInTicks;
000002  6980              LDR      r0,[r0,#0x18]
;;;440    }
000004  4770              BX       lr
                  |L17.6|
000006  2050              MOVS     r0,#0x50
000008  f3808811          MSR      BASEPRI,r0
00000c  f3bf8f4f          DSB      
000010  f3bf8f6f          ISB      
                  |L17.20|
000014  e7fe              B        |L17.20|
;;;441    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerGetTimerDaemonTaskHandle||, CODE, READONLY, ALIGN=2

                  xTimerGetTimerDaemonTaskHandle PROC
;;;424    
;;;425    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
000000  4806              LDR      r0,|L18.28|
;;;426    {
;;;427    	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
;;;428    	started, then xTimerTaskHandle will be NULL. */
;;;429    	configASSERT( ( xTimerTaskHandle != NULL ) );
000002  6840              LDR      r0,[r0,#4]  ; xTimerTaskHandle
000004  2800              CMP      r0,#0                 ;426
000006  d107              BNE      |L18.24|
000008  2050              MOVS     r0,#0x50              ;426
00000a  f3808811          MSR      BASEPRI,r0            ;426
00000e  f3bf8f4f          DSB                            ;426
000012  f3bf8f6f          ISB                            ;426
                  |L18.22|
000016  e7fe              B        |L18.22|
                  |L18.24|
;;;430    	return xTimerTaskHandle;
;;;431    }
000018  4770              BX       lr
;;;432    /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      ||.data||

                          AREA ||i.xTimerIsTimerActive||, CODE, READONLY, ALIGN=1

                  xTimerIsTimerActive PROC
;;;945    
;;;946    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
000000  b510              PUSH     {r4,lr}
;;;947    {
;;;948    BaseType_t xTimerIsInActiveList;
;;;949    Timer_t *pxTimer = ( Timer_t * ) xTimer;
000002  0004              MOVS     r4,r0
000004  d005              BEQ      |L19.18|
;;;950    
;;;951    	configASSERT( xTimer );
;;;952    
;;;953    	/* Is the timer in the list of active timers? */
;;;954    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;955    	{
;;;956    		/* Checking to see if it is in the NULL list in effect checks to see if
;;;957    		it is referenced from either the current or the overflow timer lists in
;;;958    		one go, but the logic has to be reversed, hence the '!'. */
;;;959    		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) ); /*lint !e961. Cast is only redundant when NULL is passed into the macro. */
00000a  6960              LDR      r0,[r4,#0x14]
00000c  b148              CBZ      r0,|L19.34|
00000e  2401              MOVS     r4,#1
000010  e008              B        |L19.36|
                  |L19.18|
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L19.32|
000020  e7fe              B        |L19.32|
                  |L19.34|
000022  2400              MOVS     r4,#0
                  |L19.36|
;;;960    	}
;;;961    	taskEXIT_CRITICAL();
000024  f7fffffe          BL       vPortExitCritical
;;;962    
;;;963    	return xTimerIsInActiveList;
000028  4620              MOV      r0,r4
;;;964    } /*lint !e818 Can't be pointer to const due to the typedef. */
00002a  bd10              POP      {r4,pc}
;;;965    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xActiveTimerList1
                          %        20
                  xActiveTimerList2
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  xTimerQueue
                          DCD      0x00000000
                  xTimerTaskHandle
                          DCD      0x00000000
                  xLastTime
                          DCD      0x00000000
                  pxCurrentTimerList
                          DCD      0x00000000
                  pxOverflowTimerList
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\timers.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_timers_c_a20bbafd____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_timers_c_a20bbafd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_timers_c_a20bbafd____REVSH|
#line 402
|__asm___8_timers_c_a20bbafd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_timers_c_a20bbafd____RRX|
#line 587
|__asm___8_timers_c_a20bbafd____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
