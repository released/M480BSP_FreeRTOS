; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\queue.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\queue.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\ThirdParty\FreeRTOS\Source\include -I..\..\..\ThirdParty\FreeRTOS\Demo\Common\include -I..\..\..\ThirdParty\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\..\ThirdParty\FreeRTOS -I..\..\Template -I..\CPU -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\queue.crf ..\..\..\ThirdParty\FreeRTOS\Source\queue.c]
                          THUMB

                          AREA ||i.pcQueueGetName||, CODE, READONLY, ALIGN=2

                  pcQueueGetName PROC
;;;2641   
;;;2642   	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  b510              PUSH     {r4,lr}
;;;2643   	{
;;;2644   	UBaseType_t ux;
;;;2645   	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000002  2400              MOVS     r4,#0
;;;2646   
;;;2647   		/* Note there is nothing here to protect against another task adding or
;;;2648   		removing entries from the registry while it is being searched. */
;;;2649   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
;;;2650   		{
;;;2651   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000004  4a07              LDR      r2,|L1.36|
000006  4621              MOV      r1,r4                 ;2649
                  |L1.8|
000008  eb0203c1          ADD      r3,r2,r1,LSL #3
00000c  685b              LDR      r3,[r3,#4]
00000e  4283              CMP      r3,r0
000010  d102              BNE      |L1.24|
;;;2652   			{
;;;2653   				pcReturn = xQueueRegistry[ ux ].pcQueueName;
000012  f8524031          LDR      r4,[r2,r1,LSL #3]
;;;2654   				break;
000016  e002              B        |L1.30|
                  |L1.24|
000018  1c49              ADDS     r1,r1,#1
00001a  2908              CMP      r1,#8                 ;2649
00001c  d3f4              BCC      |L1.8|
                  |L1.30|
;;;2655   			}
;;;2656   			else
;;;2657   			{
;;;2658   				mtCOVERAGE_TEST_MARKER();
;;;2659   			}
;;;2660   		}
;;;2661   
;;;2662   		return pcReturn;
00001e  4620              MOV      r0,r4
;;;2663   	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
000020  bd10              POP      {r4,pc}
;;;2664   
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      ||.bss||

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;2119   
;;;2120   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b430              PUSH     {r4,r5}
;;;2121   {
000002  6c02              LDR      r2,[r0,#0x40]
000004  460b              MOV      r3,r1
000006  2a00              CMP      r2,#0
000008  d00b              BEQ      |L2.34|
;;;2122   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
;;;2123   	{
;;;2124   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  4411              ADD      r1,r1,r2
;;;2125   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
00000e  60c1              STR      r1,[r0,#0xc]
000010  6844              LDR      r4,[r0,#4]
000012  42a1              CMP      r1,r4
000014  d301              BCC      |L2.26|
;;;2126   		{
;;;2127   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
000016  6801              LDR      r1,[r0,#0]
000018  60c1              STR      r1,[r0,#0xc]
                  |L2.26|
;;;2128   		}
;;;2129   		else
;;;2130   		{
;;;2131   			mtCOVERAGE_TEST_MARKER();
;;;2132   		}
;;;2133   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
00001a  bc30              POP      {r4,r5}
00001c  4618              MOV      r0,r3
00001e  f7ffbffe          B.W      __aeabi_memcpy
                  |L2.34|
;;;2134   	}
;;;2135   }
000022  bc30              POP      {r4,r5}
000024  4770              BX       lr
;;;2136   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;2040   
;;;2041   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2042   {
;;;2043   BaseType_t xReturn = pdFALSE;
;;;2044   UBaseType_t uxMessagesWaiting;
;;;2045   
;;;2046   	/* This function is called from a critical section. */
;;;2047   
;;;2048   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000004  6b85              LDR      r5,[r0,#0x38]
000006  4617              MOV      r7,r2                 ;2042
000008  4604              MOV      r4,r0                 ;2042
00000a  2600              MOVS     r6,#0                 ;2043
00000c  6c02              LDR      r2,[r0,#0x40]         ;2042
00000e  b182              CBZ      r2,|L3.50|
;;;2049   
;;;2050   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
;;;2051   	{
;;;2052   		#if ( configUSE_MUTEXES == 1 )
;;;2053   		{
;;;2054   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;2055   			{
;;;2056   				/* The mutex is no longer being held. */
;;;2057   				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
;;;2058   				pxQueue->pxMutexHolder = NULL;
;;;2059   			}
;;;2060   			else
;;;2061   			{
;;;2062   				mtCOVERAGE_TEST_MARKER();
;;;2063   			}
;;;2064   		}
;;;2065   		#endif /* configUSE_MUTEXES */
;;;2066   	}
;;;2067   	else if( xPosition == queueSEND_TO_BACK )
000010  b1c7              CBZ      r7,|L3.68|
;;;2068   	{
;;;2069   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
;;;2070   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
;;;2071   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
;;;2072   		{
;;;2073   			pxQueue->pcWriteTo = pxQueue->pcHead;
;;;2074   		}
;;;2075   		else
;;;2076   		{
;;;2077   			mtCOVERAGE_TEST_MARKER();
;;;2078   		}
;;;2079   	}
;;;2080   	else
;;;2081   	{
;;;2082   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000012  68e0              LDR      r0,[r4,#0xc]
000014  f7fffffe          BL       __aeabi_memcpy
;;;2083   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
000018  68e1              LDR      r1,[r4,#0xc]
00001a  6c20              LDR      r0,[r4,#0x40]
00001c  1a09              SUBS     r1,r1,r0
;;;2084   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00001e  60e1              STR      r1,[r4,#0xc]
000020  6822              LDR      r2,[r4,#0]
000022  4291              CMP      r1,r2
000024  d202              BCS      |L3.44|
;;;2085   		{
;;;2086   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000026  6861              LDR      r1,[r4,#4]
000028  1a08              SUBS     r0,r1,r0
00002a  60e0              STR      r0,[r4,#0xc]
                  |L3.44|
;;;2087   		}
;;;2088   		else
;;;2089   		{
;;;2090   			mtCOVERAGE_TEST_MARKER();
;;;2091   		}
;;;2092   
;;;2093   		if( xPosition == queueOVERWRITE )
00002c  2f02              CMP      r7,#2
00002e  d016              BEQ      |L3.94|
000030  e017              B        |L3.98|
                  |L3.50|
000032  6820              LDR      r0,[r4,#0]            ;2054
000034  b9a8              CBNZ     r0,|L3.98|
000036  6860              LDR      r0,[r4,#4]            ;2057
000038  f7fffffe          BL       xTaskPriorityDisinherit
00003c  4606              MOV      r6,r0                 ;2057
00003e  2000              MOVS     r0,#0                 ;2058
000040  6060              STR      r0,[r4,#4]            ;2058
000042  e00e              B        |L3.98|
                  |L3.68|
000044  68a0              LDR      r0,[r4,#8]            ;2069
000046  f7fffffe          BL       __aeabi_memcpy
00004a  6c21              LDR      r1,[r4,#0x40]         ;2070
00004c  68a0              LDR      r0,[r4,#8]            ;2070
00004e  4408              ADD      r0,r0,r1              ;2070
000050  60a0              STR      r0,[r4,#8]            ;2071
000052  6861              LDR      r1,[r4,#4]            ;2071
000054  4288              CMP      r0,r1                 ;2071
000056  d304              BCC      |L3.98|
000058  6820              LDR      r0,[r4,#0]            ;2073
00005a  60a0              STR      r0,[r4,#8]            ;2073
00005c  e001              B        |L3.98|
                  |L3.94|
;;;2094   		{
;;;2095   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00005e  b105              CBZ      r5,|L3.98|
000060  1e6d              SUBS     r5,r5,#1
                  |L3.98|
000062  1c6d              ADDS     r5,r5,#1
;;;2096   			{
;;;2097   				/* An item is not being added but overwritten, so subtract
;;;2098   				one from the recorded number of items in the queue so when
;;;2099   				one is added again below the number of recorded items remains
;;;2100   				correct. */
;;;2101   				--uxMessagesWaiting;
;;;2102   			}
;;;2103   			else
;;;2104   			{
;;;2105   				mtCOVERAGE_TEST_MARKER();
;;;2106   			}
;;;2107   		}
;;;2108   		else
;;;2109   		{
;;;2110   			mtCOVERAGE_TEST_MARKER();
;;;2111   		}
;;;2112   	}
;;;2113   
;;;2114   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000064  63a5              STR      r5,[r4,#0x38]
;;;2115   
;;;2116   	return xReturn;
000066  4630              MOV      r0,r6
;;;2117   }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;2118   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;2257   
;;;2258   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b510              PUSH     {r4,lr}
;;;2259   {
000002  4604              MOV      r4,r0
;;;2260   BaseType_t xReturn;
;;;2261   
;;;2262   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2263   	{
;;;2264   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba0              LDR      r0,[r4,#0x38]
00000a  b120              CBZ      r0,|L4.22|
;;;2265   		{
;;;2266   			xReturn = pdTRUE;
;;;2267   		}
;;;2268   		else
;;;2269   		{
;;;2270   			xReturn = pdFALSE;
00000c  2400              MOVS     r4,#0
                  |L4.14|
;;;2271   		}
;;;2272   	}
;;;2273   	taskEXIT_CRITICAL();
00000e  f7fffffe          BL       vPortExitCritical
;;;2274   
;;;2275   	return xReturn;
000012  4620              MOV      r0,r4
;;;2276   }
000014  bd10              POP      {r4,pc}
                  |L4.22|
000016  2401              MOVS     r4,#1                 ;2266
000018  e7f9              B        |L4.14|
;;;2277   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvNotifyQueueSetContainer||, CODE, READONLY, ALIGN=1

                  prvNotifyQueueSetContainer PROC
;;;2846   
;;;2847   	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;2848   	{
;;;2849   	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
;;;2850   	BaseType_t xReturn = pdFALSE;
000002  2600              MOVS     r6,#0
000004  9800              LDR      r0,[sp,#0]            ;2849
000006  6c84              LDR      r4,[r0,#0x48]         ;2848
000008  b15c              CBZ      r4,|L5.34|
;;;2851   
;;;2852   		/* This function must be called form a critical section. */
;;;2853   
;;;2854   		configASSERT( pxQueueSetContainer );
;;;2855   		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
00000a  6ba2              LDR      r2,[r4,#0x38]
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  4282              CMP      r2,r0
000010  d30f              BCC      |L5.50|
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L5.32|
000020  e7fe              B        |L5.32|
                  |L5.34|
000022  2050              MOVS     r0,#0x50
000024  f3808811          MSR      BASEPRI,r0
000028  f3bf8f4f          DSB      
00002c  f3bf8f6f          ISB      
                  |L5.48|
000030  e7fe              B        |L5.48|
                  |L5.50|
;;;2856   
;;;2857   		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
000032  6ba2              LDR      r2,[r4,#0x38]
000034  4282              CMP      r2,r0
000036  d20c              BCS      |L5.82|
;;;2858   		{
;;;2859   			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
000038  f9945045          LDRSB    r5,[r4,#0x45]
;;;2860   
;;;2861   			traceQUEUE_SEND( pxQueueSetContainer );
;;;2862   
;;;2863   			/* The data copied is the handle of the queue that contains data. */
;;;2864   			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
00003c  460a              MOV      r2,r1
00003e  4669              MOV      r1,sp
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       prvCopyDataToQueue
000046  4606              MOV      r6,r0
;;;2865   
;;;2866   			if( cTxLock == queueUNLOCKED )
000048  1c68              ADDS     r0,r5,#1
00004a  d004              BEQ      |L5.86|
00004c  1c6d              ADDS     r5,r5,#1
;;;2867   			{
;;;2868   				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2869   				{
;;;2870   					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
;;;2871   					{
;;;2872   						/* The task waiting has a higher priority. */
;;;2873   						xReturn = pdTRUE;
;;;2874   					}
;;;2875   					else
;;;2876   					{
;;;2877   						mtCOVERAGE_TEST_MARKER();
;;;2878   					}
;;;2879   				}
;;;2880   				else
;;;2881   				{
;;;2882   					mtCOVERAGE_TEST_MARKER();
;;;2883   				}
;;;2884   			}
;;;2885   			else
;;;2886   			{
;;;2887   				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
00004e  f8845045          STRB     r5,[r4,#0x45]
                  |L5.82|
;;;2888   			}
;;;2889   		}
;;;2890   		else
;;;2891   		{
;;;2892   			mtCOVERAGE_TEST_MARKER();
;;;2893   		}
;;;2894   
;;;2895   		return xReturn;
000052  4630              MOV      r0,r6
;;;2896   	}
000054  bd7c              POP      {r2-r6,pc}
                  |L5.86|
000056  6a60              LDR      r0,[r4,#0x24]         ;2868
000058  2800              CMP      r0,#0                 ;2868
00005a  d0fa              BEQ      |L5.82|
00005c  f1040024          ADD      r0,r4,#0x24           ;2870
000060  f7fffffe          BL       xTaskRemoveFromEventList
000064  2800              CMP      r0,#0                 ;2870
000066  d0f4              BEQ      |L5.82|
000068  2601              MOVS     r6,#1                 ;2873
00006a  e7f2              B        |L5.82|
;;;2897   
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;2137   
;;;2138   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2139   {
000004  4604              MOV      r4,r0
;;;2140   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;2141   
;;;2142   	/* The lock counts contains the number of extra data items placed or
;;;2143   	removed from the queue while the queue was locked.  When a queue is
;;;2144   	locked items can be added or removed, but the event lists cannot be
;;;2145   	updated. */
;;;2146   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;2147   	{
;;;2148   		int8_t cTxLock = pxQueue->cTxLock;
00000a  f9945045          LDRSB    r5,[r4,#0x45]
;;;2149   
;;;2150   		/* See if data was added to the queue while it was locked. */
;;;2151   		while( cTxLock > queueLOCKED_UNMODIFIED )
;;;2152   		{
;;;2153   			/* Data was posted while the queue was locked.  Are any tasks
;;;2154   			blocked waiting for data to become available? */
;;;2155   			#if ( configUSE_QUEUE_SETS == 1 )
;;;2156   			{
;;;2157   				if( pxQueue->pxQueueSetContainer != NULL )
;;;2158   				{
;;;2159   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;2160   					{
;;;2161   						/* The queue is a member of a queue set, and posting to
;;;2162   						the queue set caused a higher priority task to unblock.
;;;2163   						A context switch is required. */
;;;2164   						vTaskMissedYield();
;;;2165   					}
;;;2166   					else
;;;2167   					{
;;;2168   						mtCOVERAGE_TEST_MARKER();
;;;2169   					}
;;;2170   				}
;;;2171   				else
;;;2172   				{
;;;2173   					/* Tasks that are removed from the event list will get
;;;2174   					added to the pending ready list as the scheduler is still
;;;2175   					suspended. */
;;;2176   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2177   					{
;;;2178   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00000e  f1040624          ADD      r6,r4,#0x24
000012  e010              B        |L6.54|
                  |L6.20|
000014  6ca0              LDR      r0,[r4,#0x48]         ;2157
000016  b120              CBZ      r0,|L6.34|
000018  2100              MOVS     r1,#0                 ;2159
00001a  4620              MOV      r0,r4                 ;2159
00001c  f7fffffe          BL       prvNotifyQueueSetContainer
000020  e004              B        |L6.44|
                  |L6.34|
000022  6a60              LDR      r0,[r4,#0x24]         ;2176
000024  b148              CBZ      r0,|L6.58|
000026  4630              MOV      r0,r6                 ;2176
000028  f7fffffe          BL       xTaskRemoveFromEventList
                  |L6.44|
00002c  b108              CBZ      r0,|L6.50|
;;;2179   						{
;;;2180   							/* The task waiting has a higher priority so record that a
;;;2181   							context	switch is required. */
;;;2182   							vTaskMissedYield();
00002e  f7fffffe          BL       vTaskMissedYield
                  |L6.50|
000032  1e6d              SUBS     r5,r5,#1
;;;2183   						}
;;;2184   						else
;;;2185   						{
;;;2186   							mtCOVERAGE_TEST_MARKER();
;;;2187   						}
;;;2188   					}
;;;2189   					else
;;;2190   					{
;;;2191   						break;
;;;2192   					}
;;;2193   				}
;;;2194   			}
;;;2195   			#else /* configUSE_QUEUE_SETS */
;;;2196   			{
;;;2197   				/* Tasks that are removed from the event list will get added to
;;;2198   				the pending ready list as the scheduler is still suspended. */
;;;2199   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2200   				{
;;;2201   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;2202   					{
;;;2203   						/* The task waiting has a higher priority so record that
;;;2204   						a context switch is required. */
;;;2205   						vTaskMissedYield();
;;;2206   					}
;;;2207   					else
;;;2208   					{
;;;2209   						mtCOVERAGE_TEST_MARKER();
;;;2210   					}
;;;2211   				}
;;;2212   				else
;;;2213   				{
;;;2214   					break;
;;;2215   				}
;;;2216   			}
;;;2217   			#endif /* configUSE_QUEUE_SETS */
;;;2218   
;;;2219   			--cTxLock;
000034  b26d              SXTB     r5,r5
                  |L6.54|
000036  2d00              CMP      r5,#0                 ;2151
000038  dcec              BGT      |L6.20|
                  |L6.58|
;;;2220   		}
;;;2221   
;;;2222   		pxQueue->cTxLock = queueUNLOCKED;
00003a  f04f36ff          MOV      r6,#0xffffffff
00003e  f8846045          STRB     r6,[r4,#0x45]
;;;2223   	}
;;;2224   	taskEXIT_CRITICAL();
000042  f7fffffe          BL       vPortExitCritical
;;;2225   
;;;2226   	/* Do the same for the Rx lock. */
;;;2227   	taskENTER_CRITICAL();
000046  f7fffffe          BL       vPortEnterCritical
;;;2228   	{
;;;2229   		int8_t cRxLock = pxQueue->cRxLock;
00004a  f9945044          LDRSB    r5,[r4,#0x44]
;;;2230   
;;;2231   		while( cRxLock > queueLOCKED_UNMODIFIED )
;;;2232   		{
;;;2233   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;2234   			{
;;;2235   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00004e  f1040710          ADD      r7,r4,#0x10
000052  e009              B        |L6.104|
                  |L6.84|
000054  6920              LDR      r0,[r4,#0x10]         ;2233
000056  b148              CBZ      r0,|L6.108|
000058  4638              MOV      r0,r7                 ;2233
00005a  f7fffffe          BL       xTaskRemoveFromEventList
00005e  b108              CBZ      r0,|L6.100|
;;;2236   				{
;;;2237   					vTaskMissedYield();
000060  f7fffffe          BL       vTaskMissedYield
                  |L6.100|
000064  1e6d              SUBS     r5,r5,#1
;;;2238   				}
;;;2239   				else
;;;2240   				{
;;;2241   					mtCOVERAGE_TEST_MARKER();
;;;2242   				}
;;;2243   
;;;2244   				--cRxLock;
000066  b26d              SXTB     r5,r5
                  |L6.104|
000068  2d00              CMP      r5,#0                 ;2231
00006a  dcf3              BGT      |L6.84|
                  |L6.108|
;;;2245   			}
;;;2246   			else
;;;2247   			{
;;;2248   				break;
;;;2249   			}
;;;2250   		}
;;;2251   
;;;2252   		pxQueue->cRxLock = queueUNLOCKED;
00006c  f8846044          STRB     r6,[r4,#0x44]
;;;2253   	}
;;;2254   	taskEXIT_CRITICAL();
000070  e8bd41f0          POP      {r4-r8,lr}
000074  f7ffbffe          B.W      vPortExitCritical
;;;2255   }
;;;2256   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.ucQueueGetQueueType||, CODE, READONLY, ALIGN=1

                  ucQueueGetQueueType PROC
;;;2005   
;;;2006   	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
000000  f8900050          LDRB     r0,[r0,#0x50]
;;;2007   	{
;;;2008   		return ( ( Queue_t * ) xQueue )->ucQueueType;
;;;2009   	}
000004  4770              BX       lr
;;;2010   
                          ENDP


                          AREA ||i.uxQueueGetQueueNumber||, CODE, READONLY, ALIGN=1

                  uxQueueGetQueueNumber PROC
;;;1985   
;;;1986   	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
000000  6cc0              LDR      r0,[r0,#0x4c]
;;;1987   	{
;;;1988   		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
;;;1989   	}
000002  4770              BX       lr
;;;1990   
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1895   
;;;1896   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1897   {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L9.20|
;;;1898   UBaseType_t uxReturn;
;;;1899   
;;;1900   	configASSERT( xQueue );
;;;1901   
;;;1902   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1903   	{
;;;1904   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
00000a  6ba4              LDR      r4,[r4,#0x38]
;;;1905   	}
;;;1906   	taskEXIT_CRITICAL();
00000c  f7fffffe          BL       vPortExitCritical
;;;1907   
;;;1908   	return uxReturn;
000010  4620              MOV      r0,r4
;;;1909   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000012  bd10              POP      {r4,pc}
                  |L9.20|
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
                  |L9.34|
000022  e7fe              B        |L9.34|
;;;1910   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1929   
;;;1930   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  b108              CBZ      r0,|L10.6|
;;;1931   {
;;;1932   UBaseType_t uxReturn;
;;;1933   
;;;1934   	configASSERT( xQueue );
;;;1935   
;;;1936   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000002  6b80              LDR      r0,[r0,#0x38]
;;;1937   
;;;1938   	return uxReturn;
;;;1939   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000004  4770              BX       lr
                  |L10.6|
000006  2050              MOVS     r0,#0x50
000008  f3808811          MSR      BASEPRI,r0
00000c  f3bf8f4f          DSB      
000010  f3bf8f6f          ISB      
                  |L10.20|
000014  e7fe              B        |L10.20|
;;;1940   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1911   
;;;1912   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1913   {
000002  0004              MOVS     r4,r0
000004  d008              BEQ      |L11.24|
;;;1914   UBaseType_t uxReturn;
;;;1915   Queue_t *pxQueue;
;;;1916   
;;;1917   	pxQueue = ( Queue_t * ) xQueue;
;;;1918   	configASSERT( pxQueue );
;;;1919   
;;;1920   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1921   	{
;;;1922   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
00000a  e9d4100e          LDRD     r1,r0,[r4,#0x38]
00000e  1a44              SUBS     r4,r0,r1
;;;1923   	}
;;;1924   	taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;1925   
;;;1926   	return uxReturn;
000014  4620              MOV      r0,r4
;;;1927   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000016  bd10              POP      {r4,pc}
                  |L11.24|
000018  2050              MOVS     r0,#0x50
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
                  |L11.38|
000026  e7fe              B        |L11.38|
;;;1928   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueAddToRegistry||, CODE, READONLY, ALIGN=2

                  vQueueAddToRegistry PROC
;;;2612   
;;;2613   	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  b510              PUSH     {r4,lr}
;;;2614   	{
;;;2615   	UBaseType_t ux;
;;;2616   
;;;2617   		/* See if there is an empty space in the registry.  A NULL name denotes
;;;2618   		a free slot. */
;;;2619   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
;;;2620   		{
;;;2621   			if( xQueueRegistry[ ux ].pcQueueName == NULL )
000002  4b07              LDR      r3,|L12.32|
000004  2200              MOVS     r2,#0                 ;2619
                  |L12.6|
000006  f8534032          LDR      r4,[r3,r2,LSL #3]
00000a  b11c              CBZ      r4,|L12.20|
00000c  1c52              ADDS     r2,r2,#1
00000e  2a08              CMP      r2,#8                 ;2619
000010  d3f9              BCC      |L12.6|
;;;2622   			{
;;;2623   				/* Store the information on this queue. */
;;;2624   				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
;;;2625   				xQueueRegistry[ ux ].xHandle = xQueue;
;;;2626   
;;;2627   				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
;;;2628   				break;
;;;2629   			}
;;;2630   			else
;;;2631   			{
;;;2632   				mtCOVERAGE_TEST_MARKER();
;;;2633   			}
;;;2634   		}
;;;2635   	}
000012  bd10              POP      {r4,pc}
                  |L12.20|
000014  f8431032          STR      r1,[r3,r2,LSL #3]     ;2624
000018  eb0301c2          ADD      r1,r3,r2,LSL #3       ;2625
00001c  6048              STR      r0,[r1,#4]            ;2625
00001e  bd10              POP      {r4,pc}
;;;2636   
                          ENDP

                  |L12.32|
                          DCD      ||.bss||

                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1941   
;;;1942   void vQueueDelete( QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1943   {
000002  0004              MOVS     r4,r0
000004  d006              BEQ      |L13.20|
;;;1944   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1945   
;;;1946   	configASSERT( pxQueue );
;;;1947   	traceQUEUE_DELETE( pxQueue );
;;;1948   
;;;1949   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1950   	{
;;;1951   		vQueueUnregisterQueue( pxQueue );
000006  f7fffffe          BL       vQueueUnregisterQueue
;;;1952   	}
;;;1953   	#endif
;;;1954   
;;;1955   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1956   	{
;;;1957   		/* The queue can only have been allocated dynamically - free it
;;;1958   		again. */
;;;1959   		vPortFree( pxQueue );
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      vPortFree
                  |L13.20|
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
                  |L13.34|
000022  e7fe              B        |L13.34|
;;;1960   	}
;;;1961   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1962   	{
;;;1963   		/* The queue could have been allocated statically or dynamically, so
;;;1964   		check before attempting to free the memory. */
;;;1965   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;1966   		{
;;;1967   			vPortFree( pxQueue );
;;;1968   		}
;;;1969   		else
;;;1970   		{
;;;1971   			mtCOVERAGE_TEST_MARKER();
;;;1972   		}
;;;1973   	}
;;;1974   	#else
;;;1975   	{
;;;1976   		/* The queue must have been statically allocated, so is not going to be
;;;1977   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;1978   		( void ) pxQueue;
;;;1979   	}
;;;1980   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;1981   }
;;;1982   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueSetQueueNumber||, CODE, READONLY, ALIGN=1

                  vQueueSetQueueNumber PROC
;;;1995   
;;;1996   	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
000000  64c1              STR      r1,[r0,#0x4c]
;;;1997   	{
;;;1998   		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
;;;1999   	}
000002  4770              BX       lr
;;;2000   
                          ENDP


                          AREA ||i.vQueueUnregisterQueue||, CODE, READONLY, ALIGN=2

                  vQueueUnregisterQueue PROC
;;;2669   
;;;2670   	void vQueueUnregisterQueue( QueueHandle_t xQueue )
000000  4a08              LDR      r2,|L15.36|
;;;2671   	{
;;;2672   	UBaseType_t ux;
;;;2673   
;;;2674   		/* See if the handle of the queue being unregistered in actually in the
;;;2675   		registry. */
;;;2676   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000002  2100              MOVS     r1,#0
                  |L15.4|
;;;2677   		{
;;;2678   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000004  eb0203c1          ADD      r3,r2,r1,LSL #3
000008  685b              LDR      r3,[r3,#4]
00000a  4283              CMP      r3,r0
00000c  d106              BNE      |L15.28|
;;;2679   			{
;;;2680   				/* Set the name to NULL to show that this slot if free again. */
;;;2681   				xQueueRegistry[ ux ].pcQueueName = NULL;
00000e  2000              MOVS     r0,#0
000010  f8420031          STR      r0,[r2,r1,LSL #3]
;;;2682   
;;;2683   				/* Set the handle to NULL to ensure the same queue handle cannot
;;;2684   				appear in the registry twice if it is added, removed, then
;;;2685   				added again. */
;;;2686   				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
000014  eb0201c1          ADD      r1,r2,r1,LSL #3
;;;2687   				break;
000018  6048              STR      r0,[r1,#4]
;;;2688   			}
;;;2689   			else
;;;2690   			{
;;;2691   				mtCOVERAGE_TEST_MARKER();
;;;2692   			}
;;;2693   		}
;;;2694   
;;;2695   	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00001a  4770              BX       lr
                  |L15.28|
00001c  1c49              ADDS     r1,r1,#1
00001e  2908              CMP      r1,#8                 ;2676
000020  d3f0              BCC      |L15.4|
000022  4770              BX       lr
;;;2696   
                          ENDP

                  |L15.36|
                          DCD      ||.bss||

                          AREA ||i.vQueueWaitForMessageRestricted||, CODE, READONLY, ALIGN=1

                  vQueueWaitForMessageRestricted PROC
;;;2701   
;;;2702   	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;2703   	{
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;2704   	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;2705   
;;;2706   		/* This function should not be called by application code hence the
;;;2707   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2708   		designed for use by kernel code, and has special calling requirements.
;;;2709   		It can result in vListInsert() being called on a list that can only
;;;2710   		possibly ever have one item in it, so the list will be fast, but even
;;;2711   		so it should be called with the scheduler locked and not from a critical
;;;2712   		section. */
;;;2713   
;;;2714   		/* Only do anything if there are no messages in the queue.  This function
;;;2715   		will not actually cause the task to block, just place it on a blocked
;;;2716   		list.  It will not block until the scheduler is unlocked - at which
;;;2717   		time a yield will be performed.  If an item is added to the queue while
;;;2718   		the queue is locked, and the calling task blocks on the queue, then the
;;;2719   		calling task will be immediately unblocked when the queue is unlocked. */
;;;2720   		prvLockQueue( pxQueue );
000008  f7fffffe          BL       vPortEnterCritical
00000c  f9941044          LDRSB    r1,[r4,#0x44]
000010  2000              MOVS     r0,#0
000012  1c49              ADDS     r1,r1,#1
000014  d101              BNE      |L16.26|
000016  f8840044          STRB     r0,[r4,#0x44]
                  |L16.26|
00001a  f9941045          LDRSB    r1,[r4,#0x45]
00001e  1c49              ADDS     r1,r1,#1
000020  d101              BNE      |L16.38|
000022  f8840045          STRB     r0,[r4,#0x45]
                  |L16.38|
000026  f7fffffe          BL       vPortExitCritical
;;;2721   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
00002a  6ba0              LDR      r0,[r4,#0x38]
00002c  b928              CBNZ     r0,|L16.58|
;;;2722   		{
;;;2723   			/* There is nothing in the queue, block for the specified period. */
;;;2724   			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
00002e  462a              MOV      r2,r5
000030  4631              MOV      r1,r6
000032  f1040024          ADD      r0,r4,#0x24
000036  f7fffffe          BL       vTaskPlaceOnEventListRestricted
                  |L16.58|
;;;2725   		}
;;;2726   		else
;;;2727   		{
;;;2728   			mtCOVERAGE_TEST_MARKER();
;;;2729   		}
;;;2730   		prvUnlockQueue( pxQueue );
00003a  4620              MOV      r0,r4
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f7ffbffe          B.W      prvUnlockQueue
;;;2731   	}
;;;2732   
                          ENDP


                          AREA ||i.xQueueAddToSet||, CODE, READONLY, ALIGN=1

                  xQueueAddToSet PROC
;;;2751   
;;;2752   	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
000000  b570              PUSH     {r4-r6,lr}
;;;2753   	{
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;2754   	BaseType_t xReturn;
;;;2755   
;;;2756   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;2757   		{
;;;2758   			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
00000a  6ca0              LDR      r0,[r4,#0x48]
00000c  b908              CBNZ     r0,|L17.18|
;;;2759   			{
;;;2760   				/* Cannot add a queue/semaphore to more than one queue set. */
;;;2761   				xReturn = pdFAIL;
;;;2762   			}
;;;2763   			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
00000e  6ba0              LDR      r0,[r4,#0x38]
000010  b108              CBZ      r0,|L17.22|
                  |L17.18|
;;;2764   			{
;;;2765   				/* Cannot add a queue/semaphore to a queue set if there are already
;;;2766   				items in the queue/semaphore. */
;;;2767   				xReturn = pdFAIL;
000012  2400              MOVS     r4,#0
000014  e001              B        |L17.26|
                  |L17.22|
;;;2768   			}
;;;2769   			else
;;;2770   			{
;;;2771   				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
;;;2772   				xReturn = pdPASS;
000016  64a5              STR      r5,[r4,#0x48]
000018  2401              MOVS     r4,#1
                  |L17.26|
;;;2773   			}
;;;2774   		}
;;;2775   		taskEXIT_CRITICAL();
00001a  f7fffffe          BL       vPortExitCritical
;;;2776   
;;;2777   		return xReturn;
00001e  4620              MOV      r0,r4
;;;2778   	}
000020  bd70              POP      {r4-r6,pc}
;;;2779   
                          ENDP


                          AREA ||i.xQueueCreateCountingSemaphore||, CODE, READONLY, ALIGN=1

                  xQueueCreateCountingSemaphore PROC
;;;699    
;;;700    	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
000000  b510              PUSH     {r4,lr}
;;;701    	{
000002  460c              MOV      r4,r1
000004  b148              CBZ      r0,|L18.26|
;;;702    	QueueHandle_t xHandle;
;;;703    
;;;704    		configASSERT( uxMaxCount != 0 );
;;;705    		configASSERT( uxInitialCount <= uxMaxCount );
000006  4284              CMP      r4,r0
000008  d90f              BLS      |L18.42|
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
                  |L18.24|
000018  e7fe              B        |L18.24|
                  |L18.26|
00001a  2050              MOVS     r0,#0x50
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
                  |L18.40|
000028  e7fe              B        |L18.40|
                  |L18.42|
;;;706    
;;;707    		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
00002a  2202              MOVS     r2,#2
00002c  2100              MOVS     r1,#0
00002e  f7fffffe          BL       xQueueGenericCreate
;;;708    
;;;709    		if( xHandle != NULL )
000032  2800              CMP      r0,#0
000034  d000              BEQ      |L18.56|
;;;710    		{
;;;711    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
000036  6384              STR      r4,[r0,#0x38]
                  |L18.56|
;;;712    
;;;713    			traceCREATE_COUNTING_SEMAPHORE();
;;;714    		}
;;;715    		else
;;;716    		{
;;;717    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;718    		}
;;;719    
;;;720    		return xHandle;
;;;721    	}
000038  bd10              POP      {r4,pc}
;;;722    
                          ENDP


                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;482    
;;;483    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  b510              PUSH     {r4,lr}
;;;484    	{
;;;485    	Queue_t *pxNewQueue;
;;;486    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
;;;487    
;;;488    		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
000002  4602              MOV      r2,r0
000004  2100              MOVS     r1,#0
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       xQueueGenericCreate
00000c  1e04              SUBS     r4,r0,#0
00000e  d007              BEQ      |L19.32|
000010  2100              MOVS     r1,#0
000012  6041              STR      r1,[r0,#4]
000014  6001              STR      r1,[r0,#0]
000016  460b              MOV      r3,r1
000018  460a              MOV      r2,r1
00001a  60c1              STR      r1,[r0,#0xc]
00001c  f7fffffe          BL       xQueueGenericSend
                  |L19.32|
;;;489    		prvInitialiseMutex( pxNewQueue );
;;;490    
;;;491    		return pxNewQueue;
000020  4620              MOV      r0,r4
;;;492    	}
000022  bd10              POP      {r4,pc}
;;;493    
                          ENDP


                          AREA ||i.xQueueCreateSet||, CODE, READONLY, ALIGN=1

                  xQueueCreateSet PROC
;;;2737   
;;;2738   	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
000000  2200              MOVS     r2,#0
;;;2739   	{
;;;2740   	QueueSetHandle_t pxQueue;
;;;2741   
;;;2742   		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
000002  2104              MOVS     r1,#4
000004  f7ffbffe          B.W      xQueueGenericCreate
;;;2743   
;;;2744   		return pxQueue;
;;;2745   	}
;;;2746   
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;358    
;;;359    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;360    	{
000004  4617              MOV      r7,r2
000006  460e              MOV      r6,r1
000008  0005              MOVS     r5,r0
00000a  d018              BEQ      |L21.62|
;;;361    	Queue_t *pxNewQueue;
;;;362    	size_t xQueueSizeInBytes;
;;;363    	uint8_t *pucQueueStorage;
;;;364    
;;;365    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
;;;366    
;;;367    		if( uxItemSize == ( UBaseType_t ) 0 )
00000c  b1fe              CBZ      r6,|L21.78|
;;;368    		{
;;;369    			/* There is not going to be a queue storage area. */
;;;370    			xQueueSizeInBytes = ( size_t ) 0;
;;;371    		}
;;;372    		else
;;;373    		{
;;;374    			/* Allocate enough space to hold the maximum number of items that
;;;375    			can be in the queue at any time. */
;;;376    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00000e  fb05f006          MUL      r0,r5,r6
                  |L21.18|
000012  3054              ADDS     r0,r0,#0x54
;;;377    		}
;;;378    
;;;379    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
000014  f7fffffe          BL       pvPortMalloc
000018  0004              MOVS     r4,r0
;;;380    
;;;381    		if( pxNewQueue != NULL )
00001a  d00e              BEQ      |L21.58|
;;;382    		{
;;;383    			/* Jump past the queue structure to find the location of the queue
;;;384    			storage area. */
;;;385    			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
00001c  f1040054          ADD      r0,r4,#0x54
000020  b1be              CBZ      r6,|L21.82|
000022  6020              STR      r0,[r4,#0]
                  |L21.36|
000024  e9c4560f          STRD     r5,r6,[r4,#0x3c]
000028  4620              MOV      r0,r4
00002a  2101              MOVS     r1,#1
00002c  f7fffffe          BL       xQueueGenericReset
000030  f8847050          STRB     r7,[r4,#0x50]
000034  2100              MOVS     r1,#0
000036  4620              MOV      r0,r4
;;;386    
;;;387    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;388    			{
;;;389    				/* Queues can be created either statically or dynamically, so
;;;390    				note this task was created dynamically in case it is later
;;;391    				deleted. */
;;;392    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
;;;393    			}
;;;394    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;395    
;;;396    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
000038  64a1              STR      r1,[r4,#0x48]
                  |L21.58|
;;;397    		}
;;;398    		else
;;;399    		{
;;;400    			traceQUEUE_CREATE_FAILED( ucQueueType );
;;;401    		}
;;;402    
;;;403    		return pxNewQueue;
;;;404    	}
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L21.62|
00003e  2050              MOVS     r0,#0x50
000040  f3808811          MSR      BASEPRI,r0
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
                  |L21.76|
00004c  e7fe              B        |L21.76|
                  |L21.78|
00004e  2000              MOVS     r0,#0                 ;370
000050  e7df              B        |L21.18|
                  |L21.82|
000052  6024              STR      r4,[r4,#0]            ;370
000054  e7e6              B        |L21.36|
;;;405    
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;247    
;;;248    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;249    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d025              BEQ      |L22.84|
;;;250    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;251    
;;;252    	configASSERT( pxQueue );
;;;253    
;;;254    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;255    	{
;;;256    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00000c  e9d4200f          LDRD     r2,r0,[r4,#0x3c]
000010  6821              LDR      r1,[r4,#0]
000012  fb021100          MLA      r1,r2,r0,r1
;;;257    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000016  6061              STR      r1,[r4,#4]
000018  2100              MOVS     r1,#0
00001a  63a1              STR      r1,[r4,#0x38]
;;;258    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001c  6821              LDR      r1,[r4,#0]
;;;259    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
00001e  60a1              STR      r1,[r4,#8]
000020  460a              MOV      r2,r1
000022  e9d4010f          LDRD     r0,r1,[r4,#0x3c]
000026  1e40              SUBS     r0,r0,#1
000028  fb002101          MLA      r1,r0,r1,r2
;;;260    		pxQueue->cRxLock = queueUNLOCKED;
00002c  60e1              STR      r1,[r4,#0xc]
00002e  4621              MOV      r1,r4
000030  f04f30ff          MOV      r0,#0xffffffff
000034  f8010f44          STRB     r0,[r1,#0x44]!
;;;261    		pxQueue->cTxLock = queueUNLOCKED;
000038  7048              STRB     r0,[r1,#1]
;;;262    
;;;263    		if( xNewQueue == pdFALSE )
;;;264    		{
;;;265    			/* If there are tasks blocked waiting to read from the queue, then
;;;266    			the tasks will remain blocked as after this function exits the queue
;;;267    			will still be empty.  If there are tasks blocked waiting to write to
;;;268    			the queue, then one should be unblocked as after this function exits
;;;269    			it will be possible to write to it. */
;;;270    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;271    			{
;;;272    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00003a  f1040010          ADD      r0,r4,#0x10
00003e  b18d              CBZ      r5,|L22.100|
;;;273    				{
;;;274    					queueYIELD_IF_USING_PREEMPTION();
;;;275    				}
;;;276    				else
;;;277    				{
;;;278    					mtCOVERAGE_TEST_MARKER();
;;;279    				}
;;;280    			}
;;;281    			else
;;;282    			{
;;;283    				mtCOVERAGE_TEST_MARKER();
;;;284    			}
;;;285    		}
;;;286    		else
;;;287    		{
;;;288    			/* Ensure the event queues start in the correct state. */
;;;289    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000040  f7fffffe          BL       vListInitialise
;;;290    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000044  f1040024          ADD      r0,r4,#0x24
000048  f7fffffe          BL       vListInitialise
                  |L22.76|
;;;291    		}
;;;292    	}
;;;293    	taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
;;;294    
;;;295    	/* A value is returned for calling semantic consistency with previous
;;;296    	versions. */
;;;297    	return pdPASS;
000050  2001              MOVS     r0,#1
;;;298    }
000052  bd70              POP      {r4-r6,pc}
                  |L22.84|
000054  2050              MOVS     r0,#0x50
000056  f3808811          MSR      BASEPRI,r0
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
                  |L22.98|
000062  e7fe              B        |L22.98|
                  |L22.100|
000064  6921              LDR      r1,[r4,#0x10]         ;270
000066  2900              CMP      r1,#0                 ;270
000068  d0f0              BEQ      |L22.76|
00006a  f7fffffe          BL       xTaskRemoveFromEventList
00006e  2800              CMP      r0,#0                 ;272
000070  d0ec              BEQ      |L22.76|
000072  4904              LDR      r1,|L22.132|
000074  f04f5080          MOV      r0,#0x10000000        ;274
000078  6008              STR      r0,[r1,#0]            ;274
00007a  f3bf8f4f          DSB                            ;274
00007e  f3bf8f6f          ISB                            ;274
000082  e7e3              B        |L22.76|
;;;299    /*-----------------------------------------------------------*/
                          ENDP

                  |L22.132|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=2

                  xQueueGenericSend PROC
;;;725    
;;;726    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;727    {
000004  b083              SUB      sp,sp,#0xc
000006  4699              MOV      r9,r3
000008  468b              MOV      r11,r1
00000a  0004              MOVS     r4,r0
;;;728    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
00000c  f04f0600          MOV      r6,#0
000010  d003              BEQ      |L23.26|
;;;729    TimeOut_t xTimeOut;
;;;730    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;731    
;;;732    	configASSERT( pxQueue );
;;;733    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000012  f1bb0f00          CMP      r11,#0
000016  d008              BEQ      |L23.42|
000018  e011              B        |L23.62|
                  |L23.26|
00001a  2050              MOVS     r0,#0x50
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
                  |L23.40|
000028  e7fe              B        |L23.40|
                  |L23.42|
00002a  6c20              LDR      r0,[r4,#0x40]
00002c  b138              CBZ      r0,|L23.62|
00002e  2050              MOVS     r0,#0x50
000030  f3808811          MSR      BASEPRI,r0
000034  f3bf8f4f          DSB      
000038  f3bf8f6f          ISB      
                  |L23.60|
00003c  e7fe              B        |L23.60|
                  |L23.62|
;;;734    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
00003e  f1b90f02          CMP      r9,#2
000042  d10a              BNE      |L23.90|
000044  6be0              LDR      r0,[r4,#0x3c]
000046  2801              CMP      r0,#1
000048  d007              BEQ      |L23.90|
00004a  2050              MOVS     r0,#0x50
00004c  f3808811          MSR      BASEPRI,r0
000050  f3bf8f4f          DSB      
000054  f3bf8f6f          ISB      
                  |L23.88|
000058  e7fe              B        |L23.88|
                  |L23.90|
;;;735    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;736    	{
;;;737    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00005a  f7fffffe          BL       xTaskGetSchedulerState
;;;738    	}
;;;739    	#endif
;;;740    
;;;741    
;;;742    	/* This function relaxes the coding standard somewhat to allow return
;;;743    	statements within the function itself.  This is done in the interest
;;;744    	of execution time efficiency. */
;;;745    	for( ;; )
;;;746    	{
;;;747    		taskENTER_CRITICAL();
;;;748    		{
;;;749    			/* Is there room on the queue now?  The running task must be the
;;;750    			highest priority task wanting to access the queue.  If the head item
;;;751    			in the queue is to be overwritten then it does not matter if the
;;;752    			queue is full. */
;;;753    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
;;;754    			{
;;;755    				traceQUEUE_SEND( pxQueue );
;;;756    				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;757    
;;;758    				#if ( configUSE_QUEUE_SETS == 1 )
;;;759    				{
;;;760    					if( pxQueue->pxQueueSetContainer != NULL )
;;;761    					{
;;;762    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;763    						{
;;;764    							/* The queue is a member of a queue set, and posting
;;;765    							to the queue set caused a higher priority task to
;;;766    							unblock. A context switch is required. */
;;;767    							queueYIELD_IF_USING_PREEMPTION();
00005e  f8df8110          LDR      r8,|L23.368|
000062  f04f0a00          MOV      r10,#0                ;737
000066  f04f5780          MOV      r7,#0x10000000
00006a  b948              CBNZ     r0,|L23.128|
00006c  9805              LDR      r0,[sp,#0x14]         ;737
00006e  b138              CBZ      r0,|L23.128|
000070  2050              MOVS     r0,#0x50              ;737
000072  f3808811          MSR      BASEPRI,r0            ;737
000076  f3bf8f4f          DSB                            ;737
00007a  f3bf8f6f          ISB                            ;737
                  |L23.126|
00007e  e7fe              B        |L23.126|
                  |L23.128|
000080  f7fffffe          BL       vPortEnterCritical
000084  6ba0              LDR      r0,[r4,#0x38]         ;753
000086  6be1              LDR      r1,[r4,#0x3c]         ;753
000088  4288              CMP      r0,r1                 ;753
00008a  d306              BCC      |L23.154|
00008c  f1b90f02          CMP      r9,#2                 ;753
000090  d003              BEQ      |L23.154|
;;;768    						}
;;;769    						else
;;;770    						{
;;;771    							mtCOVERAGE_TEST_MARKER();
;;;772    						}
;;;773    					}
;;;774    					else
;;;775    					{
;;;776    						/* If there was a task waiting for data to arrive on the
;;;777    						queue then unblock it now. */
;;;778    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;779    						{
;;;780    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;781    							{
;;;782    								/* The unblocked task has a priority higher than
;;;783    								our own so yield immediately.  Yes it is ok to
;;;784    								do this from within the critical section - the
;;;785    								kernel takes care of that. */
;;;786    								queueYIELD_IF_USING_PREEMPTION();
;;;787    							}
;;;788    							else
;;;789    							{
;;;790    								mtCOVERAGE_TEST_MARKER();
;;;791    							}
;;;792    						}
;;;793    						else if( xYieldRequired != pdFALSE )
;;;794    						{
;;;795    							/* This path is a special case that will only get
;;;796    							executed if the task was holding multiple mutexes
;;;797    							and the mutexes were given back in an order that is
;;;798    							different to that in which they were taken. */
;;;799    							queueYIELD_IF_USING_PREEMPTION();
;;;800    						}
;;;801    						else
;;;802    						{
;;;803    							mtCOVERAGE_TEST_MARKER();
;;;804    						}
;;;805    					}
;;;806    				}
;;;807    				#else /* configUSE_QUEUE_SETS */
;;;808    				{
;;;809    					/* If there was a task waiting for data to arrive on the
;;;810    					queue then unblock it now. */
;;;811    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;812    					{
;;;813    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;814    						{
;;;815    							/* The unblocked task has a priority higher than
;;;816    							our own so yield immediately.  Yes it is ok to do
;;;817    							this from within the critical section - the kernel
;;;818    							takes care of that. */
;;;819    							queueYIELD_IF_USING_PREEMPTION();
;;;820    						}
;;;821    						else
;;;822    						{
;;;823    							mtCOVERAGE_TEST_MARKER();
;;;824    						}
;;;825    					}
;;;826    					else if( xYieldRequired != pdFALSE )
;;;827    					{
;;;828    						/* This path is a special case that will only get
;;;829    						executed if the task was holding multiple mutexes and
;;;830    						the mutexes were given back in an order that is
;;;831    						different to that in which they were taken. */
;;;832    						queueYIELD_IF_USING_PREEMPTION();
;;;833    					}
;;;834    					else
;;;835    					{
;;;836    						mtCOVERAGE_TEST_MARKER();
;;;837    					}
;;;838    				}
;;;839    				#endif /* configUSE_QUEUE_SETS */
;;;840    
;;;841    				taskEXIT_CRITICAL();
;;;842    				return pdPASS;
;;;843    			}
;;;844    			else
;;;845    			{
;;;846    				if( xTicksToWait == ( TickType_t ) 0 )
000092  9805              LDR      r0,[sp,#0x14]
000094  b300              CBZ      r0,|L23.216|
;;;847    				{
;;;848    					/* The queue was full and no block time is specified (or
;;;849    					the block time has expired) so leave now. */
;;;850    					taskEXIT_CRITICAL();
;;;851    
;;;852    					/* Return to the original privilege level before exiting
;;;853    					the function. */
;;;854    					traceQUEUE_SEND_FAILED( pxQueue );
;;;855    					return errQUEUE_FULL;
;;;856    				}
;;;857    				else if( xEntryTimeSet == pdFALSE )
000096  b316              CBZ      r6,|L23.222|
000098  e025              B        |L23.230|
                  |L23.154|
00009a  464a              MOV      r2,r9                 ;756
00009c  4659              MOV      r1,r11                ;756
00009e  4620              MOV      r0,r4                 ;756
0000a0  f7fffffe          BL       prvCopyDataToQueue
0000a4  6ca1              LDR      r1,[r4,#0x48]         ;760
0000a6  b121              CBZ      r1,|L23.178|
0000a8  4649              MOV      r1,r9                 ;762
0000aa  4620              MOV      r0,r4                 ;762
0000ac  f7fffffe          BL       prvNotifyQueueSetContainer
0000b0  e005              B        |L23.190|
                  |L23.178|
0000b2  6a61              LDR      r1,[r4,#0x24]         ;778
0000b4  b119              CBZ      r1,|L23.190|
0000b6  f1040024          ADD      r0,r4,#0x24           ;780
0000ba  f7fffffe          BL       xTaskRemoveFromEventList
                  |L23.190|
0000be  b128              CBZ      r0,|L23.204|
0000c0  f8c87000          STR      r7,[r8,#0]            ;799
0000c4  f3bf8f4f          DSB                            ;799
0000c8  f3bf8f6f          ISB                            ;799
                  |L23.204|
0000cc  f7fffffe          BL       vPortExitCritical
0000d0  2001              MOVS     r0,#1                 ;842
                  |L23.210|
;;;858    				{
;;;859    					/* The queue was full and a block time was specified so
;;;860    					configure the timeout structure. */
;;;861    					vTaskInternalSetTimeOutState( &xTimeOut );
;;;862    					xEntryTimeSet = pdTRUE;
;;;863    				}
;;;864    				else
;;;865    				{
;;;866    					/* Entry time was already set. */
;;;867    					mtCOVERAGE_TEST_MARKER();
;;;868    				}
;;;869    			}
;;;870    		}
;;;871    		taskEXIT_CRITICAL();
;;;872    
;;;873    		/* Interrupts and other tasks can send to and receive from the queue
;;;874    		now the critical section has been exited. */
;;;875    
;;;876    		vTaskSuspendAll();
;;;877    		prvLockQueue( pxQueue );
;;;878    
;;;879    		/* Update the timeout state to see if it has expired yet. */
;;;880    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;881    		{
;;;882    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;883    			{
;;;884    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;885    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;886    
;;;887    				/* Unlocking the queue means queue events can effect the
;;;888    				event list.  It is possible that interrupts occurring now
;;;889    				remove this task from the event list again - but as the
;;;890    				scheduler is suspended the task will go onto the pending
;;;891    				ready last instead of the actual ready list. */
;;;892    				prvUnlockQueue( pxQueue );
;;;893    
;;;894    				/* Resuming the scheduler will move tasks from the pending
;;;895    				ready list into the ready list - so it is feasible that this
;;;896    				task is already in a ready list before it yields - in which
;;;897    				case the yield will not cause a context switch unless there
;;;898    				is also a higher priority task in the pending ready list. */
;;;899    				if( xTaskResumeAll() == pdFALSE )
;;;900    				{
;;;901    					portYIELD_WITHIN_API();
;;;902    				}
;;;903    			}
;;;904    			else
;;;905    			{
;;;906    				/* Try again. */
;;;907    				prvUnlockQueue( pxQueue );
;;;908    				( void ) xTaskResumeAll();
;;;909    			}
;;;910    		}
;;;911    		else
;;;912    		{
;;;913    			/* The timeout has expired. */
;;;914    			prvUnlockQueue( pxQueue );
;;;915    			( void ) xTaskResumeAll();
;;;916    
;;;917    			traceQUEUE_SEND_FAILED( pxQueue );
;;;918    			return errQUEUE_FULL;
;;;919    		}
;;;920    	}
;;;921    }
0000d2  b007              ADD      sp,sp,#0x1c
0000d4  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.216|
0000d8  f7fffffe          BL       vPortExitCritical
0000dc  e021              B        |L23.290|
                  |L23.222|
0000de  4668              MOV      r0,sp                 ;861
0000e0  f7fffffe          BL       vTaskInternalSetTimeOutState
0000e4  2601              MOVS     r6,#1                 ;862
                  |L23.230|
0000e6  f7fffffe          BL       vPortExitCritical
0000ea  f7fffffe          BL       vTaskSuspendAll
0000ee  f7fffffe          BL       vPortEnterCritical
0000f2  f9940044          LDRSB    r0,[r4,#0x44]         ;877
0000f6  1c40              ADDS     r0,r0,#1              ;877
0000f8  d101              BNE      |L23.254|
0000fa  f884a044          STRB     r10,[r4,#0x44]        ;877
                  |L23.254|
0000fe  f9940045          LDRSB    r0,[r4,#0x45]         ;877
000102  1c40              ADDS     r0,r0,#1              ;877
000104  d101              BNE      |L23.266|
000106  f884a045          STRB     r10,[r4,#0x45]        ;877
                  |L23.266|
00010a  f7fffffe          BL       vPortExitCritical
00010e  a905              ADD      r1,sp,#0x14           ;880
000110  4668              MOV      r0,sp                 ;880
000112  f7fffffe          BL       xTaskCheckForTimeOut
000116  b130              CBZ      r0,|L23.294|
000118  4620              MOV      r0,r4                 ;914
00011a  f7fffffe          BL       prvUnlockQueue
00011e  f7fffffe          BL       xTaskResumeAll
                  |L23.290|
000122  2000              MOVS     r0,#0                 ;918
000124  e7d5              B        |L23.210|
                  |L23.294|
000126  f7fffffe          BL       vPortEnterCritical
00012a  6ba0              LDR      r0,[r4,#0x38]
00012c  6be1              LDR      r1,[r4,#0x3c]
00012e  4288              CMP      r0,r1
000130  d101              BNE      |L23.310|
000132  2501              MOVS     r5,#1
000134  e000              B        |L23.312|
                  |L23.310|
000136  2500              MOVS     r5,#0
                  |L23.312|
000138  f7fffffe          BL       vPortExitCritical
00013c  b195              CBZ      r5,|L23.356|
00013e  f1040010          ADD      r0,r4,#0x10           ;885
000142  9905              LDR      r1,[sp,#0x14]         ;885
000144  f7fffffe          BL       vTaskPlaceOnEventList
000148  4620              MOV      r0,r4                 ;892
00014a  f7fffffe          BL       prvUnlockQueue
00014e  f7fffffe          BL       xTaskResumeAll
000152  2800              CMP      r0,#0                 ;899
000154  d194              BNE      |L23.128|
000156  f8c87000          STR      r7,[r8,#0]            ;901
00015a  f3bf8f4f          DSB                            ;901
00015e  f3bf8f6f          ISB                            ;901
000162  e78d              B        |L23.128|
                  |L23.356|
000164  4620              MOV      r0,r4                 ;907
000166  f7fffffe          BL       prvUnlockQueue
00016a  f7fffffe          BL       xTaskResumeAll
00016e  e787              B        |L23.128|
;;;922    /*-----------------------------------------------------------*/
                          ENDP

                  |L23.368|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;923    
;;;924    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;925    {
000004  4698              MOV      r8,r3
000006  4615              MOV      r5,r2
000008  4689              MOV      r9,r1
00000a  0004              MOVS     r4,r0
00000c  d003              BEQ      |L24.22|
;;;926    BaseType_t xReturn;
;;;927    UBaseType_t uxSavedInterruptStatus;
;;;928    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;929    
;;;930    	configASSERT( pxQueue );
;;;931    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00000e  f1b90f00          CMP      r9,#0
000012  d008              BEQ      |L24.38|
000014  e011              B        |L24.58|
                  |L24.22|
000016  2050              MOVS     r0,#0x50
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
                  |L24.36|
000024  e7fe              B        |L24.36|
                  |L24.38|
000026  6c20              LDR      r0,[r4,#0x40]
000028  b138              CBZ      r0,|L24.58|
00002a  2050              MOVS     r0,#0x50
00002c  f3808811          MSR      BASEPRI,r0
000030  f3bf8f4f          DSB      
000034  f3bf8f6f          ISB      
                  |L24.56|
000038  e7fe              B        |L24.56|
                  |L24.58|
;;;932    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
00003a  f1b80f02          CMP      r8,#2
00003e  d10a              BNE      |L24.86|
000040  6be0              LDR      r0,[r4,#0x3c]
000042  2801              CMP      r0,#1
000044  d007              BEQ      |L24.86|
000046  2050              MOVS     r0,#0x50
000048  f3808811          MSR      BASEPRI,r0
00004c  f3bf8f4f          DSB      
000050  f3bf8f6f          ISB      
                  |L24.84|
000054  e7fe              B        |L24.84|
                  |L24.86|
;;;933    
;;;934    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;935    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;936    	above the maximum system call priority are kept permanently enabled, even
;;;937    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;938    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;939    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;940    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;941    	assigned a priority above the configured maximum system call priority.
;;;942    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;943    	that have been assigned a priority at or (logically) below the maximum
;;;944    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;945    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;946    	More information (albeit Cortex-M specific) is provided on the following
;;;947    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;948    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000056  f7fffffe          BL       vPortValidateInterruptPriority
00005a  2050              MOVS     r0,#0x50
00005c  f3ef8711          MRS      r7,BASEPRI
000060  f3808811          MSR      BASEPRI,r0
000064  f3bf8f4f          DSB      
000068  f3bf8f6f          ISB      
;;;949    
;;;950    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;951    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;952    	read, instead return a flag to say whether a context switch is required or
;;;953    	not (i.e. has a task with a higher priority than us been woken by this
;;;954    	post). */
;;;955    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;956    	{
;;;957    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
00006c  6ba0              LDR      r0,[r4,#0x38]
00006e  6be1              LDR      r1,[r4,#0x3c]
000070  4288              CMP      r0,r1
000072  d307              BCC      |L24.132|
000074  f1b80f02          CMP      r8,#2
000078  d004              BEQ      |L24.132|
;;;958    		{
;;;959    			const int8_t cTxLock = pxQueue->cTxLock;
;;;960    
;;;961    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;962    
;;;963    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;964    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;965    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;966    			called here even though the disinherit function does not check if
;;;967    			the scheduler is suspended before accessing the ready lists. */
;;;968    			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;969    
;;;970    			/* The event list is not altered if the queue is locked.  This will
;;;971    			be done when the queue is unlocked later. */
;;;972    			if( cTxLock == queueUNLOCKED )
;;;973    			{
;;;974    				#if ( configUSE_QUEUE_SETS == 1 )
;;;975    				{
;;;976    					if( pxQueue->pxQueueSetContainer != NULL )
;;;977    					{
;;;978    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;979    						{
;;;980    							/* The queue is a member of a queue set, and posting
;;;981    							to the queue set caused a higher priority task to
;;;982    							unblock.  A context switch is required. */
;;;983    							if( pxHigherPriorityTaskWoken != NULL )
;;;984    							{
;;;985    								*pxHigherPriorityTaskWoken = pdTRUE;
;;;986    							}
;;;987    							else
;;;988    							{
;;;989    								mtCOVERAGE_TEST_MARKER();
;;;990    							}
;;;991    						}
;;;992    						else
;;;993    						{
;;;994    							mtCOVERAGE_TEST_MARKER();
;;;995    						}
;;;996    					}
;;;997    					else
;;;998    					{
;;;999    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1000   						{
;;;1001   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1002   							{
;;;1003   								/* The task waiting has a higher priority so
;;;1004   								record that a context switch is required. */
;;;1005   								if( pxHigherPriorityTaskWoken != NULL )
;;;1006   								{
;;;1007   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1008   								}
;;;1009   								else
;;;1010   								{
;;;1011   									mtCOVERAGE_TEST_MARKER();
;;;1012   								}
;;;1013   							}
;;;1014   							else
;;;1015   							{
;;;1016   								mtCOVERAGE_TEST_MARKER();
;;;1017   							}
;;;1018   						}
;;;1019   						else
;;;1020   						{
;;;1021   							mtCOVERAGE_TEST_MARKER();
;;;1022   						}
;;;1023   					}
;;;1024   				}
;;;1025   				#else /* configUSE_QUEUE_SETS */
;;;1026   				{
;;;1027   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1028   					{
;;;1029   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1030   						{
;;;1031   							/* The task waiting has a higher priority so record that a
;;;1032   							context	switch is required. */
;;;1033   							if( pxHigherPriorityTaskWoken != NULL )
;;;1034   							{
;;;1035   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1036   							}
;;;1037   							else
;;;1038   							{
;;;1039   								mtCOVERAGE_TEST_MARKER();
;;;1040   							}
;;;1041   						}
;;;1042   						else
;;;1043   						{
;;;1044   							mtCOVERAGE_TEST_MARKER();
;;;1045   						}
;;;1046   					}
;;;1047   					else
;;;1048   					{
;;;1049   						mtCOVERAGE_TEST_MARKER();
;;;1050   					}
;;;1051   				}
;;;1052   				#endif /* configUSE_QUEUE_SETS */
;;;1053   			}
;;;1054   			else
;;;1055   			{
;;;1056   				/* Increment the lock count so the task that unlocks the queue
;;;1057   				knows that data was posted while it was locked. */
;;;1058   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
;;;1059   			}
;;;1060   
;;;1061   			xReturn = pdPASS;
;;;1062   		}
;;;1063   		else
;;;1064   		{
;;;1065   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1066   			xReturn = errQUEUE_FULL;
00007a  2000              MOVS     r0,#0
                  |L24.124|
00007c  f3878811          MSR      BASEPRI,r7
;;;1067   		}
;;;1068   	}
;;;1069   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1070   
;;;1071   	return xReturn;
;;;1072   }
000080  e8bd87f0          POP      {r4-r10,pc}
                  |L24.132|
000084  f9946045          LDRSB    r6,[r4,#0x45]         ;959
000088  4642              MOV      r2,r8                 ;968
00008a  4649              MOV      r1,r9                 ;968
00008c  4620              MOV      r0,r4                 ;968
00008e  f7fffffe          BL       prvCopyDataToQueue
000092  1c70              ADDS     r0,r6,#1              ;972
000094  d004              BEQ      |L24.160|
000096  1c76              ADDS     r6,r6,#1              ;972
000098  f8846045          STRB     r6,[r4,#0x45]         ;1058
                  |L24.156|
00009c  2001              MOVS     r0,#1                 ;1061
00009e  e7ed              B        |L24.124|
                  |L24.160|
0000a0  6ca0              LDR      r0,[r4,#0x48]         ;976
0000a2  2601              MOVS     r6,#1                 ;932
0000a4  b120              CBZ      r0,|L24.176|
0000a6  4641              MOV      r1,r8                 ;978
0000a8  4620              MOV      r0,r4                 ;978
0000aa  f7fffffe          BL       prvNotifyQueueSetContainer
0000ae  e006              B        |L24.190|
                  |L24.176|
0000b0  6a60              LDR      r0,[r4,#0x24]         ;999
0000b2  2800              CMP      r0,#0                 ;999
0000b4  d0f2              BEQ      |L24.156|
0000b6  f1040024          ADD      r0,r4,#0x24           ;1001
0000ba  f7fffffe          BL       xTaskRemoveFromEventList
                  |L24.190|
0000be  2800              CMP      r0,#0                 ;1001
0000c0  d0ec              BEQ      |L24.156|
0000c2  2d00              CMP      r5,#0                 ;1005
0000c4  d0ea              BEQ      |L24.156|
0000c6  602e              STR      r6,[r5,#0]            ;1007
0000c8  e7e8              B        |L24.156|
;;;1073   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGiveFromISR PROC
;;;1074   
;;;1075   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1076   {
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d009              BEQ      |L25.30|
;;;1077   BaseType_t xReturn;
;;;1078   UBaseType_t uxSavedInterruptStatus;
;;;1079   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1080   
;;;1081   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1082   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1083   	read, instead return a flag to say whether a context switch is required or
;;;1084   	not (i.e. has a task with a higher priority than us been woken by this
;;;1085   	post). */
;;;1086   
;;;1087   	configASSERT( pxQueue );
;;;1088   
;;;1089   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1090   	if the item size is not 0. */
;;;1091   	configASSERT( pxQueue->uxItemSize == 0 );
00000a  6c20              LDR      r0,[r4,#0x40]
00000c  b178              CBZ      r0,|L25.46|
00000e  2050              MOVS     r0,#0x50
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
                  |L25.28|
00001c  e7fe              B        |L25.28|
                  |L25.30|
00001e  2050              MOVS     r0,#0x50
000020  f3808811          MSR      BASEPRI,r0
000024  f3bf8f4f          DSB      
000028  f3bf8f6f          ISB      
                  |L25.44|
00002c  e7fe              B        |L25.44|
                  |L25.46|
;;;1092   
;;;1093   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1094   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1095   	interrupts, only tasks. */
;;;1096   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
00002e  6820              LDR      r0,[r4,#0]
000030  b948              CBNZ     r0,|L25.70|
000032  6860              LDR      r0,[r4,#4]
000034  b138              CBZ      r0,|L25.70|
000036  2050              MOVS     r0,#0x50
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
                  |L25.68|
000044  e7fe              B        |L25.68|
                  |L25.70|
;;;1097   
;;;1098   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1099   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1100   	above the maximum system call priority are kept permanently enabled, even
;;;1101   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1102   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1103   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1104   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1105   	assigned a priority above the configured maximum system call priority.
;;;1106   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1107   	that have been assigned a priority at or (logically) below the maximum
;;;1108   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1109   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1110   	More information (albeit Cortex-M specific) is provided on the following
;;;1111   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1112   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000046  f7fffffe          BL       vPortValidateInterruptPriority
00004a  2050              MOVS     r0,#0x50
00004c  f3ef8611          MRS      r6,BASEPRI
000050  f3808811          MSR      BASEPRI,r0
000054  f3bf8f4f          DSB      
000058  f3bf8f6f          ISB      
;;;1113   
;;;1114   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1115   	{
;;;1116   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00005c  6ba1              LDR      r1,[r4,#0x38]
;;;1117   
;;;1118   		/* When the queue is used to implement a semaphore no data is ever
;;;1119   		moved through the queue but it is still valid to see if the queue 'has
;;;1120   		space'. */
;;;1121   		if( uxMessagesWaiting < pxQueue->uxLength )
00005e  6be0              LDR      r0,[r4,#0x3c]
000060  4288              CMP      r0,r1
000062  d91f              BLS      |L25.164|
;;;1122   		{
;;;1123   			const int8_t cTxLock = pxQueue->cTxLock;
000064  f9940045          LDRSB    r0,[r4,#0x45]
000068  1c49              ADDS     r1,r1,#1
;;;1124   
;;;1125   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1126   
;;;1127   			/* A task can only have an inherited priority if it is a mutex
;;;1128   			holder - and if there is a mutex holder then the mutex cannot be
;;;1129   			given from an ISR.  As this is the ISR version of the function it
;;;1130   			can be assumed there is no mutex holder and no need to determine if
;;;1131   			priority disinheritance is needed.  Simply increase the count of
;;;1132   			messages (semaphores) available. */
;;;1133   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
00006a  63a1              STR      r1,[r4,#0x38]
;;;1134   
;;;1135   			/* The event list is not altered if the queue is locked.  This will
;;;1136   			be done when the queue is unlocked later. */
;;;1137   			if( cTxLock == queueUNLOCKED )
00006c  1c41              ADDS     r1,r0,#1
00006e  d004              BEQ      |L25.122|
000070  1c40              ADDS     r0,r0,#1
;;;1138   			{
;;;1139   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1140   				{
;;;1141   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1142   					{
;;;1143   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;1144   						{
;;;1145   							/* The semaphore is a member of a queue set, and
;;;1146   							posting	to the queue set caused a higher priority
;;;1147   							task to	unblock.  A context switch is required. */
;;;1148   							if( pxHigherPriorityTaskWoken != NULL )
;;;1149   							{
;;;1150   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1151   							}
;;;1152   							else
;;;1153   							{
;;;1154   								mtCOVERAGE_TEST_MARKER();
;;;1155   							}
;;;1156   						}
;;;1157   						else
;;;1158   						{
;;;1159   							mtCOVERAGE_TEST_MARKER();
;;;1160   						}
;;;1161   					}
;;;1162   					else
;;;1163   					{
;;;1164   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1165   						{
;;;1166   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1167   							{
;;;1168   								/* The task waiting has a higher priority so
;;;1169   								record that a context switch is required. */
;;;1170   								if( pxHigherPriorityTaskWoken != NULL )
;;;1171   								{
;;;1172   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1173   								}
;;;1174   								else
;;;1175   								{
;;;1176   									mtCOVERAGE_TEST_MARKER();
;;;1177   								}
;;;1178   							}
;;;1179   							else
;;;1180   							{
;;;1181   								mtCOVERAGE_TEST_MARKER();
;;;1182   							}
;;;1183   						}
;;;1184   						else
;;;1185   						{
;;;1186   							mtCOVERAGE_TEST_MARKER();
;;;1187   						}
;;;1188   					}
;;;1189   				}
;;;1190   				#else /* configUSE_QUEUE_SETS */
;;;1191   				{
;;;1192   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1193   					{
;;;1194   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1195   						{
;;;1196   							/* The task waiting has a higher priority so record that a
;;;1197   							context	switch is required. */
;;;1198   							if( pxHigherPriorityTaskWoken != NULL )
;;;1199   							{
;;;1200   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1201   							}
;;;1202   							else
;;;1203   							{
;;;1204   								mtCOVERAGE_TEST_MARKER();
;;;1205   							}
;;;1206   						}
;;;1207   						else
;;;1208   						{
;;;1209   							mtCOVERAGE_TEST_MARKER();
;;;1210   						}
;;;1211   					}
;;;1212   					else
;;;1213   					{
;;;1214   						mtCOVERAGE_TEST_MARKER();
;;;1215   					}
;;;1216   				}
;;;1217   				#endif /* configUSE_QUEUE_SETS */
;;;1218   			}
;;;1219   			else
;;;1220   			{
;;;1221   				/* Increment the lock count so the task that unlocks the queue
;;;1222   				knows that data was posted while it was locked. */
;;;1223   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
000072  f8840045          STRB     r0,[r4,#0x45]
                  |L25.118|
;;;1224   			}
;;;1225   
;;;1226   			xReturn = pdPASS;
000076  2001              MOVS     r0,#1
;;;1227   		}
000078  e015              B        |L25.166|
                  |L25.122|
00007a  6ca0              LDR      r0,[r4,#0x48]         ;1141
00007c  2701              MOVS     r7,#1                 ;1150
00007e  b120              CBZ      r0,|L25.138|
000080  2100              MOVS     r1,#0                 ;1143
000082  4620              MOV      r0,r4                 ;1143
000084  f7fffffe          BL       prvNotifyQueueSetContainer
000088  e006              B        |L25.152|
                  |L25.138|
00008a  6a60              LDR      r0,[r4,#0x24]         ;1164
00008c  2800              CMP      r0,#0                 ;1164
00008e  d0f2              BEQ      |L25.118|
000090  f1040024          ADD      r0,r4,#0x24           ;1166
000094  f7fffffe          BL       xTaskRemoveFromEventList
                  |L25.152|
000098  2800              CMP      r0,#0                 ;1166
00009a  d0ec              BEQ      |L25.118|
00009c  2d00              CMP      r5,#0                 ;1170
00009e  d0ea              BEQ      |L25.118|
0000a0  602f              STR      r7,[r5,#0]            ;1172
0000a2  e7e8              B        |L25.118|
                  |L25.164|
;;;1228   		else
;;;1229   		{
;;;1230   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1231   			xReturn = errQUEUE_FULL;
0000a4  2000              MOVS     r0,#0
                  |L25.166|
0000a6  f3868811          MSR      BASEPRI,r6
;;;1232   		}
;;;1233   	}
;;;1234   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1235   
;;;1236   	return xReturn;
;;;1237   }
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;1238   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveMutexRecursive||, CODE, READONLY, ALIGN=1

                  xQueueGiveMutexRecursive PROC
;;;574    
;;;575    	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
000000  b510              PUSH     {r4,lr}
;;;576    	{
000002  0004              MOVS     r4,r0
000004  d009              BEQ      |L26.26|
;;;577    	BaseType_t xReturn;
;;;578    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
;;;579    
;;;580    		configASSERT( pxMutex );
;;;581    
;;;582    		/* If this is the task that holds the mutex then pxMutexHolder will not
;;;583    		change outside of this task.  If this task does not hold the mutex then
;;;584    		pxMutexHolder can never coincidentally equal the tasks handle, and as
;;;585    		this is the only condition we are interested in it does not matter if
;;;586    		pxMutexHolder is accessed simultaneously by another task.  Therefore no
;;;587    		mutual exclusion is required to test the pxMutexHolder variable. */
;;;588    		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
000006  f7fffffe          BL       xTaskGetCurrentTaskHandle
00000a  6861              LDR      r1,[r4,#4]
00000c  4288              CMP      r0,r1
00000e  d114              BNE      |L26.58|
;;;589    		{
;;;590    			traceGIVE_MUTEX_RECURSIVE( pxMutex );
;;;591    
;;;592    			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
;;;593    			the task handle, therefore no underflow check is required.  Also,
;;;594    			uxRecursiveCallCount is only modified by the mutex holder, and as
;;;595    			there can only be one, no mutual exclusion is required to modify the
;;;596    			uxRecursiveCallCount member. */
;;;597    			( pxMutex->u.uxRecursiveCallCount )--;
000010  68e0              LDR      r0,[r4,#0xc]
000012  1e40              SUBS     r0,r0,#1
;;;598    
;;;599    			/* Has the recursive call count unwound to 0? */
;;;600    			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
000014  60e0              STR      r0,[r4,#0xc]
000016  d008              BEQ      |L26.42|
000018  e00d              B        |L26.54|
                  |L26.26|
00001a  2050              MOVS     r0,#0x50
00001c  f3808811          MSR      BASEPRI,r0
000020  f3bf8f4f          DSB      
000024  f3bf8f6f          ISB      
                  |L26.40|
000028  e7fe              B        |L26.40|
                  |L26.42|
;;;601    			{
;;;602    				/* Return the mutex.  This will automatically unblock any other
;;;603    				task that might be waiting to access the mutex. */
;;;604    				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
00002a  2300              MOVS     r3,#0
00002c  461a              MOV      r2,r3
00002e  4619              MOV      r1,r3
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       xQueueGenericSend
                  |L26.54|
;;;605    			}
;;;606    			else
;;;607    			{
;;;608    				mtCOVERAGE_TEST_MARKER();
;;;609    			}
;;;610    
;;;611    			xReturn = pdPASS;
000036  2001              MOVS     r0,#1
;;;612    		}
;;;613    		else
;;;614    		{
;;;615    			/* The mutex cannot be given because the calling task is not the
;;;616    			holder. */
;;;617    			xReturn = pdFAIL;
;;;618    
;;;619    			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;620    		}
;;;621    
;;;622    		return xReturn;
;;;623    	}
000038  bd10              POP      {r4,pc}
                  |L26.58|
00003a  2000              MOVS     r0,#0                 ;617
00003c  bd10              POP      {r4,pc}
;;;624    
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;2278   
;;;2279   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  b118              CBZ      r0,|L27.10|
;;;2280   {
;;;2281   BaseType_t xReturn;
;;;2282   
;;;2283   	configASSERT( xQueue );
;;;2284   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
000002  6b80              LDR      r0,[r0,#0x38]
000004  b148              CBZ      r0,|L27.26|
;;;2285   	{
;;;2286   		xReturn = pdTRUE;
;;;2287   	}
;;;2288   	else
;;;2289   	{
;;;2290   		xReturn = pdFALSE;
000006  2000              MOVS     r0,#0
;;;2291   	}
;;;2292   
;;;2293   	return xReturn;
;;;2294   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000008  4770              BX       lr
                  |L27.10|
00000a  2050              MOVS     r0,#0x50
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
                  |L27.24|
000018  e7fe              B        |L27.24|
                  |L27.26|
00001a  2001              MOVS     r0,#1                 ;2286
00001c  4770              BX       lr
;;;2295   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;2317   
;;;2318   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  b128              CBZ      r0,|L28.14|
;;;2319   {
;;;2320   BaseType_t xReturn;
;;;2321   
;;;2322   	configASSERT( xQueue );
;;;2323   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
000002  6b81              LDR      r1,[r0,#0x38]
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  4281              CMP      r1,r0
000008  d109              BNE      |L28.30|
;;;2324   	{
;;;2325   		xReturn = pdTRUE;
00000a  2001              MOVS     r0,#1
;;;2326   	}
;;;2327   	else
;;;2328   	{
;;;2329   		xReturn = pdFALSE;
;;;2330   	}
;;;2331   
;;;2332   	return xReturn;
;;;2333   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00000c  4770              BX       lr
                  |L28.14|
00000e  2050              MOVS     r0,#0x50
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
                  |L28.28|
00001c  e7fe              B        |L28.28|
                  |L28.30|
00001e  2000              MOVS     r0,#0                 ;2329
000020  4770              BX       lr
;;;2334   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeek||, CODE, READONLY, ALIGN=2

                  xQueuePeek PROC
;;;1600   
;;;1601   BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d43f7          PUSH     {r0-r2,r4-r9,lr}
;;;1602   {
000004  b082              SUB      sp,sp,#8
000006  4689              MOV      r9,r1
000008  0004              MOVS     r4,r0
;;;1603   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0500          MOV      r5,#0
00000e  d003              BEQ      |L29.24|
;;;1604   TimeOut_t xTimeOut;
;;;1605   int8_t *pcOriginalReadPosition;
;;;1606   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1607   
;;;1608   	/* Check the pointer is not NULL. */
;;;1609   	configASSERT( ( pxQueue ) );
;;;1610   
;;;1611   	/* The buffer into which data is received can only be NULL if the data size
;;;1612   	is zero (so no data is copied into the buffer. */
;;;1613   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
000010  f1b90f00          CMP      r9,#0
000014  d008              BEQ      |L29.40|
000016  e011              B        |L29.60|
                  |L29.24|
000018  2050              MOVS     r0,#0x50
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
                  |L29.38|
000026  e7fe              B        |L29.38|
                  |L29.40|
000028  6c20              LDR      r0,[r4,#0x40]
00002a  b138              CBZ      r0,|L29.60|
00002c  2050              MOVS     r0,#0x50
00002e  f3808811          MSR      BASEPRI,r0
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
                  |L29.58|
00003a  e7fe              B        |L29.58|
                  |L29.60|
;;;1614   
;;;1615   	/* Cannot block if the scheduler is suspended. */
;;;1616   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1617   	{
;;;1618   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00003c  f7fffffe          BL       xTaskGetSchedulerState
;;;1619   	}
;;;1620   	#endif
;;;1621   
;;;1622   
;;;1623   	/* This function relaxes the coding standard somewhat to allow return
;;;1624   	statements within the function itself.  This is done in the interest
;;;1625   	of execution time efficiency. */
;;;1626   
;;;1627   	for( ;; )
;;;1628   	{
;;;1629   		taskENTER_CRITICAL();
;;;1630   		{
;;;1631   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
;;;1632   
;;;1633   			/* Is there data in the queue now?  To be running the calling task
;;;1634   			must be the highest priority task wanting to access the queue. */
;;;1635   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
;;;1636   			{
;;;1637   				/* Remember the read position so it can be reset after the data
;;;1638   				is read from the queue as this function is only peeking the
;;;1639   				data, not removing it. */
;;;1640   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1641   
;;;1642   				prvCopyDataFromQueue( pxQueue, pvBuffer );
;;;1643   				traceQUEUE_PEEK( pxQueue );
;;;1644   
;;;1645   				/* The data is not being removed, so reset the read pointer. */
;;;1646   				pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1647   
;;;1648   				/* The data is being left in the queue, so see if there are
;;;1649   				any other tasks waiting for the data. */
;;;1650   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1651   				{
;;;1652   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1653   					{
;;;1654   						/* The task waiting has a higher priority than this task. */
;;;1655   						queueYIELD_IF_USING_PREEMPTION();
000040  f8df80f0          LDR      r8,|L29.308|
000044  2600              MOVS     r6,#0                 ;1618
000046  f04f5780          MOV      r7,#0x10000000
00004a  b948              CBNZ     r0,|L29.96|
00004c  9804              LDR      r0,[sp,#0x10]         ;1618
00004e  b138              CBZ      r0,|L29.96|
000050  2050              MOVS     r0,#0x50              ;1618
000052  f3808811          MSR      BASEPRI,r0            ;1618
000056  f3bf8f4f          DSB                            ;1618
00005a  f3bf8f6f          ISB                            ;1618
                  |L29.94|
00005e  e7fe              B        |L29.94|
                  |L29.96|
000060  f7fffffe          BL       vPortEnterCritical
000064  6ba0              LDR      r0,[r4,#0x38]         ;1631
000066  b1c0              CBZ      r0,|L29.154|
000068  4649              MOV      r1,r9                 ;1642
00006a  4620              MOV      r0,r4                 ;1642
00006c  68e5              LDR      r5,[r4,#0xc]          ;1642
00006e  f7fffffe          BL       prvCopyDataFromQueue
000072  60e5              STR      r5,[r4,#0xc]          ;1650
000074  6a60              LDR      r0,[r4,#0x24]         ;1650
000076  b150              CBZ      r0,|L29.142|
000078  f1040024          ADD      r0,r4,#0x24           ;1652
00007c  f7fffffe          BL       xTaskRemoveFromEventList
000080  b128              CBZ      r0,|L29.142|
000082  f8c87000          STR      r7,[r8,#0]
000086  f3bf8f4f          DSB      
00008a  f3bf8f6f          ISB      
                  |L29.142|
;;;1656   					}
;;;1657   					else
;;;1658   					{
;;;1659   						mtCOVERAGE_TEST_MARKER();
;;;1660   					}
;;;1661   				}
;;;1662   				else
;;;1663   				{
;;;1664   					mtCOVERAGE_TEST_MARKER();
;;;1665   				}
;;;1666   
;;;1667   				taskEXIT_CRITICAL();
00008e  f7fffffe          BL       vPortExitCritical
;;;1668   				return pdPASS;
000092  2001              MOVS     r0,#1
                  |L29.148|
;;;1669   			}
;;;1670   			else
;;;1671   			{
;;;1672   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1673   				{
;;;1674   					/* The queue was empty and no block time is specified (or
;;;1675   					the block time has expired) so leave now. */
;;;1676   					taskEXIT_CRITICAL();
;;;1677   					traceQUEUE_PEEK_FAILED( pxQueue );
;;;1678   					return errQUEUE_EMPTY;
;;;1679   				}
;;;1680   				else if( xEntryTimeSet == pdFALSE )
;;;1681   				{
;;;1682   					/* The queue was empty and a block time was specified so
;;;1683   					configure the timeout structure ready to enter the blocked
;;;1684   					state. */
;;;1685   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1686   					xEntryTimeSet = pdTRUE;
;;;1687   				}
;;;1688   				else
;;;1689   				{
;;;1690   					/* Entry time was already set. */
;;;1691   					mtCOVERAGE_TEST_MARKER();
;;;1692   				}
;;;1693   			}
;;;1694   		}
;;;1695   		taskEXIT_CRITICAL();
;;;1696   
;;;1697   		/* Interrupts and other tasks can send to and receive from the queue
;;;1698   		now the critical section has been exited. */
;;;1699   
;;;1700   		vTaskSuspendAll();
;;;1701   		prvLockQueue( pxQueue );
;;;1702   
;;;1703   		/* Update the timeout state to see if it has expired yet. */
;;;1704   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1705   		{
;;;1706   			/* Timeout has not expired yet, check to see if there is data in the
;;;1707   			queue now, and if not enter the Blocked state to wait for data. */
;;;1708   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1709   			{
;;;1710   				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
;;;1711   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1712   				prvUnlockQueue( pxQueue );
;;;1713   				if( xTaskResumeAll() == pdFALSE )
;;;1714   				{
;;;1715   					portYIELD_WITHIN_API();
;;;1716   				}
;;;1717   				else
;;;1718   				{
;;;1719   					mtCOVERAGE_TEST_MARKER();
;;;1720   				}
;;;1721   			}
;;;1722   			else
;;;1723   			{
;;;1724   				/* There is data in the queue now, so don't enter the blocked
;;;1725   				state, instead return to try and obtain the data. */
;;;1726   				prvUnlockQueue( pxQueue );
;;;1727   				( void ) xTaskResumeAll();
;;;1728   			}
;;;1729   		}
;;;1730   		else
;;;1731   		{
;;;1732   			/* The timeout has expired.  If there is still no data in the queue
;;;1733   			exit, otherwise go back and try to read the data again. */
;;;1734   			prvUnlockQueue( pxQueue );
;;;1735   			( void ) xTaskResumeAll();
;;;1736   
;;;1737   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1738   			{
;;;1739   				traceQUEUE_PEEK_FAILED( pxQueue );
;;;1740   				return errQUEUE_EMPTY;
;;;1741   			}
;;;1742   			else
;;;1743   			{
;;;1744   				mtCOVERAGE_TEST_MARKER();
;;;1745   			}
;;;1746   		}
;;;1747   	}
;;;1748   }
000094  b005              ADD      sp,sp,#0x14
000096  e8bd83f0          POP      {r4-r9,pc}
                  |L29.154|
00009a  9804              LDR      r0,[sp,#0x10]         ;1672
00009c  b108              CBZ      r0,|L29.162|
00009e  b11d              CBZ      r5,|L29.168|
0000a0  e006              B        |L29.176|
                  |L29.162|
0000a2  f7fffffe          BL       vPortExitCritical
0000a6  e027              B        |L29.248|
                  |L29.168|
0000a8  4668              MOV      r0,sp                 ;1685
0000aa  f7fffffe          BL       vTaskInternalSetTimeOutState
0000ae  2501              MOVS     r5,#1                 ;1686
                  |L29.176|
0000b0  f7fffffe          BL       vPortExitCritical
0000b4  f7fffffe          BL       vTaskSuspendAll
0000b8  f7fffffe          BL       vPortEnterCritical
0000bc  f9940044          LDRSB    r0,[r4,#0x44]         ;1701
0000c0  1c40              ADDS     r0,r0,#1              ;1701
0000c2  d101              BNE      |L29.200|
0000c4  f8846044          STRB     r6,[r4,#0x44]         ;1701
                  |L29.200|
0000c8  f9940045          LDRSB    r0,[r4,#0x45]         ;1701
0000cc  1c40              ADDS     r0,r0,#1              ;1701
0000ce  d101              BNE      |L29.212|
0000d0  f8846045          STRB     r6,[r4,#0x45]         ;1701
                  |L29.212|
0000d4  f7fffffe          BL       vPortExitCritical
0000d8  a904              ADD      r1,sp,#0x10           ;1704
0000da  4668              MOV      r0,sp                 ;1704
0000dc  f7fffffe          BL       xTaskCheckForTimeOut
0000e0  2800              CMP      r0,#0                 ;1704
0000e2  4620              MOV      r0,r4                 ;1734
0000e4  d00a              BEQ      |L29.252|
0000e6  f7fffffe          BL       prvUnlockQueue
0000ea  f7fffffe          BL       xTaskResumeAll
0000ee  4620              MOV      r0,r4                 ;1737
0000f0  f7fffffe          BL       prvIsQueueEmpty
0000f4  2800              CMP      r0,#0                 ;1737
0000f6  d0b3              BEQ      |L29.96|
                  |L29.248|
0000f8  2000              MOVS     r0,#0                 ;1740
0000fa  e7cb              B        |L29.148|
                  |L29.252|
0000fc  f7fffffe          BL       prvIsQueueEmpty
000100  b190              CBZ      r0,|L29.296|
000102  f1040024          ADD      r0,r4,#0x24           ;1711
000106  9904              LDR      r1,[sp,#0x10]         ;1711
000108  f7fffffe          BL       vTaskPlaceOnEventList
00010c  4620              MOV      r0,r4                 ;1712
00010e  f7fffffe          BL       prvUnlockQueue
000112  f7fffffe          BL       xTaskResumeAll
000116  2800              CMP      r0,#0                 ;1713
000118  d1a2              BNE      |L29.96|
00011a  f8c87000          STR      r7,[r8,#0]            ;1715
00011e  f3bf8f4f          DSB                            ;1715
000122  f3bf8f6f          ISB                            ;1715
000126  e79b              B        |L29.96|
                  |L29.296|
000128  4620              MOV      r0,r4                 ;1726
00012a  f7fffffe          BL       prvUnlockQueue
00012e  f7fffffe          BL       xTaskResumeAll
000132  e795              B        |L29.96|
;;;1749   /*-----------------------------------------------------------*/
                          ENDP

                  |L29.308|
                          DCD      0xe000ed04

                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1841   
;;;1842   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1843   {
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d01a              BEQ      |L30.64|
;;;1844   BaseType_t xReturn;
;;;1845   UBaseType_t uxSavedInterruptStatus;
;;;1846   int8_t *pcOriginalReadPosition;
;;;1847   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1848   
;;;1849   	configASSERT( pxQueue );
;;;1850   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00000a  b30e              CBZ      r6,|L30.80|
;;;1851   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  b348              CBZ      r0,|L30.100|
;;;1852   
;;;1853   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1854   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1855   	above the maximum system call priority are kept permanently enabled, even
;;;1856   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1857   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1858   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1859   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1860   	assigned a priority above the configured maximum system call priority.
;;;1861   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1862   	that have been assigned a priority at or (logically) below the maximum
;;;1863   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1864   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1865   	More information (albeit Cortex-M specific) is provided on the following
;;;1866   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1867   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000010  f7fffffe          BL       vPortValidateInterruptPriority
000014  2050              MOVS     r0,#0x50
000016  f3ef8511          MRS      r5,BASEPRI
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
;;;1868   
;;;1869   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1870   	{
;;;1871   		/* Cannot block in an ISR, so check there is data available. */
;;;1872   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000026  6ba0              LDR      r0,[r4,#0x38]
000028  b130              CBZ      r0,|L30.56|
;;;1873   		{
;;;1874   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1875   
;;;1876   			/* Remember the read position so it can be reset as nothing is
;;;1877   			actually being removed from the queue. */
;;;1878   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1879   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00002a  4631              MOV      r1,r6
00002c  4620              MOV      r0,r4
00002e  68e7              LDR      r7,[r4,#0xc]
000030  f7fffffe          BL       prvCopyDataFromQueue
;;;1880   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1881   
;;;1882   			xReturn = pdPASS;
000034  2001              MOVS     r0,#1
000036  60e7              STR      r7,[r4,#0xc]
                  |L30.56|
000038  f3858811          MSR      BASEPRI,r5
;;;1883   		}
;;;1884   		else
;;;1885   		{
;;;1886   			xReturn = pdFAIL;
;;;1887   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1888   		}
;;;1889   	}
;;;1890   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1891   
;;;1892   	return xReturn;
;;;1893   }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L30.64|
000040  2050              MOVS     r0,#0x50
000042  f3808811          MSR      BASEPRI,r0
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
                  |L30.78|
00004e  e7fe              B        |L30.78|
                  |L30.80|
000050  6c00              LDR      r0,[r0,#0x40]         ;1850
000052  b138              CBZ      r0,|L30.100|
000054  2050              MOVS     r0,#0x50              ;1850
000056  f3808811          MSR      BASEPRI,r0            ;1850
00005a  f3bf8f4f          DSB                            ;1850
00005e  f3bf8f6f          ISB                            ;1850
                  |L30.98|
000062  e7fe              B        |L30.98|
                  |L30.100|
000064  2050              MOVS     r0,#0x50              ;1850
000066  f3808811          MSR      BASEPRI,r0            ;1850
00006a  f3bf8f4f          DSB                            ;1850
00006e  f3bf8f6f          ISB                            ;1850
                  |L30.114|
000072  e7fe              B        |L30.114|
;;;1894   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceive||, CODE, READONLY, ALIGN=2

                  xQueueReceive PROC
;;;1239   
;;;1240   BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;1241   {
000004  b083              SUB      sp,sp,#0xc
000006  468a              MOV      r10,r1
000008  0004              MOVS     r4,r0
;;;1242   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0600          MOV      r6,#0
00000e  d003              BEQ      |L31.24|
;;;1243   TimeOut_t xTimeOut;
;;;1244   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1245   
;;;1246   	/* Check the pointer is not NULL. */
;;;1247   	configASSERT( ( pxQueue ) );
;;;1248   
;;;1249   	/* The buffer into which data is received can only be NULL if the data size
;;;1250   	is zero (so no data is copied into the buffer. */
;;;1251   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
000010  f1ba0f00          CMP      r10,#0
000014  d008              BEQ      |L31.40|
000016  e011              B        |L31.60|
                  |L31.24|
000018  2050              MOVS     r0,#0x50
00001a  f3808811          MSR      BASEPRI,r0
00001e  f3bf8f4f          DSB      
000022  f3bf8f6f          ISB      
                  |L31.38|
000026  e7fe              B        |L31.38|
                  |L31.40|
000028  6c20              LDR      r0,[r4,#0x40]
00002a  b138              CBZ      r0,|L31.60|
00002c  2050              MOVS     r0,#0x50
00002e  f3808811          MSR      BASEPRI,r0
000032  f3bf8f4f          DSB      
000036  f3bf8f6f          ISB      
                  |L31.58|
00003a  e7fe              B        |L31.58|
                  |L31.60|
;;;1252   
;;;1253   	/* Cannot block if the scheduler is suspended. */
;;;1254   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1255   	{
;;;1256   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00003c  f7fffffe          BL       xTaskGetSchedulerState
;;;1257   	}
;;;1258   	#endif
;;;1259   
;;;1260   
;;;1261   	/* This function relaxes the coding standard somewhat to allow return
;;;1262   	statements within the function itself.  This is done in the interest
;;;1263   	of execution time efficiency. */
;;;1264   
;;;1265   	for( ;; )
;;;1266   	{
;;;1267   		taskENTER_CRITICAL();
;;;1268   		{
;;;1269   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
;;;1270   
;;;1271   			/* Is there data in the queue now?  To be running the calling task
;;;1272   			must be the highest priority task wanting to access the queue. */
;;;1273   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
;;;1274   			{
;;;1275   				/* Data available, remove one item. */
;;;1276   				prvCopyDataFromQueue( pxQueue, pvBuffer );
;;;1277   				traceQUEUE_RECEIVE( pxQueue );
;;;1278   				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
;;;1279   
;;;1280   				/* There is now space in the queue, were any tasks waiting to
;;;1281   				post to the queue?  If so, unblock the highest priority waiting
;;;1282   				task. */
;;;1283   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1284   				{
;;;1285   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1286   					{
;;;1287   						queueYIELD_IF_USING_PREEMPTION();
000040  f8df90f0          LDR      r9,|L31.308|
000044  2700              MOVS     r7,#0                 ;1256
000046  f04f5880          MOV      r8,#0x10000000
00004a  b948              CBNZ     r0,|L31.96|
00004c  9805              LDR      r0,[sp,#0x14]         ;1256
00004e  b138              CBZ      r0,|L31.96|
000050  2050              MOVS     r0,#0x50              ;1256
000052  f3808811          MSR      BASEPRI,r0            ;1256
000056  f3bf8f4f          DSB                            ;1256
00005a  f3bf8f6f          ISB                            ;1256
                  |L31.94|
00005e  e7fe              B        |L31.94|
                  |L31.96|
000060  f7fffffe          BL       vPortEnterCritical
000064  6ba5              LDR      r5,[r4,#0x38]         ;1269
000066  b1c5              CBZ      r5,|L31.154|
000068  4651              MOV      r1,r10                ;1276
00006a  4620              MOV      r0,r4                 ;1276
00006c  f7fffffe          BL       prvCopyDataFromQueue
000070  1e6d              SUBS     r5,r5,#1              ;1276
000072  63a5              STR      r5,[r4,#0x38]         ;1278
000074  6920              LDR      r0,[r4,#0x10]         ;1283
000076  b150              CBZ      r0,|L31.142|
000078  f1040010          ADD      r0,r4,#0x10           ;1285
00007c  f7fffffe          BL       xTaskRemoveFromEventList
000080  b128              CBZ      r0,|L31.142|
000082  f8c98000          STR      r8,[r9,#0]
000086  f3bf8f4f          DSB      
00008a  f3bf8f6f          ISB      
                  |L31.142|
;;;1288   					}
;;;1289   					else
;;;1290   					{
;;;1291   						mtCOVERAGE_TEST_MARKER();
;;;1292   					}
;;;1293   				}
;;;1294   				else
;;;1295   				{
;;;1296   					mtCOVERAGE_TEST_MARKER();
;;;1297   				}
;;;1298   
;;;1299   				taskEXIT_CRITICAL();
00008e  f7fffffe          BL       vPortExitCritical
;;;1300   				return pdPASS;
000092  2001              MOVS     r0,#1
                  |L31.148|
;;;1301   			}
;;;1302   			else
;;;1303   			{
;;;1304   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1305   				{
;;;1306   					/* The queue was empty and no block time is specified (or
;;;1307   					the block time has expired) so leave now. */
;;;1308   					taskEXIT_CRITICAL();
;;;1309   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1310   					return errQUEUE_EMPTY;
;;;1311   				}
;;;1312   				else if( xEntryTimeSet == pdFALSE )
;;;1313   				{
;;;1314   					/* The queue was empty and a block time was specified so
;;;1315   					configure the timeout structure. */
;;;1316   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1317   					xEntryTimeSet = pdTRUE;
;;;1318   				}
;;;1319   				else
;;;1320   				{
;;;1321   					/* Entry time was already set. */
;;;1322   					mtCOVERAGE_TEST_MARKER();
;;;1323   				}
;;;1324   			}
;;;1325   		}
;;;1326   		taskEXIT_CRITICAL();
;;;1327   
;;;1328   		/* Interrupts and other tasks can send to and receive from the queue
;;;1329   		now the critical section has been exited. */
;;;1330   
;;;1331   		vTaskSuspendAll();
;;;1332   		prvLockQueue( pxQueue );
;;;1333   
;;;1334   		/* Update the timeout state to see if it has expired yet. */
;;;1335   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1336   		{
;;;1337   			/* The timeout has not expired.  If the queue is still empty place
;;;1338   			the task on the list of tasks waiting to receive from the queue. */
;;;1339   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1340   			{
;;;1341   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1342   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1343   				prvUnlockQueue( pxQueue );
;;;1344   				if( xTaskResumeAll() == pdFALSE )
;;;1345   				{
;;;1346   					portYIELD_WITHIN_API();
;;;1347   				}
;;;1348   				else
;;;1349   				{
;;;1350   					mtCOVERAGE_TEST_MARKER();
;;;1351   				}
;;;1352   			}
;;;1353   			else
;;;1354   			{
;;;1355   				/* The queue contains data again.  Loop back to try and read the
;;;1356   				data. */
;;;1357   				prvUnlockQueue( pxQueue );
;;;1358   				( void ) xTaskResumeAll();
;;;1359   			}
;;;1360   		}
;;;1361   		else
;;;1362   		{
;;;1363   			/* Timed out.  If there is no data in the queue exit, otherwise loop
;;;1364   			back and attempt to read the data. */
;;;1365   			prvUnlockQueue( pxQueue );
;;;1366   			( void ) xTaskResumeAll();
;;;1367   
;;;1368   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1369   			{
;;;1370   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1371   				return errQUEUE_EMPTY;
;;;1372   			}
;;;1373   			else
;;;1374   			{
;;;1375   				mtCOVERAGE_TEST_MARKER();
;;;1376   			}
;;;1377   		}
;;;1378   	}
;;;1379   }
000094  b006              ADD      sp,sp,#0x18
000096  e8bd87f0          POP      {r4-r10,pc}
                  |L31.154|
00009a  9805              LDR      r0,[sp,#0x14]         ;1304
00009c  b108              CBZ      r0,|L31.162|
00009e  b11e              CBZ      r6,|L31.168|
0000a0  e006              B        |L31.176|
                  |L31.162|
0000a2  f7fffffe          BL       vPortExitCritical
0000a6  e027              B        |L31.248|
                  |L31.168|
0000a8  4668              MOV      r0,sp                 ;1316
0000aa  f7fffffe          BL       vTaskInternalSetTimeOutState
0000ae  2601              MOVS     r6,#1                 ;1317
                  |L31.176|
0000b0  f7fffffe          BL       vPortExitCritical
0000b4  f7fffffe          BL       vTaskSuspendAll
0000b8  f7fffffe          BL       vPortEnterCritical
0000bc  f9940044          LDRSB    r0,[r4,#0x44]         ;1332
0000c0  1c40              ADDS     r0,r0,#1              ;1332
0000c2  d101              BNE      |L31.200|
0000c4  f8847044          STRB     r7,[r4,#0x44]         ;1332
                  |L31.200|
0000c8  f9940045          LDRSB    r0,[r4,#0x45]         ;1332
0000cc  1c40              ADDS     r0,r0,#1              ;1332
0000ce  d101              BNE      |L31.212|
0000d0  f8847045          STRB     r7,[r4,#0x45]         ;1332
                  |L31.212|
0000d4  f7fffffe          BL       vPortExitCritical
0000d8  a905              ADD      r1,sp,#0x14           ;1335
0000da  4668              MOV      r0,sp                 ;1335
0000dc  f7fffffe          BL       xTaskCheckForTimeOut
0000e0  2800              CMP      r0,#0                 ;1335
0000e2  4620              MOV      r0,r4                 ;1365
0000e4  d00a              BEQ      |L31.252|
0000e6  f7fffffe          BL       prvUnlockQueue
0000ea  f7fffffe          BL       xTaskResumeAll
0000ee  4620              MOV      r0,r4                 ;1368
0000f0  f7fffffe          BL       prvIsQueueEmpty
0000f4  2800              CMP      r0,#0                 ;1368
0000f6  d0b3              BEQ      |L31.96|
                  |L31.248|
0000f8  2000              MOVS     r0,#0                 ;1371
0000fa  e7cb              B        |L31.148|
                  |L31.252|
0000fc  f7fffffe          BL       prvIsQueueEmpty
000100  b190              CBZ      r0,|L31.296|
000102  f1040024          ADD      r0,r4,#0x24           ;1342
000106  9905              LDR      r1,[sp,#0x14]         ;1342
000108  f7fffffe          BL       vTaskPlaceOnEventList
00010c  4620              MOV      r0,r4                 ;1343
00010e  f7fffffe          BL       prvUnlockQueue
000112  f7fffffe          BL       xTaskResumeAll
000116  2800              CMP      r0,#0                 ;1344
000118  d1a2              BNE      |L31.96|
00011a  f8c98000          STR      r8,[r9,#0]            ;1346
00011e  f3bf8f4f          DSB                            ;1346
000122  f3bf8f6f          ISB                            ;1346
000126  e79b              B        |L31.96|
                  |L31.296|
000128  4620              MOV      r0,r4                 ;1357
00012a  f7fffffe          BL       prvUnlockQueue
00012e  f7fffffe          BL       xTaskResumeAll
000132  e795              B        |L31.96|
;;;1380   /*-----------------------------------------------------------*/
                          ENDP

                  |L31.308|
                          DCD      0xe000ed04

                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1750   
;;;1751   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1752   {
000004  4690              MOV      r8,r2
000006  4689              MOV      r9,r1
000008  0004              MOVS     r4,r0
00000a  d003              BEQ      |L32.20|
;;;1753   BaseType_t xReturn;
;;;1754   UBaseType_t uxSavedInterruptStatus;
;;;1755   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1756   
;;;1757   	configASSERT( pxQueue );
;;;1758   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00000c  f1b90f00          CMP      r9,#0
000010  d008              BEQ      |L32.36|
000012  e011              B        |L32.56|
                  |L32.20|
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
                  |L32.34|
000022  e7fe              B        |L32.34|
                  |L32.36|
000024  6c20              LDR      r0,[r4,#0x40]
000026  b138              CBZ      r0,|L32.56|
000028  2050              MOVS     r0,#0x50
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L32.54|
000036  e7fe              B        |L32.54|
                  |L32.56|
;;;1759   
;;;1760   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1761   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1762   	above the maximum system call priority are kept permanently enabled, even
;;;1763   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1764   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1765   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1766   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1767   	assigned a priority above the configured maximum system call priority.
;;;1768   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1769   	that have been assigned a priority at or (logically) below the maximum
;;;1770   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1771   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1772   	More information (albeit Cortex-M specific) is provided on the following
;;;1773   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1774   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000038  f7fffffe          BL       vPortValidateInterruptPriority
00003c  2050              MOVS     r0,#0x50
00003e  f3ef8711          MRS      r7,BASEPRI
000042  f3808811          MSR      BASEPRI,r0
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
;;;1775   
;;;1776   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1777   	{
;;;1778   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00004e  6ba6              LDR      r6,[r4,#0x38]
;;;1779   
;;;1780   		/* Cannot block in an ISR, so check there is data available. */
;;;1781   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000050  b1f6              CBZ      r6,|L32.144|
;;;1782   		{
;;;1783   			const int8_t cRxLock = pxQueue->cRxLock;
000052  f9945044          LDRSB    r5,[r4,#0x44]
;;;1784   
;;;1785   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1786   
;;;1787   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000056  4649              MOV      r1,r9
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       prvCopyDataFromQueue
00005e  1e76              SUBS     r6,r6,#1
;;;1788   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
000060  63a6              STR      r6,[r4,#0x38]
;;;1789   
;;;1790   			/* If the queue is locked the event list will not be modified.
;;;1791   			Instead update the lock count so the task that unlocks the queue
;;;1792   			will know that an ISR has removed data while the queue was
;;;1793   			locked. */
;;;1794   			if( cRxLock == queueUNLOCKED )
000062  1c68              ADDS     r0,r5,#1
000064  d004              BEQ      |L32.112|
000066  1c6d              ADDS     r5,r5,#1
;;;1795   			{
;;;1796   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1797   				{
;;;1798   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1799   					{
;;;1800   						/* The task waiting has a higher priority than us so
;;;1801   						force a context switch. */
;;;1802   						if( pxHigherPriorityTaskWoken != NULL )
;;;1803   						{
;;;1804   							*pxHigherPriorityTaskWoken = pdTRUE;
;;;1805   						}
;;;1806   						else
;;;1807   						{
;;;1808   							mtCOVERAGE_TEST_MARKER();
;;;1809   						}
;;;1810   					}
;;;1811   					else
;;;1812   					{
;;;1813   						mtCOVERAGE_TEST_MARKER();
;;;1814   					}
;;;1815   				}
;;;1816   				else
;;;1817   				{
;;;1818   					mtCOVERAGE_TEST_MARKER();
;;;1819   				}
;;;1820   			}
;;;1821   			else
;;;1822   			{
;;;1823   				/* Increment the lock count so the task that unlocks the queue
;;;1824   				knows that data was removed while it was locked. */
;;;1825   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
000068  f8845044          STRB     r5,[r4,#0x44]
                  |L32.108|
;;;1826   			}
;;;1827   
;;;1828   			xReturn = pdPASS;
00006c  2001              MOVS     r0,#1
;;;1829   		}
00006e  e010              B        |L32.146|
                  |L32.112|
000070  6920              LDR      r0,[r4,#0x10]         ;1796
000072  2800              CMP      r0,#0                 ;1796
000074  d0fa              BEQ      |L32.108|
000076  f1040010          ADD      r0,r4,#0x10           ;1798
00007a  f7fffffe          BL       xTaskRemoveFromEventList
00007e  2800              CMP      r0,#0                 ;1798
000080  d0f4              BEQ      |L32.108|
000082  f1b80f00          CMP      r8,#0                 ;1802
000086  d0f1              BEQ      |L32.108|
000088  2101              MOVS     r1,#1                 ;1804
00008a  f8c81000          STR      r1,[r8,#0]            ;1804
00008e  e7ed              B        |L32.108|
                  |L32.144|
;;;1830   		else
;;;1831   		{
;;;1832   			xReturn = pdFAIL;
000090  2000              MOVS     r0,#0
                  |L32.146|
000092  f3878811          MSR      BASEPRI,r7
;;;1833   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1834   		}
;;;1835   	}
;;;1836   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1837   
;;;1838   	return xReturn;
;;;1839   }
000096  e8bd87f0          POP      {r4-r10,pc}
;;;1840   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueRemoveFromSet||, CODE, READONLY, ALIGN=1

                  xQueueRemoveFromSet PROC
;;;2784   
;;;2785   	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
000000  b510              PUSH     {r4,lr}
;;;2786   	{
000002  4604              MOV      r4,r0
;;;2787   	BaseType_t xReturn;
;;;2788   	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
;;;2789   
;;;2790   		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
000004  6c80              LDR      r0,[r0,#0x48]
000006  4288              CMP      r0,r1
000008  d101              BNE      |L33.14|
;;;2791   		{
;;;2792   			/* The queue was not a member of the set. */
;;;2793   			xReturn = pdFAIL;
;;;2794   		}
;;;2795   		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
00000a  6ba0              LDR      r0,[r4,#0x38]
00000c  b108              CBZ      r0,|L33.18|
                  |L33.14|
00000e  2000              MOVS     r0,#0                 ;2793
;;;2796   		{
;;;2797   			/* It is dangerous to remove a queue from a set when the queue is
;;;2798   			not empty because the queue set will still hold pending events for
;;;2799   			the queue. */
;;;2800   			xReturn = pdFAIL;
;;;2801   		}
;;;2802   		else
;;;2803   		{
;;;2804   			taskENTER_CRITICAL();
;;;2805   			{
;;;2806   				/* The queue is no longer contained in the set. */
;;;2807   				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
;;;2808   			}
;;;2809   			taskEXIT_CRITICAL();
;;;2810   			xReturn = pdPASS;
;;;2811   		}
;;;2812   
;;;2813   		return xReturn;
;;;2814   	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
000010  bd10              POP      {r4,pc}
                  |L33.18|
000012  f7fffffe          BL       vPortEnterCritical
000016  2000              MOVS     r0,#0                 ;2807
000018  64a0              STR      r0,[r4,#0x48]         ;2809
00001a  f7fffffe          BL       vPortExitCritical
00001e  2001              MOVS     r0,#1                 ;2810
000020  bd10              POP      {r4,pc}
;;;2815   
                          ENDP


                          AREA ||i.xQueueSelectFromSet||, CODE, READONLY, ALIGN=1

                  xQueueSelectFromSet PROC
;;;2820   
;;;2821   	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
000000  b508              PUSH     {r3,lr}
;;;2822   	{
;;;2823   	QueueSetMemberHandle_t xReturn = NULL;
000002  2300              MOVS     r3,#0
;;;2824   
;;;2825   		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */
000004  460a              MOV      r2,r1
000006  4669              MOV      r1,sp
000008  9300              STR      r3,[sp,#0]
00000a  f7fffffe          BL       xQueueReceive
;;;2826   		return xReturn;
00000e  9800              LDR      r0,[sp,#0]
;;;2827   	}
000010  bd08              POP      {r3,pc}
;;;2828   
                          ENDP


                          AREA ||i.xQueueSelectFromSetFromISR||, CODE, READONLY, ALIGN=1

                  xQueueSelectFromSetFromISR PROC
;;;2833   
;;;2834   	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
000000  b508              PUSH     {r3,lr}
;;;2835   	{
;;;2836   	QueueSetMemberHandle_t xReturn = NULL;
000002  2100              MOVS     r1,#0
;;;2837   
;;;2838   		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
000004  460a              MOV      r2,r1
000006  9100              STR      r1,[sp,#0]
000008  4669              MOV      r1,sp
00000a  f7fffffe          BL       xQueueReceiveFromISR
;;;2839   		return xReturn;
00000e  9800              LDR      r0,[sp,#0]
;;;2840   	}
000010  bd08              POP      {r3,pc}
;;;2841   
                          ENDP


                          AREA ||i.xQueueSemaphoreTake||, CODE, READONLY, ALIGN=2

                  xQueueSemaphoreTake PROC
;;;1381   
;;;1382   BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
000000  e92d43f3          PUSH     {r0,r1,r4-r9,lr}
;;;1383   {
;;;1384   BaseType_t xEntryTimeSet = pdFALSE;
000004  f04f0500          MOV      r5,#0
000008  b083              SUB      sp,sp,#0xc            ;1383
00000a  0004              MOVS     r4,r0                 ;1383
;;;1385   TimeOut_t xTimeOut;
;;;1386   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1387   
;;;1388   #if( configUSE_MUTEXES == 1 )
;;;1389   	BaseType_t xInheritanceOccurred = pdFALSE;
00000c  462e              MOV      r6,r5
00000e  d009              BEQ      |L36.36|
;;;1390   #endif
;;;1391   
;;;1392   	/* Check the queue pointer is not NULL. */
;;;1393   	configASSERT( ( pxQueue ) );
;;;1394   
;;;1395   	/* Check this really is a semaphore, in which case the item size will be
;;;1396   	0. */
;;;1397   	configASSERT( pxQueue->uxItemSize == 0 );
000010  6c20              LDR      r0,[r4,#0x40]
000012  b178              CBZ      r0,|L36.52|
000014  2050              MOVS     r0,#0x50
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
                  |L36.34|
000022  e7fe              B        |L36.34|
                  |L36.36|
000024  2050              MOVS     r0,#0x50
000026  f3808811          MSR      BASEPRI,r0
00002a  f3bf8f4f          DSB      
00002e  f3bf8f6f          ISB      
                  |L36.50|
000032  e7fe              B        |L36.50|
                  |L36.52|
;;;1398   
;;;1399   	/* Cannot block if the scheduler is suspended. */
;;;1400   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1401   	{
;;;1402   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
000034  f7fffffe          BL       xTaskGetSchedulerState
;;;1403   	}
;;;1404   	#endif
;;;1405   
;;;1406   
;;;1407   	/* This function relaxes the coding standard somewhat to allow return
;;;1408   	statements within the function itself.  This is done in the interest
;;;1409   	of execution time efficiency. */
;;;1410   
;;;1411   	for( ;; )
;;;1412   	{
;;;1413   		taskENTER_CRITICAL();
;;;1414   		{
;;;1415   			/* Semaphores are queues with an item size of 0, and where the
;;;1416   			number of messages in the queue is the semaphore's count value. */
;;;1417   			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
;;;1418   
;;;1419   			/* Is there data in the queue now?  To be running the calling task
;;;1420   			must be the highest priority task wanting to access the queue. */
;;;1421   			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
;;;1422   			{
;;;1423   				traceQUEUE_RECEIVE( pxQueue );
;;;1424   
;;;1425   				/* Semaphores are queues with a data size of zero and where the
;;;1426   				messages waiting is the semaphore's count.  Reduce the count. */
;;;1427   				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
;;;1428   
;;;1429   				#if ( configUSE_MUTEXES == 1 )
;;;1430   				{
;;;1431   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1432   					{
;;;1433   						/* Record the information required to implement
;;;1434   						priority inheritance should it become necessary. */
;;;1435   						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
;;;1436   					}
;;;1437   					else
;;;1438   					{
;;;1439   						mtCOVERAGE_TEST_MARKER();
;;;1440   					}
;;;1441   				}
;;;1442   				#endif /* configUSE_MUTEXES */
;;;1443   
;;;1444   				/* Check to see if other tasks are blocked waiting to give the
;;;1445   				semaphore, and if so, unblock the highest priority such task. */
;;;1446   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1447   				{
;;;1448   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1449   					{
;;;1450   						queueYIELD_IF_USING_PREEMPTION();
000038  f8df9138          LDR      r9,|L36.372|
00003c  2700              MOVS     r7,#0                 ;1402
00003e  f04f5880          MOV      r8,#0x10000000
000042  b948              CBNZ     r0,|L36.88|
000044  9804              LDR      r0,[sp,#0x10]         ;1402
000046  b138              CBZ      r0,|L36.88|
000048  2050              MOVS     r0,#0x50              ;1402
00004a  f3808811          MSR      BASEPRI,r0            ;1402
00004e  f3bf8f4f          DSB                            ;1402
000052  f3bf8f6f          ISB                            ;1402
                  |L36.86|
000056  e7fe              B        |L36.86|
                  |L36.88|
000058  f7fffffe          BL       vPortEnterCritical
00005c  6ba0              LDR      r0,[r4,#0x38]         ;1417
00005e  b1c8              CBZ      r0,|L36.148|
000060  1e40              SUBS     r0,r0,#1              ;1421
000062  63a0              STR      r0,[r4,#0x38]         ;1427
000064  6820              LDR      r0,[r4,#0]            ;1431
000066  b910              CBNZ     r0,|L36.110|
000068  f7fffffe          BL       pvTaskIncrementMutexHeldCount
00006c  6060              STR      r0,[r4,#4]            ;1435
                  |L36.110|
00006e  6920              LDR      r0,[r4,#0x10]         ;1446
000070  b150              CBZ      r0,|L36.136|
000072  f1040010          ADD      r0,r4,#0x10           ;1448
000076  f7fffffe          BL       xTaskRemoveFromEventList
00007a  b128              CBZ      r0,|L36.136|
00007c  f8c98000          STR      r8,[r9,#0]
000080  f3bf8f4f          DSB      
000084  f3bf8f6f          ISB      
                  |L36.136|
;;;1451   					}
;;;1452   					else
;;;1453   					{
;;;1454   						mtCOVERAGE_TEST_MARKER();
;;;1455   					}
;;;1456   				}
;;;1457   				else
;;;1458   				{
;;;1459   					mtCOVERAGE_TEST_MARKER();
;;;1460   				}
;;;1461   
;;;1462   				taskEXIT_CRITICAL();
000088  f7fffffe          BL       vPortExitCritical
;;;1463   				return pdPASS;
00008c  2001              MOVS     r0,#1
                  |L36.142|
;;;1464   			}
;;;1465   			else
;;;1466   			{
;;;1467   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1468   				{
;;;1469   					/* For inheritance to have occurred there must have been an
;;;1470   					initial timeout, and an adjusted timeout cannot become 0, as
;;;1471   					if it were 0 the function would have exited. */
;;;1472   					#if( configUSE_MUTEXES == 1 )
;;;1473   					{
;;;1474   						configASSERT( xInheritanceOccurred == pdFALSE );
;;;1475   					}
;;;1476   					#endif /* configUSE_MUTEXES */
;;;1477   
;;;1478   					/* The semaphore count was 0 and no block time is specified
;;;1479   					(or the block time has expired) so exit now. */
;;;1480   					taskEXIT_CRITICAL();
;;;1481   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1482   					return errQUEUE_EMPTY;
;;;1483   				}
;;;1484   				else if( xEntryTimeSet == pdFALSE )
;;;1485   				{
;;;1486   					/* The semaphore count was 0 and a block time was specified
;;;1487   					so configure the timeout structure ready to block. */
;;;1488   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1489   					xEntryTimeSet = pdTRUE;
;;;1490   				}
;;;1491   				else
;;;1492   				{
;;;1493   					/* Entry time was already set. */
;;;1494   					mtCOVERAGE_TEST_MARKER();
;;;1495   				}
;;;1496   			}
;;;1497   		}
;;;1498   		taskEXIT_CRITICAL();
;;;1499   
;;;1500   		/* Interrupts and other tasks can give to and take from the semaphore
;;;1501   		now the critical section has been exited. */
;;;1502   
;;;1503   		vTaskSuspendAll();
;;;1504   		prvLockQueue( pxQueue );
;;;1505   
;;;1506   		/* Update the timeout state to see if it has expired yet. */
;;;1507   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1508   		{
;;;1509   			/* A block time is specified and not expired.  If the semaphore
;;;1510   			count is 0 then enter the Blocked state to wait for a semaphore to
;;;1511   			become available.  As semaphores are implemented with queues the
;;;1512   			queue being empty is equivalent to the semaphore count being 0. */
;;;1513   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1514   			{
;;;1515   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1516   
;;;1517   				#if ( configUSE_MUTEXES == 1 )
;;;1518   				{
;;;1519   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1520   					{
;;;1521   						taskENTER_CRITICAL();
;;;1522   						{
;;;1523   							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1524   						}
;;;1525   						taskEXIT_CRITICAL();
;;;1526   					}
;;;1527   					else
;;;1528   					{
;;;1529   						mtCOVERAGE_TEST_MARKER();
;;;1530   					}
;;;1531   				}
;;;1532   				#endif
;;;1533   
;;;1534   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1535   				prvUnlockQueue( pxQueue );
;;;1536   				if( xTaskResumeAll() == pdFALSE )
;;;1537   				{
;;;1538   					portYIELD_WITHIN_API();
;;;1539   				}
;;;1540   				else
;;;1541   				{
;;;1542   					mtCOVERAGE_TEST_MARKER();
;;;1543   				}
;;;1544   			}
;;;1545   			else
;;;1546   			{
;;;1547   				/* There was no timeout and the semaphore count was not 0, so
;;;1548   				attempt to take the semaphore again. */
;;;1549   				prvUnlockQueue( pxQueue );
;;;1550   				( void ) xTaskResumeAll();
;;;1551   			}
;;;1552   		}
;;;1553   		else
;;;1554   		{
;;;1555   			/* Timed out. */
;;;1556   			prvUnlockQueue( pxQueue );
;;;1557   			( void ) xTaskResumeAll();
;;;1558   
;;;1559   			/* If the semaphore count is 0 exit now as the timeout has
;;;1560   			expired.  Otherwise return to attempt to take the semaphore that is
;;;1561   			known to be available.  As semaphores are implemented by queues the
;;;1562   			queue being empty is equivalent to the semaphore count being 0. */
;;;1563   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1564   			{
;;;1565   				#if ( configUSE_MUTEXES == 1 )
;;;1566   				{
;;;1567   					/* xInheritanceOccurred could only have be set if
;;;1568   					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
;;;1569   					test the mutex type again to check it is actually a mutex. */
;;;1570   					if( xInheritanceOccurred != pdFALSE )
;;;1571   					{
;;;1572   						taskENTER_CRITICAL();
;;;1573   						{
;;;1574   							UBaseType_t uxHighestWaitingPriority;
;;;1575   
;;;1576   							/* This task blocking on the mutex caused another
;;;1577   							task to inherit this task's priority.  Now this task
;;;1578   							has timed out the priority should be disinherited
;;;1579   							again, but only as low as the next highest priority
;;;1580   							task that is waiting for the same mutex. */
;;;1581   							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
;;;1582   							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
;;;1583   						}
;;;1584   						taskEXIT_CRITICAL();
;;;1585   					}
;;;1586   				}
;;;1587   				#endif /* configUSE_MUTEXES */
;;;1588   
;;;1589   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1590   				return errQUEUE_EMPTY;
;;;1591   			}
;;;1592   			else
;;;1593   			{
;;;1594   				mtCOVERAGE_TEST_MARKER();
;;;1595   			}
;;;1596   		}
;;;1597   	}
;;;1598   }
00008e  b005              ADD      sp,sp,#0x14
000090  e8bd83f0          POP      {r4-r9,pc}
                  |L36.148|
000094  9804              LDR      r0,[sp,#0x10]         ;1467
000096  b108              CBZ      r0,|L36.156|
000098  b165              CBZ      r5,|L36.180|
00009a  e00f              B        |L36.188|
                  |L36.156|
00009c  b13e              CBZ      r6,|L36.174|
00009e  2050              MOVS     r0,#0x50              ;1474
0000a0  f3808811          MSR      BASEPRI,r0            ;1474
0000a4  f3bf8f4f          DSB                            ;1474
0000a8  f3bf8f6f          ISB                            ;1474
                  |L36.172|
0000ac  e7fe              B        |L36.172|
                  |L36.174|
0000ae  f7fffffe          BL       vPortExitCritical
0000b2  e05d              B        |L36.368|
                  |L36.180|
0000b4  4668              MOV      r0,sp                 ;1488
0000b6  f7fffffe          BL       vTaskInternalSetTimeOutState
0000ba  2501              MOVS     r5,#1                 ;1489
                  |L36.188|
0000bc  f7fffffe          BL       vPortExitCritical
0000c0  f7fffffe          BL       vTaskSuspendAll
0000c4  f7fffffe          BL       vPortEnterCritical
0000c8  f9940044          LDRSB    r0,[r4,#0x44]         ;1504
0000cc  1c40              ADDS     r0,r0,#1              ;1504
0000ce  d101              BNE      |L36.212|
0000d0  f8847044          STRB     r7,[r4,#0x44]         ;1504
                  |L36.212|
0000d4  f9940045          LDRSB    r0,[r4,#0x45]         ;1504
0000d8  1c40              ADDS     r0,r0,#1              ;1504
0000da  d101              BNE      |L36.224|
0000dc  f8847045          STRB     r7,[r4,#0x45]         ;1504
                  |L36.224|
0000e0  f7fffffe          BL       vPortExitCritical
0000e4  a904              ADD      r1,sp,#0x10           ;1507
0000e6  4668              MOV      r0,sp                 ;1507
0000e8  f7fffffe          BL       xTaskCheckForTimeOut
0000ec  2800              CMP      r0,#0                 ;1507
0000ee  4620              MOV      r0,r4                 ;1556
0000f0  d012              BEQ      |L36.280|
0000f2  f7fffffe          BL       prvUnlockQueue
0000f6  f7fffffe          BL       xTaskResumeAll
0000fa  4620              MOV      r0,r4                 ;1563
0000fc  f7fffffe          BL       prvIsQueueEmpty
000100  2800              CMP      r0,#0                 ;1563
000102  d0a9              BEQ      |L36.88|
000104  b39e              CBZ      r6,|L36.366|
000106  f7fffffe          BL       vPortEnterCritical
00010a  6a60              LDR      r0,[r4,#0x24]         ;1572
00010c  b350              CBZ      r0,|L36.356|
00010e  6b20              LDR      r0,[r4,#0x30]         ;1572
000110  6800              LDR      r0,[r0,#0]            ;1572
000112  f1c00105          RSB      r1,r0,#5              ;1572
000116  e026              B        |L36.358|
                  |L36.280|
000118  f7fffffe          BL       prvIsQueueEmpty
00011c  b1e0              CBZ      r0,|L36.344|
00011e  6820              LDR      r0,[r4,#0]            ;1519
000120  b938              CBNZ     r0,|L36.306|
000122  f7fffffe          BL       vPortEnterCritical
000126  6860              LDR      r0,[r4,#4]            ;1523
000128  f7fffffe          BL       xTaskPriorityInherit
00012c  4606              MOV      r6,r0                 ;1523
00012e  f7fffffe          BL       vPortExitCritical
                  |L36.306|
000132  f1040024          ADD      r0,r4,#0x24           ;1534
000136  9904              LDR      r1,[sp,#0x10]         ;1534
000138  f7fffffe          BL       vTaskPlaceOnEventList
00013c  4620              MOV      r0,r4                 ;1535
00013e  f7fffffe          BL       prvUnlockQueue
000142  f7fffffe          BL       xTaskResumeAll
000146  2800              CMP      r0,#0                 ;1536
000148  d186              BNE      |L36.88|
00014a  f8c98000          STR      r8,[r9,#0]            ;1538
00014e  f3bf8f4f          DSB                            ;1538
000152  f3bf8f6f          ISB                            ;1538
000156  e77f              B        |L36.88|
                  |L36.344|
000158  4620              MOV      r0,r4                 ;1549
00015a  f7fffffe          BL       prvUnlockQueue
00015e  f7fffffe          BL       xTaskResumeAll
000162  e779              B        |L36.88|
                  |L36.356|
000164  2100              MOVS     r1,#0                 ;1550
                  |L36.358|
000166  6860              LDR      r0,[r4,#4]            ;1582
000168  f7fffffe          BL       vTaskPriorityDisinheritAfterTimeout
00016c  e79f              B        |L36.174|
                  |L36.366|
00016e  e7ff              B        |L36.368|
                  |L36.368|
000170  2000              MOVS     r0,#0                 ;1590
000172  e78c              B        |L36.142|
;;;1599   /*-----------------------------------------------------------*/
                          ENDP

                  |L36.372|
                          DCD      0xe000ed04

                          AREA ||i.xQueueTakeMutexRecursive||, CODE, READONLY, ALIGN=1

                  xQueueTakeMutexRecursive PROC
;;;629    
;;;630    	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;631    	{
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d009              BEQ      |L37.28|
;;;632    	BaseType_t xReturn;
;;;633    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
;;;634    
;;;635    		configASSERT( pxMutex );
;;;636    
;;;637    		/* Comments regarding mutual exclusion as per those within
;;;638    		xQueueGiveMutexRecursive(). */
;;;639    
;;;640    		traceTAKE_MUTEX_RECURSIVE( pxMutex );
;;;641    
;;;642    		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
000008  f7fffffe          BL       xTaskGetCurrentTaskHandle
00000c  6861              LDR      r1,[r4,#4]
00000e  4288              CMP      r0,r1
000010  d10c              BNE      |L37.44|
;;;643    		{
;;;644    			( pxMutex->u.uxRecursiveCallCount )++;
000012  68e0              LDR      r0,[r4,#0xc]
000014  1c40              ADDS     r0,r0,#1
;;;645    			xReturn = pdPASS;
000016  60e0              STR      r0,[r4,#0xc]
000018  2001              MOVS     r0,#1
                  |L37.26|
;;;646    		}
;;;647    		else
;;;648    		{
;;;649    			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
;;;650    
;;;651    			/* pdPASS will only be returned if the mutex was successfully
;;;652    			obtained.  The calling task may have entered the Blocked state
;;;653    			before reaching here. */
;;;654    			if( xReturn != pdFAIL )
;;;655    			{
;;;656    				( pxMutex->u.uxRecursiveCallCount )++;
;;;657    			}
;;;658    			else
;;;659    			{
;;;660    				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;661    			}
;;;662    		}
;;;663    
;;;664    		return xReturn;
;;;665    	}
00001a  bd70              POP      {r4-r6,pc}
                  |L37.28|
00001c  2050              MOVS     r0,#0x50
00001e  f3808811          MSR      BASEPRI,r0
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
                  |L37.42|
00002a  e7fe              B        |L37.42|
                  |L37.44|
00002c  4629              MOV      r1,r5                 ;649
00002e  4620              MOV      r0,r4                 ;649
000030  f7fffffe          BL       xQueueSemaphoreTake
000034  2800              CMP      r0,#0                 ;654
000036  d0f0              BEQ      |L37.26|
000038  68e1              LDR      r1,[r4,#0xc]          ;656
00003a  1c49              ADDS     r1,r1,#1              ;656
00003c  60e1              STR      r1,[r4,#0xc]          ;656
00003e  bd70              POP      {r4-r6,pc}
;;;666    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xQueueRegistry
                          %        64

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\ThirdParty\\FreeRTOS\\Source\\queue.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_48e2f297____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_queue_c_48e2f297____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_48e2f297____REVSH|
#line 402
|__asm___7_queue_c_48e2f297____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_48e2f297____RRX|
#line 587
|__asm___7_queue_c_48e2f297____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
